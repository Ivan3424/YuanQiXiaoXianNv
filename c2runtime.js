// Generated by Construct 2, the HTML5 game and app creator :: http://www.scirra.com
var cr = {};
cr.plugins_ = {};
cr.behaviors = {};
if (typeof Object.getPrototypeOf !== "function")
{
	if (typeof "test".__proto__ === "object")
	{
		Object.getPrototypeOf = function(object) {
			return object.__proto__;
		};
	}
	else
	{
		Object.getPrototypeOf = function(object) {
			return object.constructor.prototype;
		};
	}
}
(function(){
	cr.logexport = function (msg)
	{
		if (window.console && window.console.log)
			window.console.log(msg);
	};
	cr.logerror = function (msg)
	{
		if (window.console && window.console.error)
			window.console.error(msg);
	};
	cr.seal = function(x)
	{
		return x;
	};
	cr.freeze = function(x)
	{
		return x;
	};
	cr.is_undefined = function (x)
	{
		return typeof x === "undefined";
	};
	cr.is_number = function (x)
	{
		return typeof x === "number";
	};
	cr.is_string = function (x)
	{
		return typeof x === "string";
	};
	cr.isPOT = function (x)
	{
		return x > 0 && ((x - 1) & x) === 0;
	};
	cr.nextHighestPowerOfTwo = function(x) {
		--x;
		for (var i = 1; i < 32; i <<= 1) {
			x = x | x >> i;
		}
		return x + 1;
	}
	cr.abs = function (x)
	{
		return (x < 0 ? -x : x);
	};
	cr.max = function (a, b)
	{
		return (a > b ? a : b);
	};
	cr.min = function (a, b)
	{
		return (a < b ? a : b);
	};
	cr.PI = Math.PI;
	cr.round = function (x)
	{
		return (x + 0.5) | 0;
	};
	cr.floor = function (x)
	{
		if (x >= 0)
			return x | 0;
		else
			return (x | 0) - 1;		// correctly round down when negative
	};
	cr.ceil = function (x)
	{
		var f = x | 0;
		return (f === x ? f : f + 1);
	};
	function Vector2(x, y)
	{
		this.x = x;
		this.y = y;
		cr.seal(this);
	};
	Vector2.prototype.offset = function (px, py)
	{
		this.x += px;
		this.y += py;
		return this;
	};
	Vector2.prototype.mul = function (px, py)
	{
		this.x *= px;
		this.y *= py;
		return this;
	};
	cr.vector2 = Vector2;
	cr.segments_intersect = function(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)
	{
		var max_ax, min_ax, max_ay, min_ay, max_bx, min_bx, max_by, min_by;
		if (a1x < a2x)
		{
			min_ax = a1x;
			max_ax = a2x;
		}
		else
		{
			min_ax = a2x;
			max_ax = a1x;
		}
		if (b1x < b2x)
		{
			min_bx = b1x;
			max_bx = b2x;
		}
		else
		{
			min_bx = b2x;
			max_bx = b1x;
		}
		if (max_ax < min_bx || min_ax > max_bx)
			return false;
		if (a1y < a2y)
		{
			min_ay = a1y;
			max_ay = a2y;
		}
		else
		{
			min_ay = a2y;
			max_ay = a1y;
		}
		if (b1y < b2y)
		{
			min_by = b1y;
			max_by = b2y;
		}
		else
		{
			min_by = b2y;
			max_by = b1y;
		}
		if (max_ay < min_by || min_ay > max_by)
			return false;
		var dpx = b1x - a1x + b2x - a2x;
		var dpy = b1y - a1y + b2y - a2y;
		var qax = a2x - a1x;
		var qay = a2y - a1y;
		var qbx = b2x - b1x;
		var qby = b2y - b1y;
		var d = cr.abs(qay * qbx - qby * qax);
		var la = qbx * dpy - qby * dpx;
		if (cr.abs(la) > d)
			return false;
		var lb = qax * dpy - qay * dpx;
		return cr.abs(lb) <= d;
	};
	function Rect(left, top, right, bottom)
	{
		this.set(left, top, right, bottom);
		cr.seal(this);
	};
	Rect.prototype.set = function (left, top, right, bottom)
	{
		this.left = left;
		this.top = top;
		this.right = right;
		this.bottom = bottom;
	};
	Rect.prototype.copy = function (r)
	{
		this.left = r.left;
		this.top = r.top;
		this.right = r.right;
		this.bottom = r.bottom;
	};
	Rect.prototype.width = function ()
	{
		return this.right - this.left;
	};
	Rect.prototype.height = function ()
	{
		return this.bottom - this.top;
	};
	Rect.prototype.offset = function (px, py)
	{
		this.left += px;
		this.top += py;
		this.right += px;
		this.bottom += py;
		return this;
	};
	Rect.prototype.normalize = function ()
	{
		var temp = 0;
		if (this.left > this.right)
		{
			temp = this.left;
			this.left = this.right;
			this.right = temp;
		}
		if (this.top > this.bottom)
		{
			temp = this.top;
			this.top = this.bottom;
			this.bottom = temp;
		}
	};
	Rect.prototype.intersects_rect = function (rc)
	{
		return !(rc.right < this.left || rc.bottom < this.top || rc.left > this.right || rc.top > this.bottom);
	};
	Rect.prototype.intersects_rect_off = function (rc, ox, oy)
	{
		return !(rc.right + ox < this.left || rc.bottom + oy < this.top || rc.left + ox > this.right || rc.top + oy > this.bottom);
	};
	Rect.prototype.contains_pt = function (x, y)
	{
		return (x >= this.left && x <= this.right) && (y >= this.top && y <= this.bottom);
	};
	Rect.prototype.equals = function (r)
	{
		return this.left === r.left && this.top === r.top && this.right === r.right && this.bottom === r.bottom;
	};
	cr.rect = Rect;
	function Quad()
	{
		this.tlx = 0;
		this.tly = 0;
		this.trx = 0;
		this.try_ = 0;	// is a keyword otherwise!
		this.brx = 0;
		this.bry = 0;
		this.blx = 0;
		this.bly = 0;
		cr.seal(this);
	};
	Quad.prototype.set_from_rect = function (rc)
	{
		this.tlx = rc.left;
		this.tly = rc.top;
		this.trx = rc.right;
		this.try_ = rc.top;
		this.brx = rc.right;
		this.bry = rc.bottom;
		this.blx = rc.left;
		this.bly = rc.bottom;
	};
	Quad.prototype.set_from_rotated_rect = function (rc, a)
	{
		if (a === 0)
		{
			this.set_from_rect(rc);
		}
		else
		{
			var sin_a = Math.sin(a);
			var cos_a = Math.cos(a);
			var left_sin_a = rc.left * sin_a;
			var top_sin_a = rc.top * sin_a;
			var right_sin_a = rc.right * sin_a;
			var bottom_sin_a = rc.bottom * sin_a;
			var left_cos_a = rc.left * cos_a;
			var top_cos_a = rc.top * cos_a;
			var right_cos_a = rc.right * cos_a;
			var bottom_cos_a = rc.bottom * cos_a;
			this.tlx = left_cos_a - top_sin_a;
			this.tly = top_cos_a + left_sin_a;
			this.trx = right_cos_a - top_sin_a;
			this.try_ = top_cos_a + right_sin_a;
			this.brx = right_cos_a - bottom_sin_a;
			this.bry = bottom_cos_a + right_sin_a;
			this.blx = left_cos_a - bottom_sin_a;
			this.bly = bottom_cos_a + left_sin_a;
		}
	};
	Quad.prototype.offset = function (px, py)
	{
		this.tlx += px;
		this.tly += py;
		this.trx += px;
		this.try_ += py;
		this.brx += px;
		this.bry += py;
		this.blx += px;
		this.bly += py;
		return this;
	};
	var minresult = 0;
	var maxresult = 0;
	function minmax4(a, b, c, d)
	{
		if (a < b)
		{
			if (c < d)
			{
				if (a < c)
					minresult = a;
				else
					minresult = c;
				if (b > d)
					maxresult = b;
				else
					maxresult = d;
			}
			else
			{
				if (a < d)
					minresult = a;
				else
					minresult = d;
				if (b > c)
					maxresult = b;
				else
					maxresult = c;
			}
		}
		else
		{
			if (c < d)
			{
				if (b < c)
					minresult = b;
				else
					minresult = c;
				if (a > d)
					maxresult = a;
				else
					maxresult = d;
			}
			else
			{
				if (b < d)
					minresult = b;
				else
					minresult = d;
				if (a > c)
					maxresult = a;
				else
					maxresult = c;
			}
		}
	};
	Quad.prototype.bounding_box = function (rc)
	{
		minmax4(this.tlx, this.trx, this.brx, this.blx);
		rc.left = minresult;
		rc.right = maxresult;
		minmax4(this.tly, this.try_, this.bry, this.bly);
		rc.top = minresult;
		rc.bottom = maxresult;
	};
	Quad.prototype.contains_pt = function (x, y)
	{
		var tlx = this.tlx;
		var tly = this.tly;
		var v0x = this.trx - tlx;
		var v0y = this.try_ - tly;
		var v1x = this.brx - tlx;
		var v1y = this.bry - tly;
		var v2x = x - tlx;
		var v2y = y - tly;
		var dot00 = v0x * v0x + v0y * v0y
		var dot01 = v0x * v1x + v0y * v1y
		var dot02 = v0x * v2x + v0y * v2y
		var dot11 = v1x * v1x + v1y * v1y
		var dot12 = v1x * v2x + v1y * v2y
		var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
		var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
		var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
		if ((u >= 0.0) && (v > 0.0) && (u + v < 1))
			return true;
		v0x = this.blx - tlx;
		v0y = this.bly - tly;
		var dot00 = v0x * v0x + v0y * v0y
		var dot01 = v0x * v1x + v0y * v1y
		var dot02 = v0x * v2x + v0y * v2y
		invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
		u = (dot11 * dot02 - dot01 * dot12) * invDenom;
		v = (dot00 * dot12 - dot01 * dot02) * invDenom;
		return (u >= 0.0) && (v > 0.0) && (u + v < 1);
	};
	Quad.prototype.at = function (i, xory)
	{
		if (xory)
		{
			switch (i)
			{
				case 0: return this.tlx;
				case 1: return this.trx;
				case 2: return this.brx;
				case 3: return this.blx;
				case 4: return this.tlx;
				default: return this.tlx;
			}
		}
		else
		{
			switch (i)
			{
				case 0: return this.tly;
				case 1: return this.try_;
				case 2: return this.bry;
				case 3: return this.bly;
				case 4: return this.tly;
				default: return this.tly;
			}
		}
	};
	Quad.prototype.midX = function ()
	{
		return (this.tlx + this.trx  + this.brx + this.blx) / 4;
	};
	Quad.prototype.midY = function ()
	{
		return (this.tly + this.try_ + this.bry + this.bly) / 4;
	};
	Quad.prototype.intersects_segment = function (x1, y1, x2, y2)
	{
		if (this.contains_pt(x1, y1) || this.contains_pt(x2, y2))
			return true;
		var a1x, a1y, a2x, a2y;
		var i;
		for (i = 0; i < 4; i++)
		{
			a1x = this.at(i, true);
			a1y = this.at(i, false);
			a2x = this.at(i + 1, true);
			a2y = this.at(i + 1, false);
			if (cr.segments_intersect(x1, y1, x2, y2, a1x, a1y, a2x, a2y))
				return true;
		}
		return false;
	};
	Quad.prototype.intersects_quad = function (rhs)
	{
		var midx = rhs.midX();
		var midy = rhs.midY();
		if (this.contains_pt(midx, midy))
			return true;
		midx = this.midX();
		midy = this.midY();
		if (rhs.contains_pt(midx, midy))
			return true;
		var a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y;
		var i, j;
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 4; j++)
			{
				a1x = this.at(i, true);
				a1y = this.at(i, false);
				a2x = this.at(i + 1, true);
				a2y = this.at(i + 1, false);
				b1x = rhs.at(j, true);
				b1y = rhs.at(j, false);
				b2x = rhs.at(j + 1, true);
				b2y = rhs.at(j + 1, false);
				if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
					return true;
			}
		}
		return false;
	};
	cr.quad = Quad;
	cr.RGB = function (red, green, blue)
	{
		return Math.max(Math.min(red, 255), 0)
			 | (Math.max(Math.min(green, 255), 0) << 8)
			 | (Math.max(Math.min(blue, 255), 0) << 16);
	};
	cr.GetRValue = function (rgb)
	{
		return rgb & 0xFF;
	};
	cr.GetGValue = function (rgb)
	{
		return (rgb & 0xFF00) >> 8;
	};
	cr.GetBValue = function (rgb)
	{
		return (rgb & 0xFF0000) >> 16;
	};
	cr.shallowCopy = function (a, b, allowOverwrite)
	{
		var attr;
		for (attr in b)
		{
			if (b.hasOwnProperty(attr))
			{
;
				a[attr] = b[attr];
			}
		}
		return a;
	};
	cr.arrayRemove = function (arr, index)
	{
		var i, len;
		index = cr.floor(index);
		if (index < 0 || index >= arr.length)
			return;							// index out of bounds
		for (i = index, len = arr.length - 1; i < len; i++)
			arr[i] = arr[i + 1];
		cr.truncateArray(arr, len);
	};
	cr.truncateArray = function (arr, index)
	{
		arr.length = index;
	};
	cr.clearArray = function (arr)
	{
		cr.truncateArray(arr, 0);
	};
	cr.shallowAssignArray = function (dest, src)
	{
		cr.clearArray(dest);
		var i, len;
		for (i = 0, len = src.length; i < len; ++i)
			dest[i] = src[i];
	};
	cr.appendArray = function (a, b)
	{
		a.push.apply(a, b);
	};
	cr.fastIndexOf = function (arr, item)
	{
		var i, len;
		for (i = 0, len = arr.length; i < len; ++i)
		{
			if (arr[i] === item)
				return i;
		}
		return -1;
	};
	cr.arrayFindRemove = function (arr, item)
	{
		var index = cr.fastIndexOf(arr, item);
		if (index !== -1)
			cr.arrayRemove(arr, index);
	};
	cr.clamp = function(x, a, b)
	{
		if (x < a)
			return a;
		else if (x > b)
			return b;
		else
			return x;
	};
	cr.to_radians = function(x)
	{
		return x / (180.0 / cr.PI);
	};
	cr.to_degrees = function(x)
	{
		return x * (180.0 / cr.PI);
	};
	cr.clamp_angle_degrees = function (a)
	{
		a %= 360;       // now in (-360, 360) range
		if (a < 0)
			a += 360;   // now in [0, 360) range
		return a;
	};
	cr.clamp_angle = function (a)
	{
		a %= 2 * cr.PI;       // now in (-2pi, 2pi) range
		if (a < 0)
			a += 2 * cr.PI;   // now in [0, 2pi) range
		return a;
	};
	cr.to_clamped_degrees = function (x)
	{
		return cr.clamp_angle_degrees(cr.to_degrees(x));
	};
	cr.to_clamped_radians = function (x)
	{
		return cr.clamp_angle(cr.to_radians(x));
	};
	cr.angleTo = function(x1, y1, x2, y2)
	{
		var dx = x2 - x1;
        var dy = y2 - y1;
		return Math.atan2(dy, dx);
	};
	cr.angleDiff = function (a1, a2)
	{
		if (a1 === a2)
			return 0;
		var s1 = Math.sin(a1);
		var c1 = Math.cos(a1);
		var s2 = Math.sin(a2);
		var c2 = Math.cos(a2);
		var n = s1 * s2 + c1 * c2;
		if (n >= 1)
			return 0;
		if (n <= -1)
			return cr.PI;
		return Math.acos(n);
	};
	cr.angleRotate = function (start, end, step)
	{
		var ss = Math.sin(start);
		var cs = Math.cos(start);
		var se = Math.sin(end);
		var ce = Math.cos(end);
		if (Math.acos(ss * se + cs * ce) > step)
		{
			if (cs * se - ss * ce > 0)
				return cr.clamp_angle(start + step);
			else
				return cr.clamp_angle(start - step);
		}
		else
			return cr.clamp_angle(end);
	};
	cr.angleClockwise = function (a1, a2)
	{
		var s1 = Math.sin(a1);
		var c1 = Math.cos(a1);
		var s2 = Math.sin(a2);
		var c2 = Math.cos(a2);
		return c1 * s2 - s1 * c2 <= 0;
	};
	cr.rotatePtAround = function (px, py, a, ox, oy, getx)
	{
		if (a === 0)
			return getx ? px : py;
		var sin_a = Math.sin(a);
		var cos_a = Math.cos(a);
		px -= ox;
		py -= oy;
		var left_sin_a = px * sin_a;
		var top_sin_a = py * sin_a;
		var left_cos_a = px * cos_a;
		var top_cos_a = py * cos_a;
		px = left_cos_a - top_sin_a;
		py = top_cos_a + left_sin_a;
		px += ox;
		py += oy;
		return getx ? px : py;
	}
	cr.distanceTo = function(x1, y1, x2, y2)
	{
		var dx = x2 - x1;
        var dy = y2 - y1;
		return Math.sqrt(dx*dx + dy*dy);
	};
	cr.xor = function (x, y)
	{
		return !x !== !y;
	};
	cr.lerp = function (a, b, x)
	{
		return a + (b - a) * x;
	};
	cr.unlerp = function (a, b, c)
	{
		if (a === b)
			return 0;		// avoid divide by 0
		return (c - a) / (b - a);
	};
	cr.anglelerp = function (a, b, x)
	{
		var diff = cr.angleDiff(a, b);
		if (cr.angleClockwise(b, a))
		{
			return a + diff * x;
		}
		else
		{
			return a - diff * x;
		}
	};
	cr.qarp = function (a, b, c, x)
	{
		return cr.lerp(cr.lerp(a, b, x), cr.lerp(b, c, x), x);
	};
	cr.cubic = function (a, b, c, d, x)
	{
		return cr.lerp(cr.qarp(a, b, c, x), cr.qarp(b, c, d, x), x);
	};
	cr.cosp = function (a, b, x)
	{
		return (a + b + (a - b) * Math.cos(x * Math.PI)) / 2;
	};
	cr.hasAnyOwnProperty = function (o)
	{
		var p;
		for (p in o)
		{
			if (o.hasOwnProperty(p))
				return true;
		}
		return false;
	};
	cr.wipe = function (obj)
	{
		var p;
		for (p in obj)
		{
			if (obj.hasOwnProperty(p))
				delete obj[p];
		}
	};
	var startup_time = +(new Date());
	cr.performance_now = function()
	{
		if (typeof window["performance"] !== "undefined")
		{
			var winperf = window["performance"];
			if (typeof winperf.now !== "undefined")
				return winperf.now();
			else if (typeof winperf["webkitNow"] !== "undefined")
				return winperf["webkitNow"]();
			else if (typeof winperf["mozNow"] !== "undefined")
				return winperf["mozNow"]();
			else if (typeof winperf["msNow"] !== "undefined")
				return winperf["msNow"]();
		}
		return Date.now() - startup_time;
	};
	var isChrome = false;
	var isSafari = false;
	var isiOS = false;
	var isEjecta = false;
	if (typeof window !== "undefined")		// not c2 editor
	{
		isChrome = /chrome/i.test(navigator.userAgent) || /chromium/i.test(navigator.userAgent);
		isSafari = !isChrome && /safari/i.test(navigator.userAgent);
		isiOS = /(iphone|ipod|ipad)/i.test(navigator.userAgent);
		isEjecta = window["c2ejecta"];
	}
	var supports_set = ((!isSafari && !isEjecta && !isiOS) && (typeof Set !== "undefined" && typeof Set.prototype["forEach"] !== "undefined"));
	function ObjectSet_()
	{
		this.s = null;
		this.items = null;			// lazy allocated (hopefully results in better GC performance)
		this.item_count = 0;
		if (supports_set)
		{
			this.s = new Set();
		}
		this.values_cache = [];
		this.cache_valid = true;
		cr.seal(this);
	};
	ObjectSet_.prototype.contains = function (x)
	{
		if (this.isEmpty())
			return false;
		if (supports_set)
			return this.s["has"](x);
		else
			return (this.items && this.items.hasOwnProperty(x));
	};
	ObjectSet_.prototype.add = function (x)
	{
		if (supports_set)
		{
			if (!this.s["has"](x))
			{
				this.s["add"](x);
				this.cache_valid = false;
			}
		}
		else
		{
			var str = x.toString();
			var items = this.items;
			if (!items)
			{
				this.items = {};
				this.items[str] = x;
				this.item_count = 1;
				this.cache_valid = false;
			}
			else if (!items.hasOwnProperty(str))
			{
				items[str] = x;
				this.item_count++;
				this.cache_valid = false;
			}
		}
	};
	ObjectSet_.prototype.remove = function (x)
	{
		if (this.isEmpty())
			return;
		if (supports_set)
		{
			if (this.s["has"](x))
			{
				this.s["delete"](x);
				this.cache_valid = false;
			}
		}
		else if (this.items)
		{
			var str = x.toString();
			var items = this.items;
			if (items.hasOwnProperty(str))
			{
				delete items[str];
				this.item_count--;
				this.cache_valid = false;
			}
		}
	};
	ObjectSet_.prototype.clear = function (/*wipe_*/)
	{
		if (this.isEmpty())
			return;
		if (supports_set)
		{
			this.s["clear"]();			// best!
		}
		else
		{
				this.items = null;		// creates garbage; will lazy allocate on next add()
			this.item_count = 0;
		}
		cr.clearArray(this.values_cache);
		this.cache_valid = true;
	};
	ObjectSet_.prototype.isEmpty = function ()
	{
		return this.count() === 0;
	};
	ObjectSet_.prototype.count = function ()
	{
		if (supports_set)
			return this.s["size"];
		else
			return this.item_count;
	};
	var current_arr = null;
	var current_index = 0;
	function set_append_to_arr(x)
	{
		current_arr[current_index++] = x;
	};
	ObjectSet_.prototype.update_cache = function ()
	{
		if (this.cache_valid)
			return;
		if (supports_set)
		{
			cr.clearArray(this.values_cache);
			current_arr = this.values_cache;
			current_index = 0;
			this.s["forEach"](set_append_to_arr);
;
			current_arr = null;
			current_index = 0;
		}
		else
		{
			var values_cache = this.values_cache;
			cr.clearArray(values_cache);
			var p, n = 0, items = this.items;
			if (items)
			{
				for (p in items)
				{
					if (items.hasOwnProperty(p))
						values_cache[n++] = items[p];
				}
			}
;
		}
		this.cache_valid = true;
	};
	ObjectSet_.prototype.valuesRef = function ()
	{
		this.update_cache();
		return this.values_cache;
	};
	cr.ObjectSet = ObjectSet_;
	var tmpSet = new cr.ObjectSet();
	cr.removeArrayDuplicates = function (arr)
	{
		var i, len;
		for (i = 0, len = arr.length; i < len; ++i)
		{
			tmpSet.add(arr[i]);
		}
		cr.shallowAssignArray(arr, tmpSet.valuesRef());
		tmpSet.clear();
	};
	cr.arrayRemoveAllFromObjectSet = function (arr, remset)
	{
		if (supports_set)
			cr.arrayRemoveAll_set(arr, remset.s);
		else
			cr.arrayRemoveAll_arr(arr, remset.valuesRef());
	};
	cr.arrayRemoveAll_set = function (arr, s)
	{
		var i, j, len, item;
		for (i = 0, j = 0, len = arr.length; i < len; ++i)
		{
			item = arr[i];
			if (!s["has"](item))					// not an item to remove
				arr[j++] = item;					// keep it
		}
		cr.truncateArray(arr, j);
	};
	cr.arrayRemoveAll_arr = function (arr, rem)
	{
		var i, j, len, item;
		for (i = 0, j = 0, len = arr.length; i < len; ++i)
		{
			item = arr[i];
			if (cr.fastIndexOf(rem, item) === -1)	// not an item to remove
				arr[j++] = item;					// keep it
		}
		cr.truncateArray(arr, j);
	};
	function KahanAdder_()
	{
		this.c = 0;
        this.y = 0;
        this.t = 0;
        this.sum = 0;
		cr.seal(this);
	};
	KahanAdder_.prototype.add = function (v)
	{
		this.y = v - this.c;
	    this.t = this.sum + this.y;
	    this.c = (this.t - this.sum) - this.y;
	    this.sum = this.t;
	};
    KahanAdder_.prototype.reset = function ()
    {
        this.c = 0;
        this.y = 0;
        this.t = 0;
        this.sum = 0;
    };
	cr.KahanAdder = KahanAdder_;
	cr.regexp_escape = function(text)
	{
		return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	};
	function CollisionPoly_(pts_array_)
	{
		this.pts_cache = [];
		this.bboxLeft = 0;
		this.bboxTop = 0;
		this.bboxRight = 0;
		this.bboxBottom = 0;
		this.convexpolys = null;		// for physics behavior to cache separated polys
		this.set_pts(pts_array_);
		cr.seal(this);
	};
	CollisionPoly_.prototype.set_pts = function(pts_array_)
	{
		this.pts_array = pts_array_;
		this.pts_count = pts_array_.length / 2;			// x, y, x, y... in array
		this.pts_cache.length = pts_array_.length;
		this.cache_width = -1;
		this.cache_height = -1;
		this.cache_angle = 0;
	};
	CollisionPoly_.prototype.is_empty = function()
	{
		return !this.pts_array.length;
	};
	CollisionPoly_.prototype.update_bbox = function ()
	{
		var myptscache = this.pts_cache;
		var bboxLeft_ = myptscache[0];
		var bboxRight_ = bboxLeft_;
		var bboxTop_ = myptscache[1];
		var bboxBottom_ = bboxTop_;
		var x, y, i = 1, i2, len = this.pts_count;
		for ( ; i < len; ++i)
		{
			i2 = i*2;
			x = myptscache[i2];
			y = myptscache[i2+1];
			if (x < bboxLeft_)
				bboxLeft_ = x;
			if (x > bboxRight_)
				bboxRight_ = x;
			if (y < bboxTop_)
				bboxTop_ = y;
			if (y > bboxBottom_)
				bboxBottom_ = y;
		}
		this.bboxLeft = bboxLeft_;
		this.bboxRight = bboxRight_;
		this.bboxTop = bboxTop_;
		this.bboxBottom = bboxBottom_;
	};
	CollisionPoly_.prototype.set_from_rect = function(rc, offx, offy)
	{
		this.pts_cache.length = 8;
		this.pts_count = 4;
		var myptscache = this.pts_cache;
		myptscache[0] = rc.left - offx;
		myptscache[1] = rc.top - offy;
		myptscache[2] = rc.right - offx;
		myptscache[3] = rc.top - offy;
		myptscache[4] = rc.right - offx;
		myptscache[5] = rc.bottom - offy;
		myptscache[6] = rc.left - offx;
		myptscache[7] = rc.bottom - offy;
		this.cache_width = rc.right - rc.left;
		this.cache_height = rc.bottom - rc.top;
		this.update_bbox();
	};
	CollisionPoly_.prototype.set_from_quad = function(q, offx, offy, w, h)
	{
		this.pts_cache.length = 8;
		this.pts_count = 4;
		var myptscache = this.pts_cache;
		myptscache[0] = q.tlx - offx;
		myptscache[1] = q.tly - offy;
		myptscache[2] = q.trx - offx;
		myptscache[3] = q.try_ - offy;
		myptscache[4] = q.brx - offx;
		myptscache[5] = q.bry - offy;
		myptscache[6] = q.blx - offx;
		myptscache[7] = q.bly - offy;
		this.cache_width = w;
		this.cache_height = h;
		this.update_bbox();
	};
	CollisionPoly_.prototype.set_from_poly = function (r)
	{
		this.pts_count = r.pts_count;
		cr.shallowAssignArray(this.pts_cache, r.pts_cache);
		this.bboxLeft = r.bboxLeft;
		this.bboxTop - r.bboxTop;
		this.bboxRight = r.bboxRight;
		this.bboxBottom = r.bboxBottom;
	};
	CollisionPoly_.prototype.cache_poly = function(w, h, a)
	{
		if (this.cache_width === w && this.cache_height === h && this.cache_angle === a)
			return;		// cache up-to-date
		this.cache_width = w;
		this.cache_height = h;
		this.cache_angle = a;
		var i, i2, i21, len, x, y;
		var sina = 0;
		var cosa = 1;
		var myptsarray = this.pts_array;
		var myptscache = this.pts_cache;
		if (a !== 0)
		{
			sina = Math.sin(a);
			cosa = Math.cos(a);
		}
		for (i = 0, len = this.pts_count; i < len; i++)
		{
			i2 = i*2;
			i21 = i2+1;
			x = myptsarray[i2] * w;
			y = myptsarray[i21] * h;
			myptscache[i2] = (x * cosa) - (y * sina);
			myptscache[i21] = (y * cosa) + (x * sina);
		}
		this.update_bbox();
	};
	CollisionPoly_.prototype.contains_pt = function (a2x, a2y)
	{
		var myptscache = this.pts_cache;
		if (a2x === myptscache[0] && a2y === myptscache[1])
			return true;
		var i, i2, imod, len = this.pts_count;
		var a1x = this.bboxLeft - 110;
		var a1y = this.bboxTop - 101;
		var a3x = this.bboxRight + 131
		var a3y = this.bboxBottom + 120;
		var b1x, b1y, b2x, b2y;
		var count1 = 0, count2 = 0;
		for (i = 0; i < len; i++)
		{
			i2 = i*2;
			imod = ((i+1)%len)*2;
			b1x = myptscache[i2];
			b1y = myptscache[i2+1];
			b2x = myptscache[imod];
			b2y = myptscache[imod+1];
			if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
				count1++;
			if (cr.segments_intersect(a3x, a3y, a2x, a2y, b1x, b1y, b2x, b2y))
				count2++;
		}
		return (count1 % 2 === 1) || (count2 % 2 === 1);
	};
	CollisionPoly_.prototype.intersects_poly = function (rhs, offx, offy)
	{
		var rhspts = rhs.pts_cache;
		var mypts = this.pts_cache;
		if (this.contains_pt(rhspts[0] + offx, rhspts[1] + offy))
			return true;
		if (rhs.contains_pt(mypts[0] - offx, mypts[1] - offy))
			return true;
		var i, i2, imod, leni, j, j2, jmod, lenj;
		var a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y;
		for (i = 0, leni = this.pts_count; i < leni; i++)
		{
			i2 = i*2;
			imod = ((i+1)%leni)*2;
			a1x = mypts[i2];
			a1y = mypts[i2+1];
			a2x = mypts[imod];
			a2y = mypts[imod+1];
			for (j = 0, lenj = rhs.pts_count; j < lenj; j++)
			{
				j2 = j*2;
				jmod = ((j+1)%lenj)*2;
				b1x = rhspts[j2] + offx;
				b1y = rhspts[j2+1] + offy;
				b2x = rhspts[jmod] + offx;
				b2y = rhspts[jmod+1] + offy;
				if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
					return true;
			}
		}
		return false;
	};
	CollisionPoly_.prototype.intersects_segment = function (offx, offy, x1, y1, x2, y2)
	{
		var mypts = this.pts_cache;
		if (this.contains_pt(x1 - offx, y1 - offy))
			return true;
		var i, leni, i2, imod;
		var a1x, a1y, a2x, a2y;
		for (i = 0, leni = this.pts_count; i < leni; i++)
		{
			i2 = i*2;
			imod = ((i+1)%leni)*2;
			a1x = mypts[i2] + offx;
			a1y = mypts[i2+1] + offy;
			a2x = mypts[imod] + offx;
			a2y = mypts[imod+1] + offy;
			if (cr.segments_intersect(x1, y1, x2, y2, a1x, a1y, a2x, a2y))
				return true;
		}
		return false;
	};
	CollisionPoly_.prototype.mirror = function (px)
	{
		var i, leni, i2;
		for (i = 0, leni = this.pts_count; i < leni; ++i)
		{
			i2 = i*2;
			this.pts_cache[i2] = px * 2 - this.pts_cache[i2];
		}
	};
	CollisionPoly_.prototype.flip = function (py)
	{
		var i, leni, i21;
		for (i = 0, leni = this.pts_count; i < leni; ++i)
		{
			i21 = i*2+1;
			this.pts_cache[i21] = py * 2 - this.pts_cache[i21];
		}
	};
	CollisionPoly_.prototype.diag = function ()
	{
		var i, leni, i2, i21, temp;
		for (i = 0, leni = this.pts_count; i < leni; ++i)
		{
			i2 = i*2;
			i21 = i2+1;
			temp = this.pts_cache[i2];
			this.pts_cache[i2] = this.pts_cache[i21];
			this.pts_cache[i21] = temp;
		}
	};
	cr.CollisionPoly = CollisionPoly_;
	function SparseGrid_(cellwidth_, cellheight_)
	{
		this.cellwidth = cellwidth_;
		this.cellheight = cellheight_;
		this.cells = {};
	};
	SparseGrid_.prototype.totalCellCount = 0;
	SparseGrid_.prototype.getCell = function (x_, y_, create_if_missing)
	{
		var ret;
		var col = this.cells[x_];
		if (!col)
		{
			if (create_if_missing)
			{
				ret = allocGridCell(this, x_, y_);
				this.cells[x_] = {};
				this.cells[x_][y_] = ret;
				return ret;
			}
			else
				return null;
		}
		ret = col[y_];
		if (ret)
			return ret;
		else if (create_if_missing)
		{
			ret = allocGridCell(this, x_, y_);
			this.cells[x_][y_] = ret;
			return ret;
		}
		else
			return null;
	};
	SparseGrid_.prototype.XToCell = function (x_)
	{
		return cr.floor(x_ / this.cellwidth);
	};
	SparseGrid_.prototype.YToCell = function (y_)
	{
		return cr.floor(y_ / this.cellheight);
	};
	SparseGrid_.prototype.update = function (inst, oldrange, newrange)
	{
		var x, lenx, y, leny, cell;
		if (oldrange)
		{
			for (x = oldrange.left, lenx = oldrange.right; x <= lenx; ++x)
			{
				for (y = oldrange.top, leny = oldrange.bottom; y <= leny; ++y)
				{
					if (newrange && newrange.contains_pt(x, y))
						continue;	// is still in this cell
					cell = this.getCell(x, y, false);	// don't create if missing
					if (!cell)
						continue;	// cell does not exist yet
					cell.remove(inst);
					if (cell.isEmpty())
					{
						freeGridCell(cell);
						this.cells[x][y] = null;
					}
				}
			}
		}
		if (newrange)
		{
			for (x = newrange.left, lenx = newrange.right; x <= lenx; ++x)
			{
				for (y = newrange.top, leny = newrange.bottom; y <= leny; ++y)
				{
					if (oldrange && oldrange.contains_pt(x, y))
						continue;	// is still in this cell
					this.getCell(x, y, true).insert(inst);
				}
			}
		}
	};
	SparseGrid_.prototype.queryRange = function (rc, result)
	{
		var x, lenx, ystart, y, leny, cell;
		x = this.XToCell(rc.left);
		ystart = this.YToCell(rc.top);
		lenx = this.XToCell(rc.right);
		leny = this.YToCell(rc.bottom);
		for ( ; x <= lenx; ++x)
		{
			for (y = ystart; y <= leny; ++y)
			{
				cell = this.getCell(x, y, false);
				if (!cell)
					continue;
				cell.dump(result);
			}
		}
	};
	cr.SparseGrid = SparseGrid_;
	function RenderGrid_(cellwidth_, cellheight_)
	{
		this.cellwidth = cellwidth_;
		this.cellheight = cellheight_;
		this.cells = {};
	};
	RenderGrid_.prototype.totalCellCount = 0;
	RenderGrid_.prototype.getCell = function (x_, y_, create_if_missing)
	{
		var ret;
		var col = this.cells[x_];
		if (!col)
		{
			if (create_if_missing)
			{
				ret = allocRenderCell(this, x_, y_);
				this.cells[x_] = {};
				this.cells[x_][y_] = ret;
				return ret;
			}
			else
				return null;
		}
		ret = col[y_];
		if (ret)
			return ret;
		else if (create_if_missing)
		{
			ret = allocRenderCell(this, x_, y_);
			this.cells[x_][y_] = ret;
			return ret;
		}
		else
			return null;
	};
	RenderGrid_.prototype.XToCell = function (x_)
	{
		return cr.floor(x_ / this.cellwidth);
	};
	RenderGrid_.prototype.YToCell = function (y_)
	{
		return cr.floor(y_ / this.cellheight);
	};
	RenderGrid_.prototype.update = function (inst, oldrange, newrange)
	{
		var x, lenx, y, leny, cell;
		if (oldrange)
		{
			for (x = oldrange.left, lenx = oldrange.right; x <= lenx; ++x)
			{
				for (y = oldrange.top, leny = oldrange.bottom; y <= leny; ++y)
				{
					if (newrange && newrange.contains_pt(x, y))
						continue;	// is still in this cell
					cell = this.getCell(x, y, false);	// don't create if missing
					if (!cell)
						continue;	// cell does not exist yet
					cell.remove(inst);
					if (cell.isEmpty())
					{
						freeRenderCell(cell);
						this.cells[x][y] = null;
					}
				}
			}
		}
		if (newrange)
		{
			for (x = newrange.left, lenx = newrange.right; x <= lenx; ++x)
			{
				for (y = newrange.top, leny = newrange.bottom; y <= leny; ++y)
				{
					if (oldrange && oldrange.contains_pt(x, y))
						continue;	// is still in this cell
					this.getCell(x, y, true).insert(inst);
				}
			}
		}
	};
	RenderGrid_.prototype.queryRange = function (left, top, right, bottom, result)
	{
		var x, lenx, ystart, y, leny, cell;
		x = this.XToCell(left);
		ystart = this.YToCell(top);
		lenx = this.XToCell(right);
		leny = this.YToCell(bottom);
		for ( ; x <= lenx; ++x)
		{
			for (y = ystart; y <= leny; ++y)
			{
				cell = this.getCell(x, y, false);
				if (!cell)
					continue;
				cell.dump(result);
			}
		}
	};
	RenderGrid_.prototype.markRangeChanged = function (rc)
	{
		var x, lenx, ystart, y, leny, cell;
		x = rc.left;
		ystart = rc.top;
		lenx = rc.right;
		leny = rc.bottom;
		for ( ; x <= lenx; ++x)
		{
			for (y = ystart; y <= leny; ++y)
			{
				cell = this.getCell(x, y, false);
				if (!cell)
					continue;
				cell.is_sorted = false;
			}
		}
	};
	cr.RenderGrid = RenderGrid_;
	var gridcellcache = [];
	function allocGridCell(grid_, x_, y_)
	{
		var ret;
		SparseGrid_.prototype.totalCellCount++;
		if (gridcellcache.length)
		{
			ret = gridcellcache.pop();
			ret.grid = grid_;
			ret.x = x_;
			ret.y = y_;
			return ret;
		}
		else
			return new cr.GridCell(grid_, x_, y_);
	};
	function freeGridCell(c)
	{
		SparseGrid_.prototype.totalCellCount--;
		c.objects.clear();
		if (gridcellcache.length < 1000)
			gridcellcache.push(c);
	};
	function GridCell_(grid_, x_, y_)
	{
		this.grid = grid_;
		this.x = x_;
		this.y = y_;
		this.objects = new cr.ObjectSet();
	};
	GridCell_.prototype.isEmpty = function ()
	{
		return this.objects.isEmpty();
	};
	GridCell_.prototype.insert = function (inst)
	{
		this.objects.add(inst);
	};
	GridCell_.prototype.remove = function (inst)
	{
		this.objects.remove(inst);
	};
	GridCell_.prototype.dump = function (result)
	{
		cr.appendArray(result, this.objects.valuesRef());
	};
	cr.GridCell = GridCell_;
	var rendercellcache = [];
	function allocRenderCell(grid_, x_, y_)
	{
		var ret;
		RenderGrid_.prototype.totalCellCount++;
		if (rendercellcache.length)
		{
			ret = rendercellcache.pop();
			ret.grid = grid_;
			ret.x = x_;
			ret.y = y_;
			return ret;
		}
		else
			return new cr.RenderCell(grid_, x_, y_);
	};
	function freeRenderCell(c)
	{
		RenderGrid_.prototype.totalCellCount--;
		c.reset();
		if (rendercellcache.length < 1000)
			rendercellcache.push(c);
	};
	function RenderCell_(grid_, x_, y_)
	{
		this.grid = grid_;
		this.x = x_;
		this.y = y_;
		this.objects = [];		// array which needs to be sorted by Z order
		this.is_sorted = true;	// whether array is in correct sort order or not
		this.pending_removal = new cr.ObjectSet();
		this.any_pending_removal = false;
	};
	RenderCell_.prototype.isEmpty = function ()
	{
		if (!this.objects.length)
		{
;
;
			return true;
		}
		if (this.objects.length > this.pending_removal.count())
			return false;
;
		this.flush_pending();		// takes fast path and just resets state
		return true;
	};
	RenderCell_.prototype.insert = function (inst)
	{
		if (this.pending_removal.contains(inst))
		{
			this.pending_removal.remove(inst);
			if (this.pending_removal.isEmpty())
				this.any_pending_removal = false;
			return;
		}
		if (this.objects.length)
		{
			var top = this.objects[this.objects.length - 1];
			if (top.get_zindex() > inst.get_zindex())
				this.is_sorted = false;		// 'inst' should be somewhere beneath 'top'
			this.objects.push(inst);
		}
		else
		{
			this.objects.push(inst);
			this.is_sorted = true;
		}
;
	};
	RenderCell_.prototype.remove = function (inst)
	{
		this.pending_removal.add(inst);
		this.any_pending_removal = true;
		if (this.pending_removal.count() >= 30)
			this.flush_pending();
	};
	RenderCell_.prototype.flush_pending = function ()
	{
;
		if (!this.any_pending_removal)
			return;		// not changed
		if (this.pending_removal.count() === this.objects.length)
		{
			this.reset();
			return;
		}
		cr.arrayRemoveAllFromObjectSet(this.objects, this.pending_removal);
		this.pending_removal.clear();
		this.any_pending_removal = false;
	};
	function sortByInstanceZIndex(a, b)
	{
		return a.zindex - b.zindex;
	};
	RenderCell_.prototype.ensure_sorted = function ()
	{
		if (this.is_sorted)
			return;		// already sorted
		this.objects.sort(sortByInstanceZIndex);
		this.is_sorted = true;
	};
	RenderCell_.prototype.reset = function ()
	{
		cr.clearArray(this.objects);
		this.is_sorted = true;
		this.pending_removal.clear();
		this.any_pending_removal = false;
	};
	RenderCell_.prototype.dump = function (result)
	{
		this.flush_pending();
		this.ensure_sorted();
		if (this.objects.length)
			result.push(this.objects);
	};
	cr.RenderCell = RenderCell_;
	var fxNames = [ "lighter",
					"xor",
					"copy",
					"destination-over",
					"source-in",
					"destination-in",
					"source-out",
					"destination-out",
					"source-atop",
					"destination-atop"];
	cr.effectToCompositeOp = function(effect)
	{
		if (effect <= 0 || effect >= 11)
			return "source-over";
		return fxNames[effect - 1];	// not including "none" so offset by 1
	};
	cr.setGLBlend = function(this_, effect, gl)
	{
		if (!gl)
			return;
		this_.srcBlend = gl.ONE;
		this_.destBlend = gl.ONE_MINUS_SRC_ALPHA;
		switch (effect) {
		case 1:		// lighter (additive)
			this_.srcBlend = gl.ONE;
			this_.destBlend = gl.ONE;
			break;
		case 2:		// xor
			break;	// todo
		case 3:		// copy
			this_.srcBlend = gl.ONE;
			this_.destBlend = gl.ZERO;
			break;
		case 4:		// destination-over
			this_.srcBlend = gl.ONE_MINUS_DST_ALPHA;
			this_.destBlend = gl.ONE;
			break;
		case 5:		// source-in
			this_.srcBlend = gl.DST_ALPHA;
			this_.destBlend = gl.ZERO;
			break;
		case 6:		// destination-in
			this_.srcBlend = gl.ZERO;
			this_.destBlend = gl.SRC_ALPHA;
			break;
		case 7:		// source-out
			this_.srcBlend = gl.ONE_MINUS_DST_ALPHA;
			this_.destBlend = gl.ZERO;
			break;
		case 8:		// destination-out
			this_.srcBlend = gl.ZERO;
			this_.destBlend = gl.ONE_MINUS_SRC_ALPHA;
			break;
		case 9:		// source-atop
			this_.srcBlend = gl.DST_ALPHA;
			this_.destBlend = gl.ONE_MINUS_SRC_ALPHA;
			break;
		case 10:	// destination-atop
			this_.srcBlend = gl.ONE_MINUS_DST_ALPHA;
			this_.destBlend = gl.SRC_ALPHA;
			break;
		}
	};
	cr.round6dp = function (x)
	{
		return Math.round(x * 1000000) / 1000000;
	};
	/*
	var localeCompare_options = {
		"usage": "search",
		"sensitivity": "accent"
	};
	var has_localeCompare = !!"a".localeCompare;
	var localeCompare_works1 = (has_localeCompare && "a".localeCompare("A", undefined, localeCompare_options) === 0);
	var localeCompare_works2 = (has_localeCompare && "a".localeCompare("á", undefined, localeCompare_options) !== 0);
	var supports_localeCompare = (has_localeCompare && localeCompare_works1 && localeCompare_works2);
	*/
	cr.equals_nocase = function (a, b)
	{
		if (typeof a !== "string" || typeof b !== "string")
			return false;
		if (a.length !== b.length)
			return false;
		if (a === b)
			return true;
		/*
		if (supports_localeCompare)
		{
			return (a.localeCompare(b, undefined, localeCompare_options) === 0);
		}
		else
		{
		*/
			return a.toLowerCase() === b.toLowerCase();
	};
	cr.isCanvasInputEvent = function (e)
	{
		var target = e.target;
		if (!target)
			return true;
		if (target === document || target === window)
			return true;
		if (document && document.body && target === document.body)
			return true;
		if (cr.equals_nocase(target.tagName, "canvas"))
			return true;
		return false;
	};
}());
var MatrixArray=typeof Float32Array!=="undefined"?Float32Array:Array,glMatrixArrayType=MatrixArray,vec3={},mat3={},mat4={},quat4={};vec3.create=function(a){var b=new MatrixArray(3);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2]);return b};vec3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b};vec3.add=function(a,b,c){if(!c||a===c)return a[0]+=b[0],a[1]+=b[1],a[2]+=b[2],a;c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];return c};
vec3.subtract=function(a,b,c){if(!c||a===c)return a[0]-=b[0],a[1]-=b[1],a[2]-=b[2],a;c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c};vec3.negate=function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b};vec3.scale=function(a,b,c){if(!c||a===c)return a[0]*=b,a[1]*=b,a[2]*=b,a;c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};
vec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g===1)return b[0]=c,b[1]=d,b[2]=e,b}else return b[0]=0,b[1]=0,b[2]=0,b;g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};vec3.cross=function(a,b,c){c||(c=a);var d=a[0],e=a[1],a=a[2],g=b[0],f=b[1],b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c};vec3.length=function(a){var b=a[0],c=a[1],a=a[2];return Math.sqrt(b*b+c*c+a*a)};vec3.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};
vec3.direction=function(a,b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1],a=a[2]-b[2],b=Math.sqrt(d*d+e*e+a*a);if(!b)return c[0]=0,c[1]=0,c[2]=0,c;b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c};vec3.lerp=function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d};vec3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+"]"};
mat3.create=function(a){var b=new MatrixArray(9);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8]);return b};mat3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b};mat3.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a};
mat3.transpose=function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};mat3.toMat4=function(a,b){b||(b=mat4.create());b[15]=1;b[14]=0;b[13]=0;b[12]=0;b[11]=0;b[10]=a[8];b[9]=a[7];b[8]=a[6];b[7]=0;b[6]=a[5];b[5]=a[4];b[4]=a[3];b[3]=0;b[2]=a[2];b[1]=a[1];b[0]=a[0];return b};
mat3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+"]"};mat4.create=function(a){var b=new MatrixArray(16);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8],b[9]=a[9],b[10]=a[10],b[11]=a[11],b[12]=a[12],b[13]=a[13],b[14]=a[14],b[15]=a[15]);return b};
mat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.transpose=function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]=a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};
mat4.determinant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],i=a[7],j=a[8],k=a[9],l=a[10],n=a[11],o=a[12],m=a[13],p=a[14],a=a[15];return o*k*h*e-j*m*h*e-o*f*l*e+g*m*l*e+j*f*p*e-g*k*p*e-o*k*d*i+j*m*d*i+o*c*l*i-b*m*l*i-j*c*p*i+b*k*p*i+o*f*d*n-g*m*d*n-o*c*h*n+b*m*h*n+g*c*p*n-b*f*p*n-j*f*d*a+g*k*d*a+j*c*h*a-b*k*h*a-g*c*l*a+b*f*l*a};
mat4.inverse=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],i=a[6],j=a[7],k=a[8],l=a[9],n=a[10],o=a[11],m=a[12],p=a[13],r=a[14],s=a[15],A=c*h-d*f,B=c*i-e*f,t=c*j-g*f,u=d*i-e*h,v=d*j-g*h,w=e*j-g*i,x=k*p-l*m,y=k*r-n*m,z=k*s-o*m,C=l*r-n*p,D=l*s-o*p,E=n*s-o*r,q=1/(A*E-B*D+t*C+u*z-v*y+w*x);b[0]=(h*E-i*D+j*C)*q;b[1]=(-d*E+e*D-g*C)*q;b[2]=(p*w-r*v+s*u)*q;b[3]=(-l*w+n*v-o*u)*q;b[4]=(-f*E+i*z-j*y)*q;b[5]=(c*E-e*z+g*y)*q;b[6]=(-m*w+r*t-s*B)*q;b[7]=(k*w-n*t+o*B)*q;b[8]=(f*D-h*z+j*x)*q;
b[9]=(-c*D+d*z-g*x)*q;b[10]=(m*v-p*t+s*A)*q;b[11]=(-k*v+l*t-o*A)*q;b[12]=(-f*C+h*y-i*x)*q;b[13]=(c*C-d*y+e*x)*q;b[14]=(-m*u+p*B-r*A)*q;b[15]=(k*u-l*B+n*A)*q;return b};mat4.toRotationMat=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
mat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,n=-k*g+h*i,o=j*g-f*i,m=c*l+d*n+e*o;if(!m)return null;m=1/m;b||(b=mat3.create());b[0]=l*m;b[1]=(-k*d+e*j)*m;b[2]=(h*d-e*f)*m;b[3]=n*m;b[4]=(k*c-e*i)*m;b[5]=(-h*c+e*g)*m;b[6]=o*m;b[7]=(-j*c+d*i)*m;b[8]=(f*c-d*g)*m;return b};
mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],n=a[9],o=a[10],m=a[11],p=a[12],r=a[13],s=a[14],a=a[15],A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14],b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*n+u*r;c[2]=A*g+B*j+t*o+u*s;c[3]=A*f+B*k+t*m+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*n+y*r;c[6]=v*g+w*j+x*o+y*s;c[7]=v*f+w*k+x*m+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*n+E*r;c[10]=z*g+C*
j+D*o+E*s;c[11]=z*f+C*k+D*m+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*n+b*r;c[14]=q*g+F*j+G*o+b*s;c[15]=q*f+F*k+G*m+b*a;return c};mat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c};
mat4.multiplyVec4=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c};
mat4.translate=function(a,b,c){var d=b[0],e=b[1],b=b[2],g,f,h,i,j,k,l,n,o,m,p,r;if(!c||a===c)return a[12]=a[0]*d+a[4]*e+a[8]*b+a[12],a[13]=a[1]*d+a[5]*e+a[9]*b+a[13],a[14]=a[2]*d+a[6]*e+a[10]*b+a[14],a[15]=a[3]*d+a[7]*e+a[11]*b+a[15],a;g=a[0];f=a[1];h=a[2];i=a[3];j=a[4];k=a[5];l=a[6];n=a[7];o=a[8];m=a[9];p=a[10];r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=n;c[8]=o;c[9]=m;c[10]=p;c[11]=r;c[12]=g*d+j*e+o*b+a[12];c[13]=f*d+k*e+m*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+n*e+r*b+a[15];
return c};mat4.scale=function(a,b,c){var d=b[0],e=b[1],b=b[2];if(!c||a===c)return a[0]*=d,a[1]*=d,a[2]*=d,a[3]*=d,a[4]*=e,a[5]*=e,a[6]*=e,a[7]*=e,a[8]*=b,a[9]*=b,a[10]*=b,a[11]*=b,a;c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};
mat4.rotate=function(a,b,c,d){var e=c[0],g=c[1],c=c[2],f=Math.sqrt(e*e+g*g+c*c),h,i,j,k,l,n,o,m,p,r,s,A,B,t,u,v,w,x,y,z;if(!f)return null;f!==1&&(f=1/f,e*=f,g*=f,c*=f);h=Math.sin(b);i=Math.cos(b);j=1-i;b=a[0];f=a[1];k=a[2];l=a[3];n=a[4];o=a[5];m=a[6];p=a[7];r=a[8];s=a[9];A=a[10];B=a[11];t=e*e*j+i;u=g*e*j+c*h;v=c*e*j-g*h;w=e*g*j-c*h;x=g*g*j+i;y=c*g*j+e*h;z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;d?a!==d&&(d[12]=a[12],d[13]=a[13],d[14]=a[14],d[15]=a[15]):d=a;d[0]=b*t+n*u+r*v;d[1]=f*t+o*u+s*v;d[2]=k*t+m*u+A*
v;d[3]=l*t+p*u+B*v;d[4]=b*w+n*x+r*y;d[5]=f*w+o*x+s*y;d[6]=k*w+m*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+n*e+r*g;d[9]=f*z+o*e+s*g;d[10]=k*z+m*e+A*g;d[11]=l*z+p*e+B*g;return d};mat4.rotateX=function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[4],g=a[5],f=a[6],h=a[7],i=a[8],j=a[9],k=a[10],l=a[11];c?a!==c&&(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[3]=a[3],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[4]=e*b+i*d;c[5]=g*b+j*d;c[6]=f*b+k*d;c[7]=h*b+l*d;c[8]=e*-d+i*b;c[9]=g*-d+j*b;c[10]=f*-d+k*b;c[11]=h*-d+l*b;return c};
mat4.rotateY=function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],i=a[8],j=a[9],k=a[10],l=a[11];c?a!==c&&(c[4]=a[4],c[5]=a[5],c[6]=a[6],c[7]=a[7],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[0]=e*b+i*-d;c[1]=g*b+j*-d;c[2]=f*b+k*-d;c[3]=h*b+l*-d;c[8]=e*d+i*b;c[9]=g*d+j*b;c[10]=f*d+k*b;c[11]=h*d+l*b;return c};
mat4.rotateZ=function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],i=a[4],j=a[5],k=a[6],l=a[7];c?a!==c&&(c[8]=a[8],c[9]=a[9],c[10]=a[10],c[11]=a[11],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[0]=e*b+i*d;c[1]=g*b+j*d;c[2]=f*b+k*d;c[3]=h*b+l*d;c[4]=e*-d+i*b;c[5]=g*-d+j*b;c[6]=f*-d+k*b;c[7]=h*-d+l*b;return c};
mat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b*=a;return mat4.frustum(-b,b,-a,a,c,d,e)};
mat4.ortho=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/i;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/j;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/i;f[14]=-(g+e)/j;f[15]=1;return f};
mat4.lookAt=function(a,b,c,d){d||(d=mat4.create());var e,g,f,h,i,j,k,l,n=a[0],o=a[1],a=a[2];g=c[0];f=c[1];e=c[2];c=b[1];j=b[2];if(n===b[0]&&o===c&&a===j)return mat4.identity(d);c=n-b[0];j=o-b[1];k=a-b[2];l=1/Math.sqrt(c*c+j*j+k*k);c*=l;j*=l;k*=l;b=f*k-e*j;e=e*c-g*k;g=g*j-f*c;(l=Math.sqrt(b*b+e*e+g*g))?(l=1/l,b*=l,e*=l,g*=l):g=e=b=0;f=j*g-k*e;h=k*b-c*g;i=c*e-j*b;(l=Math.sqrt(f*f+h*h+i*i))?(l=1/l,f*=l,h*=l,i*=l):i=h=f=0;d[0]=b;d[1]=f;d[2]=c;d[3]=0;d[4]=e;d[5]=h;d[6]=j;d[7]=0;d[8]=g;d[9]=i;d[10]=k;d[11]=
0;d[12]=-(b*n+e*o+g*a);d[13]=-(f*n+h*o+i*a);d[14]=-(c*n+j*o+k*a);d[15]=1;return d};mat4.fromRotationTranslation=function(a,b,c){c||(c=mat4.create());var d=a[0],e=a[1],g=a[2],f=a[3],h=d+d,i=e+e,j=g+g,a=d*h,k=d*i;d*=j;var l=e*i;e*=j;g*=j;h*=f;i*=f;f*=j;c[0]=1-(l+g);c[1]=k+f;c[2]=d-i;c[3]=0;c[4]=k-f;c[5]=1-(a+g);c[6]=e+h;c[7]=0;c[8]=d+i;c[9]=e-h;c[10]=1-(a+l);c[11]=0;c[12]=b[0];c[13]=b[1];c[14]=b[2];c[15]=1;return c};
mat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+"]"};quat4.create=function(a){var b=new MatrixArray(4);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]);return b};quat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b};
quat4.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a===b)return a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e)),a;b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};quat4.inverse=function(a,b){if(!b||a===b)return a[0]*=-1,a[1]*=-1,a[2]*=-1,a;b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};quat4.length=function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};
quat4.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(f===0)return b[0]=0,b[1]=0,b[2]=0,b[3]=0,b;f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};quat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3],f=b[0],h=b[1],i=b[2],b=b[3];c[0]=d*b+a*f+e*i-g*h;c[1]=e*b+a*h+g*f-d*i;c[2]=g*b+a*i+d*h-e*f;c[3]=a*b-d*f-e*h-g*i;return c};
quat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=a[0],f=a[1],h=a[2],a=a[3],i=a*d+f*g-h*e,j=a*e+h*d-b*g,k=a*g+b*e-f*d,d=-b*d-f*e-h*g;c[0]=i*a+d*-b+j*-h-k*-f;c[1]=j*a+d*-f+k*-b-i*-h;c[2]=k*a+d*-h+i*-f-j*-b;return c};quat4.toMat3=function(a,b){b||(b=mat3.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c*=i;var l=d*h;d*=i;e*=i;f*=g;h*=g;g*=i;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=k-g;b[4]=1-(j+e);b[5]=d+f;b[6]=c+h;b[7]=d-f;b[8]=1-(j+l);return b};
quat4.toMat4=function(a,b){b||(b=mat4.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c*=i;var l=d*h;d*=i;e*=i;f*=g;h*=g;g*=i;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=0;b[4]=k-g;b[5]=1-(j+e);b[6]=d+f;b[7]=0;b[8]=c+h;b[9]=d-f;b[10]=1-(j+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
quat4.slerp=function(a,b,c,d){d||(d=a);var e=a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3],g,f;if(Math.abs(e)>=1)return d!==a&&(d[0]=a[0],d[1]=a[1],d[2]=a[2],d[3]=a[3]),d;g=Math.acos(e);f=Math.sqrt(1-e*e);if(Math.abs(f)<0.001)return d[0]=a[0]*0.5+b[0]*0.5,d[1]=a[1]*0.5+b[1]*0.5,d[2]=a[2]*0.5+b[2]*0.5,d[3]=a[3]*0.5+b[3]*0.5,d;e=Math.sin((1-c)*g)/f;c=Math.sin(c*g)/f;d[0]=a[0]*e+b[0]*c;d[1]=a[1]*e+b[1]*c;d[2]=a[2]*e+b[2]*c;d[3]=a[3]*e+b[3]*c;return d};
quat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+"]"};
(function()
{
	var MAX_VERTICES = 8000;						// equates to 2500 objects being drawn
	var MAX_INDICES = (MAX_VERTICES / 2) * 3;		// 6 indices for every 4 vertices
	var MAX_POINTS = 8000;
	var MULTI_BUFFERS = 4;							// cycle 4 buffers to try and avoid blocking
	var BATCH_NULL = 0;
	var BATCH_QUAD = 1;
	var BATCH_SETTEXTURE = 2;
	var BATCH_SETOPACITY = 3;
	var BATCH_SETBLEND = 4;
	var BATCH_UPDATEMODELVIEW = 5;
	var BATCH_RENDERTOTEXTURE = 6;
	var BATCH_CLEAR = 7;
	var BATCH_POINTS = 8;
	var BATCH_SETPROGRAM = 9;
	var BATCH_SETPROGRAMPARAMETERS = 10;
	var BATCH_SETTEXTURE1 = 11;
	var BATCH_SETCOLOR = 12;
	var BATCH_SETDEPTHTEST = 13;
	var BATCH_SETEARLYZMODE = 14;
	/*
	var lose_ext = null;
	window.lose_context = function ()
	{
		if (!lose_ext)
		{
			console.log("WEBGL_lose_context not supported");
			return;
		}
		lose_ext.loseContext();
	};
	window.restore_context = function ()
	{
		if (!lose_ext)
		{
			console.log("WEBGL_lose_context not supported");
			return;
		}
		lose_ext.restoreContext();
	};
	*/
	var tempMat4 = mat4.create();
	function GLWrap_(gl, isMobile, enableFrontToBack)
	{
		this.isIE = /msie/i.test(navigator.userAgent) || /trident/i.test(navigator.userAgent);
		this.width = 0;		// not yet known, wait for call to setSize()
		this.height = 0;
		this.enableFrontToBack = !!enableFrontToBack;
		this.isEarlyZPass = false;
		this.isBatchInEarlyZPass = false;
		this.currentZ = 0;
		this.zNear = 1;
		this.zFar = 1000;
		this.zIncrement = ((this.zFar - this.zNear) / 32768);
		this.zA = this.zFar / (this.zFar - this.zNear);
		this.zB = this.zFar * this.zNear / (this.zNear - this.zFar);
		this.kzA = 65536 * this.zA;
		this.kzB = 65536 * this.zB;
		this.cam = vec3.create([0, 0, 100]);			// camera position
		this.look = vec3.create([0, 0, 0]);				// lookat position
		this.up = vec3.create([0, 1, 0]);				// up vector
		this.worldScale = vec3.create([1, 1, 1]);		// world scaling factor
		this.enable_mipmaps = true;
		this.matP = mat4.create();						// perspective matrix
		this.matMV = mat4.create();						// model view matrix
		this.lastMV = mat4.create();
		this.currentMV = mat4.create();
		this.gl = gl;
		this.initState();
	};
	GLWrap_.prototype.initState = function ()
	{
		var gl = this.gl;
		var i, len;
		this.lastOpacity = 1;
		this.lastTexture0 = null;			// last bound to TEXTURE0
		this.lastTexture1 = null;			// last bound to TEXTURE1
		this.currentOpacity = 1;
		gl.clearColor(0, 0, 0, 0);
		gl.clear(gl.COLOR_BUFFER_BIT);
		gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.STENCIL_TEST);
		gl.disable(gl.DITHER);
		if (this.enableFrontToBack)
		{
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
		}
		else
		{
			gl.disable(gl.DEPTH_TEST);
		}
		this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		this.lastSrcBlend = gl.ONE;
		this.lastDestBlend = gl.ONE_MINUS_SRC_ALPHA;
		this.vertexData = new Float32Array(MAX_VERTICES * (this.enableFrontToBack ? 3 : 2));
		this.texcoordData = new Float32Array(MAX_VERTICES * 2);
		this.pointData = new Float32Array(MAX_POINTS * 4);
		this.pointBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this.pointData.byteLength, gl.DYNAMIC_DRAW);
		this.vertexBuffers = new Array(MULTI_BUFFERS);
		this.texcoordBuffers = new Array(MULTI_BUFFERS);
		for (i = 0; i < MULTI_BUFFERS; i++)
		{
			this.vertexBuffers[i] = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffers[i]);
			gl.bufferData(gl.ARRAY_BUFFER, this.vertexData.byteLength, gl.DYNAMIC_DRAW);
			this.texcoordBuffers[i] = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffers[i]);
			gl.bufferData(gl.ARRAY_BUFFER, this.texcoordData.byteLength, gl.DYNAMIC_DRAW);
		}
		this.curBuffer = 0;
		this.indexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
		var indexData = new Uint16Array(MAX_INDICES);
		i = 0, len = MAX_INDICES;
		var fv = 0;
		while (i < len)
		{
			indexData[i++] = fv;		// top left
			indexData[i++] = fv + 1;	// top right
			indexData[i++] = fv + 2;	// bottom right (first tri)
			indexData[i++] = fv;		// top left
			indexData[i++] = fv + 2;	// bottom right
			indexData[i++] = fv + 3;	// bottom left
			fv += 4;
		}
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
		this.vertexPtr = 0;
		this.texPtr = 0;
		this.pointPtr = 0;
		var fsSource, vsSource;
		this.shaderPrograms = [];
		fsSource = [
			"varying mediump vec2 vTex;",
			"uniform lowp float opacity;",
			"uniform lowp sampler2D samplerFront;",
			"void main(void) {",
			"	gl_FragColor = texture2D(samplerFront, vTex);",
			"	gl_FragColor *= opacity;",
			"}"
		].join("\n");
		if (this.enableFrontToBack)
		{
			vsSource = [
				"attribute highp vec3 aPos;",
				"attribute mediump vec2 aTex;",
				"varying mediump vec2 vTex;",
				"uniform highp mat4 matP;",
				"uniform highp mat4 matMV;",
				"void main(void) {",
				"	gl_Position = matP * matMV * vec4(aPos.x, aPos.y, aPos.z, 1.0);",
				"	vTex = aTex;",
				"}"
			].join("\n");
		}
		else
		{
			vsSource = [
				"attribute highp vec2 aPos;",
				"attribute mediump vec2 aTex;",
				"varying mediump vec2 vTex;",
				"uniform highp mat4 matP;",
				"uniform highp mat4 matMV;",
				"void main(void) {",
				"	gl_Position = matP * matMV * vec4(aPos.x, aPos.y, 0.0, 1.0);",
				"	vTex = aTex;",
				"}"
			].join("\n");
		}
		var shaderProg = this.createShaderProgram({src: fsSource}, vsSource, "<default>");
;
		this.shaderPrograms.push(shaderProg);		// Default shader is always shader 0
		fsSource = [
			"uniform mediump sampler2D samplerFront;",
			"varying lowp float opacity;",
			"void main(void) {",
			"	gl_FragColor = texture2D(samplerFront, gl_PointCoord);",
			"	gl_FragColor *= opacity;",
			"}"
		].join("\n");
		var pointVsSource = [
			"attribute vec4 aPos;",
			"varying float opacity;",
			"uniform mat4 matP;",
			"uniform mat4 matMV;",
			"void main(void) {",
			"	gl_Position = matP * matMV * vec4(aPos.x, aPos.y, 0.0, 1.0);",
			"	gl_PointSize = aPos.z;",
			"	opacity = aPos.w;",
			"}"
		].join("\n");
		shaderProg = this.createShaderProgram({src: fsSource}, pointVsSource, "<point>");
;
		this.shaderPrograms.push(shaderProg);		// Point shader is always shader 1
		fsSource = [
			"varying mediump vec2 vTex;",
			"uniform lowp sampler2D samplerFront;",
			"void main(void) {",
			"	if (texture2D(samplerFront, vTex).a < 1.0)",
			"		discard;",						// discarding non-opaque fragments
			"}"
		].join("\n");
		var shaderProg = this.createShaderProgram({src: fsSource}, vsSource, "<earlyz>");
;
		this.shaderPrograms.push(shaderProg);		// Early-Z shader is always shader 2
		fsSource = [
			"uniform lowp vec4 colorFill;",
			"void main(void) {",
			"	gl_FragColor = colorFill;",
			"}"
		].join("\n");
		var shaderProg = this.createShaderProgram({src: fsSource}, vsSource, "<fill>");
;
		this.shaderPrograms.push(shaderProg);		// Fill-color shader is always shader 3
		for (var shader_name in cr.shaders)
		{
			if (cr.shaders.hasOwnProperty(shader_name))
				this.shaderPrograms.push(this.createShaderProgram(cr.shaders[shader_name], vsSource, shader_name));
		}
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, null);
		this.batch = [];
		this.batchPtr = 0;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
		this.lastProgram = -1;				// start -1 so first switchProgram can do work
		this.currentProgram = -1;			// current program during batch execution
		this.currentShader = null;
		this.fbo = gl.createFramebuffer();
		this.renderToTex = null;
		this.depthBuffer = null;
		this.attachedDepthBuffer = false;	// wait until first size call to attach, otherwise it has no storage
		if (this.enableFrontToBack)
		{
			this.depthBuffer = gl.createRenderbuffer();
		}
		this.tmpVec3 = vec3.create([0, 0, 0]);
;
		var pointsizes = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
		this.minPointSize = pointsizes[0];
		this.maxPointSize = pointsizes[1];
		if (this.maxPointSize > 2048)
			this.maxPointSize = 2048;
;
		this.switchProgram(0);
		cr.seal(this);
	};
	function GLShaderProgram(gl, shaderProgram, name)
	{
		this.gl = gl;
		this.shaderProgram = shaderProgram;
		this.name = name;
		this.locAPos = gl.getAttribLocation(shaderProgram, "aPos");
		this.locATex = gl.getAttribLocation(shaderProgram, "aTex");
		this.locMatP = gl.getUniformLocation(shaderProgram, "matP");
		this.locMatMV = gl.getUniformLocation(shaderProgram, "matMV");
		this.locOpacity = gl.getUniformLocation(shaderProgram, "opacity");
		this.locColorFill = gl.getUniformLocation(shaderProgram, "colorFill");
		this.locSamplerFront = gl.getUniformLocation(shaderProgram, "samplerFront");
		this.locSamplerBack = gl.getUniformLocation(shaderProgram, "samplerBack");
		this.locDestStart = gl.getUniformLocation(shaderProgram, "destStart");
		this.locDestEnd = gl.getUniformLocation(shaderProgram, "destEnd");
		this.locSeconds = gl.getUniformLocation(shaderProgram, "seconds");
		this.locPixelWidth = gl.getUniformLocation(shaderProgram, "pixelWidth");
		this.locPixelHeight = gl.getUniformLocation(shaderProgram, "pixelHeight");
		this.locLayerScale = gl.getUniformLocation(shaderProgram, "layerScale");
		this.locLayerAngle = gl.getUniformLocation(shaderProgram, "layerAngle");
		this.locViewOrigin = gl.getUniformLocation(shaderProgram, "viewOrigin");
		this.locScrollPos = gl.getUniformLocation(shaderProgram, "scrollPos");
		this.hasAnyOptionalUniforms = !!(this.locPixelWidth || this.locPixelHeight || this.locSeconds || this.locSamplerBack || this.locDestStart || this.locDestEnd || this.locLayerScale || this.locLayerAngle || this.locViewOrigin || this.locScrollPos);
		this.lpPixelWidth = -999;		// set to something unlikely so never counts as cached on first set
		this.lpPixelHeight = -999;
		this.lpOpacity = 1;
		this.lpDestStartX = 0.0;
		this.lpDestStartY = 0.0;
		this.lpDestEndX = 1.0;
		this.lpDestEndY = 1.0;
		this.lpLayerScale = 1.0;
		this.lpLayerAngle = 0.0;
		this.lpViewOriginX = 0.0;
		this.lpViewOriginY = 0.0;
		this.lpScrollPosX = 0.0;
		this.lpScrollPosY = 0.0;
		this.lpSeconds = 0.0;
		this.lastCustomParams = [];
		this.lpMatMV = mat4.create();
		if (this.locOpacity)
			gl.uniform1f(this.locOpacity, 1);
		if (this.locColorFill)
			gl.uniform4f(this.locColorFill, 1.0, 1.0, 1.0, 1.0);
		if (this.locSamplerFront)
			gl.uniform1i(this.locSamplerFront, 0);
		if (this.locSamplerBack)
			gl.uniform1i(this.locSamplerBack, 1);
		if (this.locDestStart)
			gl.uniform2f(this.locDestStart, 0.0, 0.0);
		if (this.locDestEnd)
			gl.uniform2f(this.locDestEnd, 1.0, 1.0);
		if (this.locLayerScale)
			gl.uniform1f(this.locLayerScale, 1.0);
		if (this.locLayerAngle)
			gl.uniform1f(this.locLayerAngle, 0.0);
		if (this.locViewOrigin)
			gl.uniform2f(this.locViewOrigin, 0.0, 0.0);
		if (this.locScrollPos)
			gl.uniform2f(this.locScrollPos, 0.0, 0.0);
		if (this.locSeconds)
			gl.uniform1f(this.locSeconds, 0.0);
		this.hasCurrentMatMV = false;		// matMV needs updating
	};
	function areMat4sEqual(a, b)
	{
		return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3]&&
			   a[4]===b[4]&&a[5]===b[5]&&a[6]===b[6]&&a[7]===b[7]&&
			   a[8]===b[8]&&a[9]===b[9]&&a[10]===b[10]&&a[11]===b[11]&&
			   a[12]===b[12]&&a[13]===b[13]&&a[14]===b[14]&&a[15]===b[15];
	};
	GLShaderProgram.prototype.updateMatMV = function (mv)
	{
		if (areMat4sEqual(this.lpMatMV, mv))
			return;		// no change, save the expensive GL call
		mat4.set(mv, this.lpMatMV);
		this.gl.uniformMatrix4fv(this.locMatMV, false, mv);
	};
	GLWrap_.prototype.createShaderProgram = function(shaderEntry, vsSource, name)
	{
		var gl = this.gl;
		var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragmentShader, shaderEntry.src);
		gl.compileShader(fragmentShader);
		if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
		{
;
			gl.deleteShader(fragmentShader);
			return null;
		}
		var vertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertexShader, vsSource);
		gl.compileShader(vertexShader);
		if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
		{
;
			gl.deleteShader(fragmentShader);
			gl.deleteShader(vertexShader);
			return null;
		}
		var shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, fragmentShader);
		gl.attachShader(shaderProgram, vertexShader);
		gl.linkProgram(shaderProgram);
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
		{
;
			gl.deleteShader(fragmentShader);
			gl.deleteShader(vertexShader);
			gl.deleteProgram(shaderProgram);
			return null;
		}
		gl.useProgram(shaderProgram);
		gl.deleteShader(fragmentShader);
		gl.deleteShader(vertexShader);
		var ret = new GLShaderProgram(gl, shaderProgram, name);
		ret.extendBoxHorizontal = shaderEntry.extendBoxHorizontal || 0;
		ret.extendBoxVertical = shaderEntry.extendBoxVertical || 0;
		ret.crossSampling = !!shaderEntry.crossSampling;
		ret.preservesOpaqueness = !!shaderEntry.preservesOpaqueness;
		ret.animated = !!shaderEntry.animated;
		ret.parameters = shaderEntry.parameters || [];
		var i, len;
		for (i = 0, len = ret.parameters.length; i < len; i++)
		{
			ret.parameters[i][1] = gl.getUniformLocation(shaderProgram, ret.parameters[i][0]);
			ret.lastCustomParams.push(0);
			gl.uniform1f(ret.parameters[i][1], 0);
		}
		cr.seal(ret);
		return ret;
	};
	GLWrap_.prototype.getShaderIndex = function(name_)
	{
		var i, len;
		for (i = 0, len = this.shaderPrograms.length; i < len; i++)
		{
			if (this.shaderPrograms[i].name === name_)
				return i;
		}
		return -1;
	};
	GLWrap_.prototype.project = function (x, y, out)
	{
		var mv = this.matMV;
		var proj = this.matP;
		var fTempo = [0, 0, 0, 0, 0, 0, 0, 0];
		fTempo[0] = mv[0]*x+mv[4]*y+mv[12];
		fTempo[1] = mv[1]*x+mv[5]*y+mv[13];
		fTempo[2] = mv[2]*x+mv[6]*y+mv[14];
		fTempo[3] = mv[3]*x+mv[7]*y+mv[15];
		fTempo[4] = proj[0]*fTempo[0]+proj[4]*fTempo[1]+proj[8]*fTempo[2]+proj[12]*fTempo[3];
		fTempo[5] = proj[1]*fTempo[0]+proj[5]*fTempo[1]+proj[9]*fTempo[2]+proj[13]*fTempo[3];
		fTempo[6] = proj[2]*fTempo[0]+proj[6]*fTempo[1]+proj[10]*fTempo[2]+proj[14]*fTempo[3];
		fTempo[7] = -fTempo[2];
		if(fTempo[7]===0.0)	//The w value
			return;
		fTempo[7]=1.0/fTempo[7];
		fTempo[4]*=fTempo[7];
		fTempo[5]*=fTempo[7];
		fTempo[6]*=fTempo[7];
		out[0]=(fTempo[4]*0.5+0.5)*this.width;
		out[1]=(fTempo[5]*0.5+0.5)*this.height;
	};
	GLWrap_.prototype.setSize = function(w, h, force)
	{
		if (this.width === w && this.height === h && !force)
			return;
		this.endBatch();
		var gl = this.gl;
		this.width = w;
		this.height = h;
		gl.viewport(0, 0, w, h);
		mat4.lookAt(this.cam, this.look, this.up, this.matMV);
		if (this.enableFrontToBack)
		{
			mat4.ortho(-w/2, w/2, h/2, -h/2, this.zNear, this.zFar, this.matP);
			this.worldScale[0] = 1;
			this.worldScale[1] = 1;
		}
		else
		{
			mat4.perspective(45, w / h, this.zNear, this.zFar, this.matP);
			var tl = [0, 0];
			var br = [0, 0];
			this.project(0, 0, tl);
			this.project(1, 1, br);
			this.worldScale[0] = 1 / (br[0] - tl[0]);
			this.worldScale[1] = -1 / (br[1] - tl[1]);
		}
		var i, len, s;
		for (i = 0, len = this.shaderPrograms.length; i < len; i++)
		{
			s = this.shaderPrograms[i];
			s.hasCurrentMatMV = false;
			if (s.locMatP)
			{
				gl.useProgram(s.shaderProgram);
				gl.uniformMatrix4fv(s.locMatP, false, this.matP);
			}
		}
		gl.useProgram(this.shaderPrograms[this.lastProgram].shaderProgram);
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.activeTexture(gl.TEXTURE0);
		this.lastTexture0 = null;
		this.lastTexture1 = null;
		if (this.depthBuffer)
		{
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
			gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
			if (!this.attachedDepthBuffer)
			{
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer);
				this.attachedDepthBuffer = true;
			}
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			this.renderToTex = null;
		}
	};
	GLWrap_.prototype.resetModelView = function ()
	{
		mat4.lookAt(this.cam, this.look, this.up, this.matMV);
		mat4.scale(this.matMV, this.worldScale);
	};
	GLWrap_.prototype.translate = function (x, y)
	{
		if (x === 0 && y === 0)
			return;
		this.tmpVec3[0] = x;// * this.worldScale[0];
		this.tmpVec3[1] = y;// * this.worldScale[1];
		this.tmpVec3[2] = 0;
		mat4.translate(this.matMV, this.tmpVec3);
	};
	GLWrap_.prototype.scale = function (x, y)
	{
		if (x === 1 && y === 1)
			return;
		this.tmpVec3[0] = x;
		this.tmpVec3[1] = y;
		this.tmpVec3[2] = 1;
		mat4.scale(this.matMV, this.tmpVec3);
	};
	GLWrap_.prototype.rotateZ = function (a)
	{
		if (a === 0)
			return;
		mat4.rotateZ(this.matMV, a);
	};
	GLWrap_.prototype.updateModelView = function()
	{
		if (areMat4sEqual(this.lastMV, this.matMV))
			return;
		var b = this.pushBatch();
		b.type = BATCH_UPDATEMODELVIEW;
		if (b.mat4param)
			mat4.set(this.matMV, b.mat4param);
		else
			b.mat4param = mat4.create(this.matMV);
		mat4.set(this.matMV, this.lastMV);
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	/*
	var debugBatch = false;
	jQuery(document).mousedown(
		function(info) {
			if (info.which === 2)
				debugBatch = true;
		}
	);
	*/
	GLWrap_.prototype.setEarlyZIndex = function (i)
	{
		if (!this.enableFrontToBack)
			return;
		if (i > 32760)
			i = 32760;
		this.currentZ = this.cam[2] - this.zNear - i * this.zIncrement;
	};
	function GLBatchJob(type_, glwrap_)
	{
		this.type = type_;
		this.glwrap = glwrap_;
		this.gl = glwrap_.gl;
		this.opacityParam = 0;		// for setOpacity()
		this.startIndex = 0;		// for quad()
		this.indexCount = 0;		// "
		this.texParam = null;		// for setTexture()
		this.mat4param = null;		// for updateModelView()
		this.shaderParams = [];		// for user parameters
		cr.seal(this);
	};
	GLBatchJob.prototype.doSetEarlyZPass = function ()
	{
		var gl = this.gl;
		var glwrap = this.glwrap;
		if (this.startIndex !== 0)		// enable
		{
			gl.depthMask(true);			// enable depth writes
			gl.colorMask(false, false, false, false);	// disable color writes
			gl.disable(gl.BLEND);		// no color writes so disable blend
			gl.bindFramebuffer(gl.FRAMEBUFFER, glwrap.fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
			gl.clear(gl.DEPTH_BUFFER_BIT);		// auto-clear depth buffer
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			glwrap.isBatchInEarlyZPass = true;
		}
		else
		{
			gl.depthMask(false);		// disable depth writes, only test existing depth values
			gl.colorMask(true, true, true, true);		// enable color writes
			gl.enable(gl.BLEND);		// turn blending back on
			glwrap.isBatchInEarlyZPass = false;
		}
	};
	GLBatchJob.prototype.doSetTexture = function ()
	{
		this.gl.bindTexture(this.gl.TEXTURE_2D, this.texParam);
	};
	GLBatchJob.prototype.doSetTexture1 = function ()
	{
		var gl = this.gl;
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.texParam);
		gl.activeTexture(gl.TEXTURE0);
	};
	GLBatchJob.prototype.doSetOpacity = function ()
	{
		var o = this.opacityParam;
		var glwrap = this.glwrap;
		glwrap.currentOpacity = o;
		var curProg = glwrap.currentShader;
		if (curProg.locOpacity && curProg.lpOpacity !== o)
		{
			curProg.lpOpacity = o;
			this.gl.uniform1f(curProg.locOpacity, o);
		}
	};
	GLBatchJob.prototype.doQuad = function ()
	{
		this.gl.drawElements(this.gl.TRIANGLES, this.indexCount, this.gl.UNSIGNED_SHORT, this.startIndex);
	};
	GLBatchJob.prototype.doSetBlend = function ()
	{
		this.gl.blendFunc(this.startIndex, this.indexCount);
	};
	GLBatchJob.prototype.doUpdateModelView = function ()
	{
		var i, len, s, shaderPrograms = this.glwrap.shaderPrograms, currentProgram = this.glwrap.currentProgram;
		for (i = 0, len = shaderPrograms.length; i < len; i++)
		{
			s = shaderPrograms[i];
			if (i === currentProgram && s.locMatMV)
			{
				s.updateMatMV(this.mat4param);
				s.hasCurrentMatMV = true;
			}
			else
				s.hasCurrentMatMV = false;
		}
		mat4.set(this.mat4param, this.glwrap.currentMV);
	};
	GLBatchJob.prototype.doRenderToTexture = function ()
	{
		var gl = this.gl;
		var glwrap = this.glwrap;
		if (this.texParam)
		{
			if (glwrap.lastTexture1 === this.texParam)
			{
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, null);
				glwrap.lastTexture1 = null;
				gl.activeTexture(gl.TEXTURE0);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, glwrap.fbo);
			if (!glwrap.isBatchInEarlyZPass)
			{
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texParam, 0);
			}
		}
		else
		{
			if (!glwrap.enableFrontToBack)
			{
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	};
	GLBatchJob.prototype.doClear = function ()
	{
		var gl = this.gl;
		var mode = this.startIndex;
		if (mode === 0)			// clear whole surface
		{
			gl.clearColor(this.mat4param[0], this.mat4param[1], this.mat4param[2], this.mat4param[3]);
			gl.clear(gl.COLOR_BUFFER_BIT);
		}
		else if (mode === 1)	// clear rectangle
		{
			gl.enable(gl.SCISSOR_TEST);
			gl.scissor(this.mat4param[0], this.mat4param[1], this.mat4param[2], this.mat4param[3]);
			gl.clearColor(0, 0, 0, 0);
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.disable(gl.SCISSOR_TEST);
		}
		else					// clear depth
		{
			gl.clear(gl.DEPTH_BUFFER_BIT);
		}
	};
	GLBatchJob.prototype.doSetDepthTestEnabled = function ()
	{
		var gl = this.gl;
		var enable = this.startIndex;
		if (enable !== 0)
		{
			gl.enable(gl.DEPTH_TEST);
		}
		else
		{
			gl.disable(gl.DEPTH_TEST);
		}
	};
	GLBatchJob.prototype.doPoints = function ()
	{
		var gl = this.gl;
		var glwrap = this.glwrap;
		if (glwrap.enableFrontToBack)
			gl.disable(gl.DEPTH_TEST);
		var s = glwrap.shaderPrograms[1];
		gl.useProgram(s.shaderProgram);
		if (!s.hasCurrentMatMV && s.locMatMV)
		{
			s.updateMatMV(glwrap.currentMV);
			s.hasCurrentMatMV = true;
		}
		gl.enableVertexAttribArray(s.locAPos);
		gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.pointBuffer);
		gl.vertexAttribPointer(s.locAPos, 4, gl.FLOAT, false, 0, 0);
		gl.drawArrays(gl.POINTS, this.startIndex / 4, this.indexCount);
		s = glwrap.currentShader;
		gl.useProgram(s.shaderProgram);
		if (s.locAPos >= 0)
		{
			gl.enableVertexAttribArray(s.locAPos);
			gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.vertexBuffers[glwrap.curBuffer]);
			gl.vertexAttribPointer(s.locAPos, glwrap.enableFrontToBack ? 3 : 2, gl.FLOAT, false, 0, 0);
		}
		if (s.locATex >= 0)
		{
			gl.enableVertexAttribArray(s.locATex);
			gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.texcoordBuffers[glwrap.curBuffer]);
			gl.vertexAttribPointer(s.locATex, 2, gl.FLOAT, false, 0, 0);
		}
		if (glwrap.enableFrontToBack)
			gl.enable(gl.DEPTH_TEST);
	};
	GLBatchJob.prototype.doSetProgram = function ()
	{
		var gl = this.gl;
		var glwrap = this.glwrap;
		var s = glwrap.shaderPrograms[this.startIndex];		// recycled param to save memory
		glwrap.currentProgram = this.startIndex;			// current batch program
		glwrap.currentShader = s;
		gl.useProgram(s.shaderProgram);						// switch to
		if (!s.hasCurrentMatMV && s.locMatMV)
		{
			s.updateMatMV(glwrap.currentMV);
			s.hasCurrentMatMV = true;
		}
		if (s.locOpacity && s.lpOpacity !== glwrap.currentOpacity)
		{
			s.lpOpacity = glwrap.currentOpacity;
			gl.uniform1f(s.locOpacity, glwrap.currentOpacity);
		}
		if (s.locAPos >= 0)
		{
			gl.enableVertexAttribArray(s.locAPos);
			gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.vertexBuffers[glwrap.curBuffer]);
			gl.vertexAttribPointer(s.locAPos, glwrap.enableFrontToBack ? 3 : 2, gl.FLOAT, false, 0, 0);
		}
		if (s.locATex >= 0)
		{
			gl.enableVertexAttribArray(s.locATex);
			gl.bindBuffer(gl.ARRAY_BUFFER, glwrap.texcoordBuffers[glwrap.curBuffer]);
			gl.vertexAttribPointer(s.locATex, 2, gl.FLOAT, false, 0, 0);
		}
	}
	GLBatchJob.prototype.doSetColor = function ()
	{
		var s = this.glwrap.currentShader;
		var mat4param = this.mat4param;
		this.gl.uniform4f(s.locColorFill, mat4param[0], mat4param[1], mat4param[2], mat4param[3]);
	};
	GLBatchJob.prototype.doSetProgramParameters = function ()
	{
		var i, len, s = this.glwrap.currentShader;
		var gl = this.gl;
		var mat4param = this.mat4param;
		if (s.locSamplerBack && this.glwrap.lastTexture1 !== this.texParam)
		{
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, this.texParam);
			this.glwrap.lastTexture1 = this.texParam;
			gl.activeTexture(gl.TEXTURE0);
		}
		var v = mat4param[0];
		var v2;
		if (s.locPixelWidth && v !== s.lpPixelWidth)
		{
			s.lpPixelWidth = v;
			gl.uniform1f(s.locPixelWidth, v);
		}
		v = mat4param[1];
		if (s.locPixelHeight && v !== s.lpPixelHeight)
		{
			s.lpPixelHeight = v;
			gl.uniform1f(s.locPixelHeight, v);
		}
		v = mat4param[2];
		v2 = mat4param[3];
		if (s.locDestStart && (v !== s.lpDestStartX || v2 !== s.lpDestStartY))
		{
			s.lpDestStartX = v;
			s.lpDestStartY = v2;
			gl.uniform2f(s.locDestStart, v, v2);
		}
		v = mat4param[4];
		v2 = mat4param[5];
		if (s.locDestEnd && (v !== s.lpDestEndX || v2 !== s.lpDestEndY))
		{
			s.lpDestEndX = v;
			s.lpDestEndY = v2;
			gl.uniform2f(s.locDestEnd, v, v2);
		}
		v = mat4param[6];
		if (s.locLayerScale && v !== s.lpLayerScale)
		{
			s.lpLayerScale = v;
			gl.uniform1f(s.locLayerScale, v);
		}
		v = mat4param[7];
		if (s.locLayerAngle && v !== s.lpLayerAngle)
		{
			s.lpLayerAngle = v;
			gl.uniform1f(s.locLayerAngle, v);
		}
		v = mat4param[8];
		v2 = mat4param[9];
		if (s.locViewOrigin && (v !== s.lpViewOriginX || v2 !== s.lpViewOriginY))
		{
			s.lpViewOriginX = v;
			s.lpViewOriginY = v2;
			gl.uniform2f(s.locViewOrigin, v, v2);
		}
		v = mat4param[10];
		v2 = mat4param[11];
		if (s.locScrollPos && (v !== s.lpScrollPosX || v2 !== s.lpScrollPosY))
		{
			s.lpScrollPosX = v;
			s.lpScrollPosY = v2;
			gl.uniform2f(s.locScrollPos, v, v2);
		}
		v = mat4param[12];
		if (s.locSeconds && v !== s.lpSeconds)
		{
			s.lpSeconds = v;
			gl.uniform1f(s.locSeconds, v);
		}
		if (s.parameters.length)
		{
			for (i = 0, len = s.parameters.length; i < len; i++)
			{
				v = this.shaderParams[i];
				if (v !== s.lastCustomParams[i])
				{
					s.lastCustomParams[i] = v;
					gl.uniform1f(s.parameters[i][1], v);
				}
			}
		}
	};
	GLWrap_.prototype.pushBatch = function ()
	{
		if (this.batchPtr === this.batch.length)
			this.batch.push(new GLBatchJob(BATCH_NULL, this));
		return this.batch[this.batchPtr++];
	};
	GLWrap_.prototype.endBatch = function ()
	{
		if (this.batchPtr === 0)
			return;
		if (this.gl.isContextLost())
			return;
		var gl = this.gl;
		if (this.pointPtr > 0)
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, this.pointBuffer);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.pointData.subarray(0, this.pointPtr));
			if (s && s.locAPos >= 0 && s.name === "<point>")
				gl.vertexAttribPointer(s.locAPos, 4, gl.FLOAT, false, 0, 0);
		}
		if (this.vertexPtr > 0)
		{
			var s = this.currentShader;
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffers[this.curBuffer]);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexData.subarray(0, this.vertexPtr));
			if (s && s.locAPos >= 0 && s.name !== "<point>")
				gl.vertexAttribPointer(s.locAPos, this.enableFrontToBack ? 3 : 2, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffers[this.curBuffer]);
			gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.texcoordData.subarray(0, this.texPtr));
			if (s && s.locATex >= 0 && s.name !== "<point>")
				gl.vertexAttribPointer(s.locATex, 2, gl.FLOAT, false, 0, 0);
		}
		var i, len, b;
		for (i = 0, len = this.batchPtr; i < len; i++)
		{
			b = this.batch[i];
			switch (b.type) {
			case 1:
				b.doQuad();
				break;
			case 2:
				b.doSetTexture();
				break;
			case 3:
				b.doSetOpacity();
				break;
			case 4:
				b.doSetBlend();
				break;
			case 5:
				b.doUpdateModelView();
				break;
			case 6:
				b.doRenderToTexture();
				break;
			case 7:
				b.doClear();
				break;
			case 8:
				b.doPoints();
				break;
			case 9:
				b.doSetProgram();
				break;
			case 10:
				b.doSetProgramParameters();
				break;
			case 11:
				b.doSetTexture1();
				break;
			case 12:
				b.doSetColor();
				break;
			case 13:
				b.doSetDepthTestEnabled();
				break;
			case 14:
				b.doSetEarlyZPass();
				break;
			}
		}
		this.batchPtr = 0;
		this.vertexPtr = 0;
		this.texPtr = 0;
		this.pointPtr = 0;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
		this.isBatchInEarlyZPass = false;
		this.curBuffer++;
		if (this.curBuffer >= MULTI_BUFFERS)
			this.curBuffer = 0;
	};
	GLWrap_.prototype.setOpacity = function (op)
	{
		if (op === this.lastOpacity)
			return;
		if (this.isEarlyZPass)
			return;		// ignore
		var b = this.pushBatch();
		b.type = BATCH_SETOPACITY;
		b.opacityParam = op;
		this.lastOpacity = op;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.setTexture = function (tex)
	{
		if (tex === this.lastTexture0)
			return;
;
		var b = this.pushBatch();
		b.type = BATCH_SETTEXTURE;
		b.texParam = tex;
		this.lastTexture0 = tex;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.setBlend = function (s, d)
	{
		if (s === this.lastSrcBlend && d === this.lastDestBlend)
			return;
		if (this.isEarlyZPass)
			return;		// ignore
		var b = this.pushBatch();
		b.type = BATCH_SETBLEND;
		b.startIndex = s;		// recycle params to save memory
		b.indexCount = d;
		this.lastSrcBlend = s;
		this.lastDestBlend = d;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.isPremultipliedAlphaBlend = function ()
	{
		return (this.lastSrcBlend === this.gl.ONE && this.lastDestBlend === this.gl.ONE_MINUS_SRC_ALPHA);
	};
	GLWrap_.prototype.setAlphaBlend = function ()
	{
		this.setBlend(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
	};
	GLWrap_.prototype.setNoPremultiplyAlphaBlend = function ()
	{
		this.setBlend(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
	};
	var LAST_VERTEX = MAX_VERTICES * 2 - 8;
	GLWrap_.prototype.quad = function(tlx, tly, trx, try_, brx, bry, blx, bly)
	{
		if (this.vertexPtr >= LAST_VERTEX)
			this.endBatch();
		var v = this.vertexPtr;			// vertex cursor
		var t = this.texPtr;
		var vd = this.vertexData;		// vertex data array
		var td = this.texcoordData;		// texture coord data array
		var currentZ = this.currentZ;
		if (this.hasQuadBatchTop)
		{
			this.batch[this.batchPtr - 1].indexCount += 6;
		}
		else
		{
			var b = this.pushBatch();
			b.type = BATCH_QUAD;
			b.startIndex = this.enableFrontToBack ? v : (v / 2) * 3;
			b.indexCount = 6;
			this.hasQuadBatchTop = true;
			this.hasPointBatchTop = false;
		}
		if (this.enableFrontToBack)
		{
			vd[v++] = tlx;
			vd[v++] = tly;
			vd[v++] = currentZ;
			vd[v++] = trx;
			vd[v++] = try_;
			vd[v++] = currentZ;
			vd[v++] = brx;
			vd[v++] = bry;
			vd[v++] = currentZ;
			vd[v++] = blx;
			vd[v++] = bly;
			vd[v++] = currentZ;
		}
		else
		{
			vd[v++] = tlx;
			vd[v++] = tly;
			vd[v++] = trx;
			vd[v++] = try_;
			vd[v++] = brx;
			vd[v++] = bry;
			vd[v++] = blx;
			vd[v++] = bly;
		}
		td[t++] = 0;
		td[t++] = 0;
		td[t++] = 1;
		td[t++] = 0;
		td[t++] = 1;
		td[t++] = 1;
		td[t++] = 0;
		td[t++] = 1;
		this.vertexPtr = v;
		this.texPtr = t;
	};
	GLWrap_.prototype.quadTex = function(tlx, tly, trx, try_, brx, bry, blx, bly, rcTex)
	{
		if (this.vertexPtr >= LAST_VERTEX)
			this.endBatch();
		var v = this.vertexPtr;			// vertex cursor
		var t = this.texPtr;
		var vd = this.vertexData;		// vertex data array
		var td = this.texcoordData;		// texture coord data array
		var currentZ = this.currentZ;
		if (this.hasQuadBatchTop)
		{
			this.batch[this.batchPtr - 1].indexCount += 6;
		}
		else
		{
			var b = this.pushBatch();
			b.type = BATCH_QUAD;
			b.startIndex = this.enableFrontToBack ? v : (v / 2) * 3;
			b.indexCount = 6;
			this.hasQuadBatchTop = true;
			this.hasPointBatchTop = false;
		}
		var rc_left = rcTex.left;
		var rc_top = rcTex.top;
		var rc_right = rcTex.right;
		var rc_bottom = rcTex.bottom;
		if (this.enableFrontToBack)
		{
			vd[v++] = tlx;
			vd[v++] = tly;
			vd[v++] = currentZ;
			vd[v++] = trx;
			vd[v++] = try_;
			vd[v++] = currentZ;
			vd[v++] = brx;
			vd[v++] = bry;
			vd[v++] = currentZ;
			vd[v++] = blx;
			vd[v++] = bly;
			vd[v++] = currentZ;
		}
		else
		{
			vd[v++] = tlx;
			vd[v++] = tly;
			vd[v++] = trx;
			vd[v++] = try_;
			vd[v++] = brx;
			vd[v++] = bry;
			vd[v++] = blx;
			vd[v++] = bly;
		}
		td[t++] = rc_left;
		td[t++] = rc_top;
		td[t++] = rc_right;
		td[t++] = rc_top;
		td[t++] = rc_right;
		td[t++] = rc_bottom;
		td[t++] = rc_left;
		td[t++] = rc_bottom;
		this.vertexPtr = v;
		this.texPtr = t;
	};
	GLWrap_.prototype.quadTexUV = function(tlx, tly, trx, try_, brx, bry, blx, bly, tlu, tlv, tru, trv, bru, brv, blu, blv)
	{
		if (this.vertexPtr >= LAST_VERTEX)
			this.endBatch();
		var v = this.vertexPtr;			// vertex cursor
		var t = this.texPtr;
		var vd = this.vertexData;		// vertex data array
		var td = this.texcoordData;		// texture coord data array
		var currentZ = this.currentZ;
		if (this.hasQuadBatchTop)
		{
			this.batch[this.batchPtr - 1].indexCount += 6;
		}
		else
		{
			var b = this.pushBatch();
			b.type = BATCH_QUAD;
			b.startIndex = this.enableFrontToBack ? v : (v / 2) * 3;
			b.indexCount = 6;
			this.hasQuadBatchTop = true;
			this.hasPointBatchTop = false;
		}
		if (this.enableFrontToBack)
		{
			vd[v++] = tlx;
			vd[v++] = tly;
			vd[v++] = currentZ;
			vd[v++] = trx;
			vd[v++] = try_;
			vd[v++] = currentZ;
			vd[v++] = brx;
			vd[v++] = bry;
			vd[v++] = currentZ;
			vd[v++] = blx;
			vd[v++] = bly;
			vd[v++] = currentZ;
		}
		else
		{
			vd[v++] = tlx;
			vd[v++] = tly;
			vd[v++] = trx;
			vd[v++] = try_;
			vd[v++] = brx;
			vd[v++] = bry;
			vd[v++] = blx;
			vd[v++] = bly;
		}
		td[t++] = tlu;
		td[t++] = tlv;
		td[t++] = tru;
		td[t++] = trv;
		td[t++] = bru;
		td[t++] = brv;
		td[t++] = blu;
		td[t++] = blv;
		this.vertexPtr = v;
		this.texPtr = t;
	};
	GLWrap_.prototype.convexPoly = function(pts)
	{
		var pts_count = pts.length / 2;
;
		var tris = pts_count - 2;	// 3 points = 1 tri, 4 points = 2 tris, 5 points = 3 tris etc.
		var last_tri = tris - 1;
		var p0x = pts[0];
		var p0y = pts[1];
		var i, i2, p1x, p1y, p2x, p2y, p3x, p3y;
		for (i = 0; i < tris; i += 2)		// draw 2 triangles at a time
		{
			i2 = i * 2;
			p1x = pts[i2 + 2];
			p1y = pts[i2 + 3];
			p2x = pts[i2 + 4];
			p2y = pts[i2 + 5];
			if (i === last_tri)
			{
				this.quad(p0x, p0y, p1x, p1y, p2x, p2y, p2x, p2y);
			}
			else
			{
				p3x = pts[i2 + 6];
				p3y = pts[i2 + 7];
				this.quad(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y);
			}
		}
	};
	var LAST_POINT = MAX_POINTS - 4;
	GLWrap_.prototype.point = function(x_, y_, size_, opacity_)
	{
		if (this.pointPtr >= LAST_POINT)
			this.endBatch();
		var p = this.pointPtr;			// point cursor
		var pd = this.pointData;		// point data array
		if (this.hasPointBatchTop)
		{
			this.batch[this.batchPtr - 1].indexCount++;
		}
		else
		{
			var b = this.pushBatch();
			b.type = BATCH_POINTS;
			b.startIndex = p;
			b.indexCount = 1;
			this.hasPointBatchTop = true;
			this.hasQuadBatchTop = false;
		}
		pd[p++] = x_;
		pd[p++] = y_;
		pd[p++] = size_;
		pd[p++] = opacity_;
		this.pointPtr = p;
	};
	GLWrap_.prototype.switchProgram = function (progIndex)
	{
		if (this.lastProgram === progIndex)
			return;			// no change
		var shaderProg = this.shaderPrograms[progIndex];
		if (!shaderProg)
		{
			if (this.lastProgram === 0)
				return;								// already on default shader
			progIndex = 0;
			shaderProg = this.shaderPrograms[0];
		}
		var b = this.pushBatch();
		b.type = BATCH_SETPROGRAM;
		b.startIndex = progIndex;
		this.lastProgram = progIndex;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.programUsesDest = function (progIndex)
	{
		var s = this.shaderPrograms[progIndex];
		return !!(s.locDestStart || s.locDestEnd);
	};
	GLWrap_.prototype.programUsesCrossSampling = function (progIndex)
	{
		var s = this.shaderPrograms[progIndex];
		return !!(s.locDestStart || s.locDestEnd || s.crossSampling);
	};
	GLWrap_.prototype.programPreservesOpaqueness = function (progIndex)
	{
		return this.shaderPrograms[progIndex].preservesOpaqueness;
	};
	GLWrap_.prototype.programExtendsBox = function (progIndex)
	{
		var s = this.shaderPrograms[progIndex];
		return s.extendBoxHorizontal !== 0 || s.extendBoxVertical !== 0;
	};
	GLWrap_.prototype.getProgramBoxExtendHorizontal = function (progIndex)
	{
		return this.shaderPrograms[progIndex].extendBoxHorizontal;
	};
	GLWrap_.prototype.getProgramBoxExtendVertical = function (progIndex)
	{
		return this.shaderPrograms[progIndex].extendBoxVertical;
	};
	GLWrap_.prototype.getProgramParameterType = function (progIndex, paramIndex)
	{
		return this.shaderPrograms[progIndex].parameters[paramIndex][2];
	};
	GLWrap_.prototype.programIsAnimated = function (progIndex)
	{
		return this.shaderPrograms[progIndex].animated;
	};
	GLWrap_.prototype.setProgramParameters = function (backTex, pixelWidth, pixelHeight, destStartX, destStartY, destEndX, destEndY, layerScale, layerAngle, viewOriginLeft, viewOriginTop, scrollPosX, scrollPosY, seconds, params)
	{
		var i, len;
		var s = this.shaderPrograms[this.lastProgram];
		var b, mat4param, shaderParams;
		if (s.hasAnyOptionalUniforms || params.length)
		{
			b = this.pushBatch();
			b.type = BATCH_SETPROGRAMPARAMETERS;
			if (b.mat4param)
				mat4.set(this.matMV, b.mat4param);
			else
				b.mat4param = mat4.create();
			mat4param = b.mat4param;
			mat4param[0] = pixelWidth;
			mat4param[1] = pixelHeight;
			mat4param[2] = destStartX;
			mat4param[3] = destStartY;
			mat4param[4] = destEndX;
			mat4param[5] = destEndY;
			mat4param[6] = layerScale;
			mat4param[7] = layerAngle;
			mat4param[8] = viewOriginLeft;
			mat4param[9] = viewOriginTop;
			mat4param[10] = scrollPosX;
			mat4param[11] = scrollPosY;
			mat4param[12] = seconds;
			if (s.locSamplerBack)
			{
;
				b.texParam = backTex;
			}
			else
				b.texParam = null;
			if (params.length)
			{
				shaderParams = b.shaderParams;
				shaderParams.length = params.length;
				for (i = 0, len = params.length; i < len; i++)
					shaderParams[i] = params[i];
			}
			this.hasQuadBatchTop = false;
			this.hasPointBatchTop = false;
		}
	};
	GLWrap_.prototype.clear = function (r, g, b_, a)
	{
		var b = this.pushBatch();
		b.type = BATCH_CLEAR;
		b.startIndex = 0;					// clear all mode
		if (!b.mat4param)
			b.mat4param = mat4.create();
		b.mat4param[0] = r;
		b.mat4param[1] = g;
		b.mat4param[2] = b_;
		b.mat4param[3] = a;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.clearRect = function (x, y, w, h)
	{
		if (w < 0 || h < 0)
			return;							// invalid clear area
		var b = this.pushBatch();
		b.type = BATCH_CLEAR;
		b.startIndex = 1;					// clear rect mode
		if (!b.mat4param)
			b.mat4param = mat4.create();
		b.mat4param[0] = x;
		b.mat4param[1] = y;
		b.mat4param[2] = w;
		b.mat4param[3] = h;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.clearDepth = function ()
	{
		var b = this.pushBatch();
		b.type = BATCH_CLEAR;
		b.startIndex = 2;					// clear depth mode
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.setEarlyZPass = function (e)
	{
		if (!this.enableFrontToBack)
			return;		// no depth buffer in use
		e = !!e;
		if (this.isEarlyZPass === e)
			return;		// no change
		var b = this.pushBatch();
		b.type = BATCH_SETEARLYZMODE;
		b.startIndex = (e ? 1 : 0);
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
		this.isEarlyZPass = e;
		this.renderToTex = null;
		if (this.isEarlyZPass)
		{
			this.switchProgram(2);		// early Z program
		}
		else
		{
			this.switchProgram(0);		// normal rendering
		}
	};
	GLWrap_.prototype.setDepthTestEnabled = function (e)
	{
		if (!this.enableFrontToBack)
			return;		// no depth buffer in use
		var b = this.pushBatch();
		b.type = BATCH_SETDEPTHTEST;
		b.startIndex = (e ? 1 : 0);
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.fullscreenQuad = function ()
	{
		mat4.set(this.lastMV, tempMat4);
		this.resetModelView();
		this.updateModelView();
		var halfw = this.width / 2;
		var halfh = this.height / 2;
		this.quad(-halfw, halfh, halfw, halfh, halfw, -halfh, -halfw, -halfh);
		mat4.set(tempMat4, this.matMV);
		this.updateModelView();
	};
	GLWrap_.prototype.setColorFillMode = function (r_, g_, b_, a_)
	{
		this.switchProgram(3);
		var b = this.pushBatch();
		b.type = BATCH_SETCOLOR;
		if (!b.mat4param)
			b.mat4param = mat4.create();
		b.mat4param[0] = r_;
		b.mat4param[1] = g_;
		b.mat4param[2] = b_;
		b.mat4param[3] = a_;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	GLWrap_.prototype.setTextureFillMode = function ()
	{
;
		this.switchProgram(0);
	};
	GLWrap_.prototype.restoreEarlyZMode = function ()
	{
;
		this.switchProgram(2);
	};
	GLWrap_.prototype.present = function ()
	{
		this.endBatch();
		this.gl.flush();
		/*
		if (debugBatch)
		{
;
			debugBatch = false;
		}
		*/
	};
	function nextHighestPowerOfTwo(x) {
		--x;
		for (var i = 1; i < 32; i <<= 1) {
			x = x | x >> i;
		}
		return x + 1;
	}
	var all_textures = [];
	var textures_by_src = {};
	GLWrap_.prototype.contextLost = function ()
	{
		cr.clearArray(all_textures);
		textures_by_src = {};
	};
	var BF_RGBA8 = 0;
	var BF_RGB8 = 1;
	var BF_RGBA4 = 2;
	var BF_RGB5_A1 = 3;
	var BF_RGB565 = 4;
	GLWrap_.prototype.loadTexture = function (img, tiling, linearsampling, pixelformat, tiletype, nomip)
	{
		tiling = !!tiling;
		linearsampling = !!linearsampling;
		var tex_key = img.src + "," + tiling + "," + linearsampling + (tiling ? ("," + tiletype) : "");
		var webGL_texture = null;
		if (typeof img.src !== "undefined" && textures_by_src.hasOwnProperty(tex_key))
		{
			webGL_texture = textures_by_src[tex_key];
			webGL_texture.c2refcount++;
			return webGL_texture;
		}
		this.endBatch();
;
		var gl = this.gl;
		var isPOT = (cr.isPOT(img.width) && cr.isPOT(img.height));
		webGL_texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, webGL_texture);
		gl.pixelStorei(gl["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], true);
		var internalformat = gl.RGBA;
		var format = gl.RGBA;
		var type = gl.UNSIGNED_BYTE;
		if (pixelformat && !this.isIE)
		{
			switch (pixelformat) {
			case BF_RGB8:
				internalformat = gl.RGB;
				format = gl.RGB;
				break;
			case BF_RGBA4:
				type = gl.UNSIGNED_SHORT_4_4_4_4;
				break;
			case BF_RGB5_A1:
				type = gl.UNSIGNED_SHORT_5_5_5_1;
				break;
			case BF_RGB565:
				internalformat = gl.RGB;
				format = gl.RGB;
				type = gl.UNSIGNED_SHORT_5_6_5;
				break;
			}
		}
		if (!isPOT && tiling)
		{
			var canvas = document.createElement("canvas");
			canvas.width = cr.nextHighestPowerOfTwo(img.width);
			canvas.height = cr.nextHighestPowerOfTwo(img.height);
			var ctx = canvas.getContext("2d");
			if (typeof ctx["imageSmoothingEnabled"] !== "undefined")
			{
				ctx["imageSmoothingEnabled"] = linearsampling;
			}
			else
			{
				ctx["webkitImageSmoothingEnabled"] = linearsampling;
				ctx["mozImageSmoothingEnabled"] = linearsampling;
				ctx["msImageSmoothingEnabled"] = linearsampling;
			}
			ctx.drawImage(img,
						  0, 0, img.width, img.height,
						  0, 0, canvas.width, canvas.height);
			gl.texImage2D(gl.TEXTURE_2D, 0, internalformat, format, type, canvas);
		}
		else
			gl.texImage2D(gl.TEXTURE_2D, 0, internalformat, format, type, img);
		if (tiling)
		{
			if (tiletype === "repeat-x")
			{
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			}
			else if (tiletype === "repeat-y")
			{
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
			}
			else
			{
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
			}
		}
		else
		{
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		}
		if (linearsampling)
		{
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			if (isPOT && this.enable_mipmaps && !nomip)
			{
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
				gl.generateMipmap(gl.TEXTURE_2D);
			}
			else
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		}
		else
		{
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		}
		gl.bindTexture(gl.TEXTURE_2D, null);
		this.lastTexture0 = null;
		webGL_texture.c2width = img.width;
		webGL_texture.c2height = img.height;
		webGL_texture.c2refcount = 1;
		webGL_texture.c2texkey = tex_key;
		all_textures.push(webGL_texture);
		textures_by_src[tex_key] = webGL_texture;
		return webGL_texture;
	};
	GLWrap_.prototype.createEmptyTexture = function (w, h, linearsampling, _16bit, tiling)
	{
		this.endBatch();
		var gl = this.gl;
		if (this.isIE)
			_16bit = false;
		var webGL_texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, webGL_texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, _16bit ? gl.UNSIGNED_SHORT_4_4_4_4 : gl.UNSIGNED_BYTE, null);
		if (tiling)
		{
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
		}
		else
		{
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		}
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linearsampling ? gl.LINEAR : gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linearsampling ? gl.LINEAR : gl.NEAREST);
		gl.bindTexture(gl.TEXTURE_2D, null);
		this.lastTexture0 = null;
		webGL_texture.c2width = w;
		webGL_texture.c2height = h;
		all_textures.push(webGL_texture);
		return webGL_texture;
	};
	GLWrap_.prototype.videoToTexture = function (video_, texture_, _16bit)
	{
		this.endBatch();
		var gl = this.gl;
		if (this.isIE)
			_16bit = false;
		gl.bindTexture(gl.TEXTURE_2D, texture_);
		gl.pixelStorei(gl["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], true);
		try {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, _16bit ? gl.UNSIGNED_SHORT_4_4_4_4 : gl.UNSIGNED_BYTE, video_);
		}
		catch (e)
		{
			if (console && console.error)
				console.error("Error updating WebGL texture: ", e);
		}
		gl.bindTexture(gl.TEXTURE_2D, null);
		this.lastTexture0 = null;
	};
	GLWrap_.prototype.deleteTexture = function (tex)
	{
		if (!tex)
			return;
		if (typeof tex.c2refcount !== "undefined" && tex.c2refcount > 1)
		{
			tex.c2refcount--;
			return;
		}
		this.endBatch();
		if (tex === this.lastTexture0)
		{
			this.gl.bindTexture(this.gl.TEXTURE_2D, null);
			this.lastTexture0 = null;
		}
		if (tex === this.lastTexture1)
		{
			this.gl.activeTexture(this.gl.TEXTURE1);
			this.gl.bindTexture(this.gl.TEXTURE_2D, null);
			this.gl.activeTexture(this.gl.TEXTURE0);
			this.lastTexture1 = null;
		}
		cr.arrayFindRemove(all_textures, tex);
		if (typeof tex.c2texkey !== "undefined")
			delete textures_by_src[tex.c2texkey];
		this.gl.deleteTexture(tex);
	};
	GLWrap_.prototype.estimateVRAM = function ()
	{
		var total = this.width * this.height * 4 * 2;
		var i, len, t;
		for (i = 0, len = all_textures.length; i < len; i++)
		{
			t = all_textures[i];
			total += (t.c2width * t.c2height * 4);
		}
		return total;
	};
	GLWrap_.prototype.textureCount = function ()
	{
		return all_textures.length;
	};
	GLWrap_.prototype.setRenderingToTexture = function (tex)
	{
		if (tex === this.renderToTex)
			return;
;
		var b = this.pushBatch();
		b.type = BATCH_RENDERTOTEXTURE;
		b.texParam = tex;
		this.renderToTex = tex;
		this.hasQuadBatchTop = false;
		this.hasPointBatchTop = false;
	};
	cr.GLWrap = GLWrap_;
}());
;
(function()
{
	var raf = window["requestAnimationFrame"] ||
	  window["mozRequestAnimationFrame"]    ||
	  window["webkitRequestAnimationFrame"] ||
	  window["msRequestAnimationFrame"]     ||
	  window["oRequestAnimationFrame"];
	function Runtime(canvas)
	{
		if (!canvas || (!canvas.getContext && !canvas["dc"]))
			return;
		if (canvas["c2runtime"])
			return;
		else
			canvas["c2runtime"] = this;
		var self = this;
		this.isCrosswalk = /crosswalk/i.test(navigator.userAgent) || /xwalk/i.test(navigator.userAgent) || !!(typeof window["c2isCrosswalk"] !== "undefined" && window["c2isCrosswalk"]);
		this.isCordova = this.isCrosswalk || (typeof window["device"] !== "undefined" && (typeof window["device"]["cordova"] !== "undefined" || typeof window["device"]["phonegap"] !== "undefined")) || (typeof window["c2iscordova"] !== "undefined" && window["c2iscordova"]);
		this.isPhoneGap = this.isCordova;
		this.isDirectCanvas = !!canvas["dc"];
		this.isAppMobi = (typeof window["AppMobi"] !== "undefined" || this.isDirectCanvas);
		this.isCocoonJs = !!window["c2cocoonjs"];
		this.isEjecta = !!window["c2ejecta"];
		if (this.isCocoonJs)
		{
			CocoonJS["App"]["onSuspended"].addEventListener(function() {
				self["setSuspended"](true);
			});
			CocoonJS["App"]["onActivated"].addEventListener(function () {
				self["setSuspended"](false);
			});
		}
		if (this.isEjecta)
		{
			document.addEventListener("pagehide", function() {
				self["setSuspended"](true);
			});
			document.addEventListener("pageshow", function() {
				self["setSuspended"](false);
			});
			document.addEventListener("resize", function () {
				self["setSize"](window.innerWidth, window.innerHeight);
			});
		}
		this.isDomFree = (this.isDirectCanvas || this.isCocoonJs || this.isEjecta);
		this.isMicrosoftEdge = /edge\//i.test(navigator.userAgent);
		this.isIE = (/msie/i.test(navigator.userAgent) || /trident/i.test(navigator.userAgent) || /iemobile/i.test(navigator.userAgent)) && !this.isMicrosoftEdge;
		this.isTizen = /tizen/i.test(navigator.userAgent);
		this.isAndroid = /android/i.test(navigator.userAgent) && !this.isTizen && !this.isIE && !this.isMicrosoftEdge;		// IE mobile and Tizen masquerade as Android
		this.isiPhone = (/iphone/i.test(navigator.userAgent) || /ipod/i.test(navigator.userAgent)) && !this.isIE && !this.isMicrosoftEdge;	// treat ipod as an iphone; IE mobile masquerades as iPhone
		this.isiPad = /ipad/i.test(navigator.userAgent);
		this.isiOS = this.isiPhone || this.isiPad || this.isEjecta;
		this.isiPhoneiOS6 = (this.isiPhone && /os\s6/i.test(navigator.userAgent));
		this.isChrome = (/chrome/i.test(navigator.userAgent) || /chromium/i.test(navigator.userAgent)) && !this.isIE && !this.isMicrosoftEdge;	// note true on Chromium-based webview on Android 4.4+; IE 'Edge' mode also pretends to be Chrome
		this.isAmazonWebApp = /amazonwebappplatform/i.test(navigator.userAgent);
		this.isFirefox = /firefox/i.test(navigator.userAgent);
		this.isSafari = /safari/i.test(navigator.userAgent) && !this.isChrome && !this.isIE && !this.isMicrosoftEdge;		// Chrome and IE Mobile masquerade as Safari
		this.isWindows = /windows/i.test(navigator.userAgent);
		this.isNWjs = (typeof window["c2nodewebkit"] !== "undefined" || typeof window["c2nwjs"] !== "undefined" || /nodewebkit/i.test(navigator.userAgent) || /nwjs/i.test(navigator.userAgent));
		this.isNodeWebkit = this.isNWjs;		// old name for backwards compat
		this.isArcade = (typeof window["is_scirra_arcade"] !== "undefined");
		this.isWindows8App = !!(typeof window["c2isWindows8"] !== "undefined" && window["c2isWindows8"]);
		this.isWindows8Capable = !!(typeof window["c2isWindows8Capable"] !== "undefined" && window["c2isWindows8Capable"]);
		this.isWindowsPhone8 = !!(typeof window["c2isWindowsPhone8"] !== "undefined" && window["c2isWindowsPhone8"]);
		this.isWindowsPhone81 = !!(typeof window["c2isWindowsPhone81"] !== "undefined" && window["c2isWindowsPhone81"]);
		this.isWindows10 = !!window["cr_windows10"];
		this.isWinJS = (this.isWindows8App || this.isWindows8Capable || this.isWindowsPhone81 || this.isWindows10);	// note not WP8.0
		this.isBlackberry10 = !!(typeof window["c2isBlackberry10"] !== "undefined" && window["c2isBlackberry10"]);
		this.isAndroidStockBrowser = (this.isAndroid && !this.isChrome && !this.isCrosswalk && !this.isFirefox && !this.isAmazonWebApp && !this.isDomFree);
		this.devicePixelRatio = 1;
		this.isMobile = (this.isCordova || this.isCrosswalk || this.isAppMobi || this.isCocoonJs || this.isAndroid || this.isiOS || this.isWindowsPhone8 || this.isWindowsPhone81 || this.isBlackberry10 || this.isTizen || this.isEjecta);
		if (!this.isMobile)
		{
			this.isMobile = /(blackberry|bb10|playbook|palm|symbian|nokia|windows\s+ce|phone|mobile|tablet|kindle|silk)/i.test(navigator.userAgent);
		}
		this.isWKWebView = !!(this.isiOS && this.isCordova && window["webkit"]);
		this.httpServer = null;
		this.httpServerUrl = "";
		if (this.isWKWebView)
		{
			this.httpServer = (cordova && cordova["plugins"] && cordova["plugins"]["CorHttpd"]) ? cordova["plugins"]["CorHttpd"] : null;
		}
		if (typeof cr_is_preview !== "undefined" && !this.isNWjs && (window.location.search === "?nw" || /nodewebkit/i.test(navigator.userAgent) || /nwjs/i.test(navigator.userAgent)))
		{
			this.isNWjs = true;
		}
		this.isDebug = (typeof cr_is_preview !== "undefined" && window.location.search.indexOf("debug") > -1);
		this.canvas = canvas;
		this.canvasdiv = document.getElementById("c2canvasdiv");
		this.gl = null;
		this.glwrap = null;
		this.glUnmaskedRenderer = "(unavailable)";
		this.enableFrontToBack = false;
		this.earlyz_index = 0;
		this.ctx = null;
		this.fullscreenOldMarginCss = "";
		this.firstInFullscreen = false;
		this.oldWidth = 0;		// for restoring non-fullscreen canvas after fullscreen
		this.oldHeight = 0;
		this.canvas.oncontextmenu = function (e) { if (e.preventDefault) e.preventDefault(); return false; };
		this.canvas.onselectstart = function (e) { if (e.preventDefault) e.preventDefault(); return false; };
		if (this.isDirectCanvas)
			window["c2runtime"] = this;
		if (this.isNWjs)
		{
			window["ondragover"] = function(e) { e.preventDefault(); return false; };
			window["ondrop"] = function(e) { e.preventDefault(); return false; };
			if (window["nwgui"] && window["nwgui"]["App"]["clearCache"])
				window["nwgui"]["App"]["clearCache"]();
		}
		if (this.isAndroidStockBrowser && typeof jQuery !== "undefined")
		{
			jQuery("canvas").parents("*").css("overflow", "visible");
		}
		this.width = canvas.width;
		this.height = canvas.height;
		this.draw_width = this.width;
		this.draw_height = this.height;
		this.cssWidth = this.width;
		this.cssHeight = this.height;
		this.lastWindowWidth = window.innerWidth;
		this.lastWindowHeight = window.innerHeight;
		this.forceCanvasAlpha = false;		// allow plugins to force the canvas to display with alpha channel
		this.redraw = true;
		this.isSuspended = false;
		if (!Date.now) {
		  Date.now = function now() {
			return +new Date();
		  };
		}
		this.plugins = [];
		this.types = {};
		this.types_by_index = [];
		this.behaviors = [];
		this.layouts = {};
		this.layouts_by_index = [];
		this.eventsheets = {};
		this.eventsheets_by_index = [];
		this.wait_for_textures = [];        // for blocking until textures loaded
		this.triggers_to_postinit = [];
		this.all_global_vars = [];
		this.all_local_vars = [];
		this.solidBehavior = null;
		this.jumpthruBehavior = null;
		this.shadowcasterBehavior = null;
		this.deathRow = {};
		this.hasPendingInstances = false;		// true if anything exists in create row or death row
		this.isInClearDeathRow = false;
		this.isInOnDestroy = 0;					// needs to support recursion so increments and decrements and is true if > 0
		this.isRunningEvents = false;
		this.isEndingLayout = false;
		this.createRow = [];
		this.isLoadingState = false;
		this.saveToSlot = "";
		this.loadFromSlot = "";
		this.loadFromJson = "";
		this.lastSaveJson = "";
		this.signalledContinuousPreview = false;
		this.suspendDrawing = false;		// for hiding display until continuous preview loads
		this.fireOnCreateAfterLoad = [];	// for delaying "On create" triggers until loading complete
		this.dt = 0;
        this.dt1 = 0;
		this.minimumFramerate = 30;
		this.logictime = 0;			// used to calculate CPUUtilisation
		this.cpuutilisation = 0;
        this.timescale = 1.0;
        this.kahanTime = new cr.KahanAdder();
		this.wallTime = new cr.KahanAdder();
		this.last_tick_time = 0;
		this.fps = 0;
		this.last_fps_time = 0;
		this.tickcount = 0;
		this.execcount = 0;
		this.framecount = 0;        // for fps
		this.objectcount = 0;
		this.changelayout = null;
		this.destroycallbacks = [];
		this.event_stack = [];
		this.event_stack_index = -1;
		this.localvar_stack = [[]];
		this.localvar_stack_index = 0;
		this.trigger_depth = 0;		// recursion depth for triggers
		this.pushEventStack(null);
		this.loop_stack = [];
		this.loop_stack_index = -1;
		this.next_uid = 0;
		this.next_puid = 0;		// permanent unique ids
		this.layout_first_tick = true;
		this.family_count = 0;
		this.suspend_events = [];
		this.raf_id = -1;
		this.timeout_id = -1;
		this.isloading = true;
		this.loadingprogress = 0;
		this.isNodeFullscreen = false;
		this.stackLocalCount = 0;	// number of stack-based local vars for recursion
		this.audioInstance = null;
		this.had_a_click = false;
		this.isInUserInputEvent = false;
		this.objects_to_pretick = new cr.ObjectSet();
        this.objects_to_tick = new cr.ObjectSet();
		this.objects_to_tick2 = new cr.ObjectSet();
		this.registered_collisions = [];
		this.temp_poly = new cr.CollisionPoly([]);
		this.temp_poly2 = new cr.CollisionPoly([]);
		this.allGroups = [];				// array of all event groups
        this.groups_by_name = {};
		this.cndsBySid = {};
		this.actsBySid = {};
		this.varsBySid = {};
		this.blocksBySid = {};
		this.running_layout = null;			// currently running layout
		this.layer_canvas = null;			// for layers "render-to-texture"
		this.layer_ctx = null;
		this.layer_tex = null;
		this.layout_tex = null;
		this.layout_canvas = null;
		this.layout_ctx = null;
		this.is_WebGL_context_lost = false;
		this.uses_background_blending = false;	// if any shader uses background blending, so entire layout renders to texture
		this.fx_tex = [null, null];
		this.fullscreen_scaling = 0;
		this.files_subfolder = "";			// path with project files
		this.objectsByUid = {};				// maps every in-use UID (as a string) to its instance
		this.loaderlogos = null;
		this.snapshotCanvas = null;
		this.snapshotData = "";
		this.objectRefTable = [];
		this.requestProjectData();
	};
	Runtime.prototype.requestProjectData = function ()
	{
		var self = this;
		if (this.isWKWebView)
		{
			if (this.httpServer)
			{
				this.httpServer["startServer"]({
					"port": 0,
					"localhost_only": true
				}, function (url)
				{
					self.httpServerUrl = url;
					self.fetchLocalFileViaCordovaAsText("data.js", function (str)
					{
						self.loadProject(JSON.parse(str));
					}, function (err)
					{
						alert("Error fetching data.js");
					});
				}, function (err)
				{
					alert("error starting local server: " + err);
				});
			}
			else
			{
				this.fetchLocalFileViaCordovaAsText("data.js", function (str)
				{
					self.loadProject(JSON.parse(str));
				}, function (err)
				{
					alert("Error fetching data.js");
				});
			}
			return;
		}
		var xhr;
		if (this.isWindowsPhone8)
			xhr = new ActiveXObject("Microsoft.XMLHTTP");
		else
			xhr = new XMLHttpRequest();
		var datajs_filename = "data.js";
		if (this.isWindows8App || this.isWindowsPhone8 || this.isWindowsPhone81 || this.isWindows10)
			datajs_filename = "data.json";
		xhr.open("GET", datajs_filename, true);
		var supportsJsonResponse = false;
		if (!this.isDomFree && ("response" in xhr) && ("responseType" in xhr))
		{
			try {
				xhr["responseType"] = "json";
				supportsJsonResponse = (xhr["responseType"] === "json");
			}
			catch (e) {
				supportsJsonResponse = false;
			}
		}
		if (!supportsJsonResponse && ("responseType" in xhr))
		{
			try {
				xhr["responseType"] = "text";
			}
			catch (e) {}
		}
		if ("overrideMimeType" in xhr)
		{
			try {
				xhr["overrideMimeType"]("application/json; charset=utf-8");
			}
			catch (e) {}
		}
		if (this.isWindowsPhone8)
		{
			xhr.onreadystatechange = function ()
			{
				if (xhr.readyState !== 4)
					return;
				self.loadProject(JSON.parse(xhr["responseText"]));
			};
		}
		else
		{
			xhr.onload = function ()
			{
				if (supportsJsonResponse)
				{
					self.loadProject(xhr["response"]);					// already parsed by browser
				}
				else
				{
					if (self.isEjecta)
					{
						var str = xhr["responseText"];
						str = str.substr(str.indexOf("{"));		// trim any BOM
						self.loadProject(JSON.parse(str));
					}
					else
					{
						self.loadProject(JSON.parse(xhr["responseText"]));	// forced to sync parse JSON
					}
				}
			};
			xhr.onerror = function (e)
			{
				cr.logerror("Error requesting " + datajs_filename + ":");
				cr.logerror(e);
			};
		}
		xhr.send();
	};
	Runtime.prototype.initRendererAndLoader = function ()
	{
		var self = this;
		var i, len, j, lenj, k, lenk, t, s, l, y;
		this.isRetina = ((!this.isDomFree || this.isEjecta || this.isCordova) && this.useHighDpi && !this.isAndroidStockBrowser);
		if (this.fullscreen_mode === 0 && this.isiOS)
			this.isRetina = false;
		this.devicePixelRatio = (this.isRetina ? (window["devicePixelRatio"] || window["webkitDevicePixelRatio"] || window["mozDevicePixelRatio"] || window["msDevicePixelRatio"] || 1) : 1);
		this.ClearDeathRow();
		var attribs;
		var alpha_canvas = !!(this.forceCanvasAlpha || (this.alphaBackground && !(this.isNWjs || this.isWinJS || this.isWindowsPhone8 || this.isCrosswalk || this.isCordova || this.isAmazonWebApp)));
		if (this.fullscreen_mode > 0)
			this["setSize"](window.innerWidth, window.innerHeight, true);
		try {
			if (this.enableWebGL && (this.isCocoonJs || this.isEjecta || !this.isDomFree))
			{
				attribs = {
					"alpha": alpha_canvas,
					"depth": false,
					"antialias": false,
					"failIfMajorPerformanceCaveat": true
				};
				this.gl = (this.canvas.getContext("webgl", attribs) || this.canvas.getContext("experimental-webgl", attribs));
			}
		}
		catch (e) {
		}
		if (this.gl)
		{
			var debug_ext = this.gl.getExtension("WEBGL_debug_renderer_info");
			if (debug_ext)
			{
				var unmasked_vendor = this.gl.getParameter(debug_ext.UNMASKED_VENDOR_WEBGL);
				var unmasked_renderer = this.gl.getParameter(debug_ext.UNMASKED_RENDERER_WEBGL);
				this.glUnmaskedRenderer = unmasked_renderer + " [" + unmasked_vendor + "]";
			}
			if (this.enableFrontToBack)
				this.glUnmaskedRenderer += " [front-to-back enabled]";
;
			if (!this.isDomFree)
			{
				this.overlay_canvas = document.createElement("canvas");
				jQuery(this.overlay_canvas).appendTo(this.canvas.parentNode);
				this.overlay_canvas.oncontextmenu = function (e) { return false; };
				this.overlay_canvas.onselectstart = function (e) { return false; };
				this.overlay_canvas.width = Math.round(this.cssWidth * this.devicePixelRatio);
				this.overlay_canvas.height = Math.round(this.cssHeight * this.devicePixelRatio);
				jQuery(this.overlay_canvas).css({"width": this.cssWidth + "px",
												"height": this.cssHeight + "px"});
				this.positionOverlayCanvas();
				this.overlay_ctx = this.overlay_canvas.getContext("2d");
			}
			this.glwrap = new cr.GLWrap(this.gl, this.isMobile, this.enableFrontToBack);
			this.glwrap.setSize(this.canvas.width, this.canvas.height);
			this.glwrap.enable_mipmaps = (this.downscalingQuality !== 0);
			this.ctx = null;
			this.canvas.addEventListener("webglcontextlost", function (ev) {
				ev.preventDefault();
				self.onContextLost();
				cr.logexport("[Construct 2] WebGL context lost");
				window["cr_setSuspended"](true);		// stop rendering
			}, false);
			this.canvas.addEventListener("webglcontextrestored", function (ev) {
				self.glwrap.initState();
				self.glwrap.setSize(self.glwrap.width, self.glwrap.height, true);
				self.layer_tex = null;
				self.layout_tex = null;
				self.fx_tex[0] = null;
				self.fx_tex[1] = null;
				self.onContextRestored();
				self.redraw = true;
				cr.logexport("[Construct 2] WebGL context restored");
				window["cr_setSuspended"](false);		// resume rendering
			}, false);
			for (i = 0, len = this.types_by_index.length; i < len; i++)
			{
				t = this.types_by_index[i];
				for (j = 0, lenj = t.effect_types.length; j < lenj; j++)
				{
					s = t.effect_types[j];
					s.shaderindex = this.glwrap.getShaderIndex(s.id);
					s.preservesOpaqueness = this.glwrap.programPreservesOpaqueness(s.shaderindex);
					this.uses_background_blending = this.uses_background_blending || this.glwrap.programUsesDest(s.shaderindex);
				}
			}
			for (i = 0, len = this.layouts_by_index.length; i < len; i++)
			{
				l = this.layouts_by_index[i];
				for (j = 0, lenj = l.effect_types.length; j < lenj; j++)
				{
					s = l.effect_types[j];
					s.shaderindex = this.glwrap.getShaderIndex(s.id);
					s.preservesOpaqueness = this.glwrap.programPreservesOpaqueness(s.shaderindex);
				}
				l.updateActiveEffects();		// update preserves opaqueness flag
				for (j = 0, lenj = l.layers.length; j < lenj; j++)
				{
					y = l.layers[j];
					for (k = 0, lenk = y.effect_types.length; k < lenk; k++)
					{
						s = y.effect_types[k];
						s.shaderindex = this.glwrap.getShaderIndex(s.id);
						s.preservesOpaqueness = this.glwrap.programPreservesOpaqueness(s.shaderindex);
						this.uses_background_blending = this.uses_background_blending || this.glwrap.programUsesDest(s.shaderindex);
					}
					y.updateActiveEffects();		// update preserves opaqueness flag
				}
			}
		}
		else
		{
			if (this.fullscreen_mode > 0 && this.isDirectCanvas)
			{
;
				this.canvas = null;
				document.oncontextmenu = function (e) { return false; };
				document.onselectstart = function (e) { return false; };
				this.ctx = AppMobi["canvas"]["getContext"]("2d");
				try {
					this.ctx["samplingMode"] = this.linearSampling ? "smooth" : "sharp";
					this.ctx["globalScale"] = 1;
					this.ctx["HTML5CompatibilityMode"] = true;
					this.ctx["imageSmoothingEnabled"] = this.linearSampling;
				} catch(e){}
				if (this.width !== 0 && this.height !== 0)
				{
					this.ctx.width = this.width;
					this.ctx.height = this.height;
				}
			}
			if (!this.ctx)
			{
;
				if (this.isCocoonJs)
				{
					attribs = {
						"antialias": !!this.linearSampling,
						"alpha": alpha_canvas
					};
					this.ctx = this.canvas.getContext("2d", attribs);
				}
				else
				{
					attribs = {
						"alpha": alpha_canvas
					};
					this.ctx = this.canvas.getContext("2d", attribs);
				}
				this.setCtxImageSmoothingEnabled(this.ctx, this.linearSampling);
			}
			this.overlay_canvas = null;
			this.overlay_ctx = null;
		}
		this.tickFunc = function (timestamp) { self.tick(false, timestamp); };
		if (window != window.top && !this.isDomFree && !this.isWinJS && !this.isWindowsPhone8)
		{
			document.addEventListener("mousedown", function () {
				window.focus();
			}, true);
			document.addEventListener("touchstart", function () {
				window.focus();
			}, true);
		}
		if (typeof cr_is_preview !== "undefined")
		{
			if (this.isCocoonJs)
				console.log("[Construct 2] In preview-over-wifi via CocoonJS mode");
			if (window.location.search.indexOf("continuous") > -1)
			{
				cr.logexport("Reloading for continuous preview");
				this.loadFromSlot = "__c2_continuouspreview";
				this.suspendDrawing = true;
			}
			if (this.pauseOnBlur && !this.isMobile)
			{
				jQuery(window).focus(function ()
				{
					self["setSuspended"](false);
				});
				jQuery(window).blur(function ()
				{
					var parent = window.parent;
					if (!parent || !parent.document.hasFocus())
						self["setSuspended"](true);
				});
			}
		}
		window.addEventListener("blur", function () {
			self.onWindowBlur();
		});
		if (!this.isDomFree)
		{
			var unfocusFormControlFunc = function (e) {
				if (cr.isCanvasInputEvent(e) && document["activeElement"] && document["activeElement"] !== document.getElementsByTagName("body")[0] && document["activeElement"].blur)
				{
					try {
						document["activeElement"].blur();
					}
					catch (e) {}
				}
			}
			if (window.navigator["pointerEnabled"])
			{
				document.addEventListener("pointerdown", unfocusFormControlFunc);
			}
			else if (window.navigator["msPointerEnabled"])
			{
				document.addEventListener("MSPointerDown", unfocusFormControlFunc);
			}
			else
			{
				document.addEventListener("touchstart", unfocusFormControlFunc);
			}
			document.addEventListener("mousedown", unfocusFormControlFunc);
		}
		if (this.fullscreen_mode === 0 && this.isRetina && this.devicePixelRatio > 1)
		{
			this["setSize"](this.original_width, this.original_height, true);
		}
		this.tryLockOrientation();
		this.getready();	// determine things to preload
		this.go();			// run loading screen
		this.extra = {};
		cr.seal(this);
	};
	var webkitRepaintFlag = false;
	Runtime.prototype["setSize"] = function (w, h, force)
	{
		var offx = 0, offy = 0;
		var neww = 0, newh = 0, intscale = 0;
		if (this.lastWindowWidth === w && this.lastWindowHeight === h && !force)
			return;
		this.lastWindowWidth = w;
		this.lastWindowHeight = h;
		var mode = this.fullscreen_mode;
		var orig_aspect, cur_aspect;
		var isfullscreen = (document["mozFullScreen"] || document["webkitIsFullScreen"] || !!document["msFullscreenElement"] || document["fullScreen"] || this.isNodeFullscreen) && !this.isCordova;
		if (!isfullscreen && this.fullscreen_mode === 0 && !force)
			return;			// ignore size events when not fullscreen and not using a fullscreen-in-browser mode
		if (isfullscreen && this.fullscreen_scaling > 0)
			mode = this.fullscreen_scaling;
		var dpr = this.devicePixelRatio;
		if (mode >= 4)
		{
			orig_aspect = this.original_width / this.original_height;
			cur_aspect = w / h;
			if (cur_aspect > orig_aspect)
			{
				neww = h * orig_aspect;
				if (mode === 5)	// integer scaling
				{
					intscale = (neww * dpr) / this.original_width;
					if (intscale > 1)
						intscale = Math.floor(intscale);
					else if (intscale < 1)
						intscale = 1 / Math.ceil(1 / intscale);
					neww = this.original_width * intscale / dpr;
					newh = this.original_height * intscale / dpr;
					offx = (w - neww) / 2;
					offy = (h - newh) / 2;
					w = neww;
					h = newh;
				}
				else
				{
					offx = (w - neww) / 2;
					w = neww;
				}
			}
			else
			{
				newh = w / orig_aspect;
				if (mode === 5)	// integer scaling
				{
					intscale = (newh * dpr) / this.original_height;
					if (intscale > 1)
						intscale = Math.floor(intscale);
					else if (intscale < 1)
						intscale = 1 / Math.ceil(1 / intscale);
					neww = this.original_width * intscale / dpr;
					newh = this.original_height * intscale / dpr;
					offx = (w - neww) / 2;
					offy = (h - newh) / 2;
					w = neww;
					h = newh;
				}
				else
				{
					offy = (h - newh) / 2;
					h = newh;
				}
			}
			if (isfullscreen && !this.isNWjs)
			{
				offx = 0;
				offy = 0;
			}
		}
		else if (this.isNWjs && this.isNodeFullscreen && this.fullscreen_mode_set === 0)
		{
			offx = Math.floor((w - this.original_width) / 2);
			offy = Math.floor((h - this.original_height) / 2);
			w = this.original_width;
			h = this.original_height;
		}
		if (mode < 2)
			this.aspect_scale = dpr;
		this.cssWidth = Math.round(w);
		this.cssHeight = Math.round(h);
		this.width = Math.round(w * dpr);
		this.height = Math.round(h * dpr);
		this.redraw = true;
		if (this.wantFullscreenScalingQuality)
		{
			this.draw_width = this.width;
			this.draw_height = this.height;
			this.fullscreenScalingQuality = true;
		}
		else
		{
			if ((this.width < this.original_width && this.height < this.original_height) || mode === 1)
			{
				this.draw_width = this.width;
				this.draw_height = this.height;
				this.fullscreenScalingQuality = true;
			}
			else
			{
				this.draw_width = this.original_width;
				this.draw_height = this.original_height;
				this.fullscreenScalingQuality = false;
				/*var orig_aspect = this.original_width / this.original_height;
				var cur_aspect = this.width / this.height;
				if ((this.fullscreen_mode !== 2 && cur_aspect > orig_aspect) || (this.fullscreen_mode === 2 && cur_aspect < orig_aspect))
					this.aspect_scale = this.height / this.original_height;
				else
					this.aspect_scale = this.width / this.original_width;*/
				if (mode === 2)		// scale inner
				{
					orig_aspect = this.original_width / this.original_height;
					cur_aspect = this.lastWindowWidth / this.lastWindowHeight;
					if (cur_aspect < orig_aspect)
						this.draw_width = this.draw_height * cur_aspect;
					else if (cur_aspect > orig_aspect)
						this.draw_height = this.draw_width / cur_aspect;
				}
				else if (mode === 3)
				{
					orig_aspect = this.original_width / this.original_height;
					cur_aspect = this.lastWindowWidth / this.lastWindowHeight;
					if (cur_aspect > orig_aspect)
						this.draw_width = this.draw_height * cur_aspect;
					else if (cur_aspect < orig_aspect)
						this.draw_height = this.draw_width / cur_aspect;
				}
			}
		}
		if (this.canvasdiv && !this.isDomFree)
		{
			jQuery(this.canvasdiv).css({"width": Math.round(w) + "px",
										"height": Math.round(h) + "px",
										"margin-left": Math.floor(offx) + "px",
										"margin-top": Math.floor(offy) + "px"});
			if (typeof cr_is_preview !== "undefined")
			{
				jQuery("#borderwrap").css({"width": Math.round(w) + "px",
											"height": Math.round(h) + "px"});
			}
		}
		if (this.canvas)
		{
			this.canvas.width = Math.round(w * dpr);
			this.canvas.height = Math.round(h * dpr);
			if (this.isEjecta)
			{
				this.canvas.style.left = Math.floor(offx) + "px";
				this.canvas.style.top = Math.floor(offy) + "px";
				this.canvas.style.width = Math.round(w) + "px";
				this.canvas.style.height = Math.round(h) + "px";
			}
			else if (this.isRetina && !this.isDomFree)
			{
				this.canvas.style.width = Math.round(w) + "px";
				this.canvas.style.height = Math.round(h) + "px";
			}
		}
		if (this.overlay_canvas)
		{
			this.overlay_canvas.width = Math.round(w * dpr);
			this.overlay_canvas.height = Math.round(h * dpr);
			this.overlay_canvas.style.width = this.cssWidth + "px";
			this.overlay_canvas.style.height = this.cssHeight + "px";
		}
		if (this.glwrap)
		{
			this.glwrap.setSize(Math.round(w * dpr), Math.round(h * dpr));
		}
		if (this.isDirectCanvas && this.ctx)
		{
			this.ctx.width = Math.round(w);
			this.ctx.height = Math.round(h);
		}
		if (this.ctx)
		{
			this.setCtxImageSmoothingEnabled(this.ctx, this.linearSampling);
		}
		this.tryLockOrientation();
		if (this.isiPhone && !this.isCordova)
		{
			window.scrollTo(0, 0);
		}
	};
	Runtime.prototype.tryLockOrientation = function ()
	{
		if (!this.autoLockOrientation || this.orientations === 0)
			return;
		var orientation = "portrait";
		if (this.orientations === 2)
			orientation = "landscape";
		try {
			if (screen["orientation"] && screen["orientation"]["lock"])
				screen["orientation"]["lock"](orientation).catch(function(){});
			else if (screen["lockOrientation"])
				screen["lockOrientation"](orientation);
			else if (screen["webkitLockOrientation"])
				screen["webkitLockOrientation"](orientation);
			else if (screen["mozLockOrientation"])
				screen["mozLockOrientation"](orientation);
			else if (screen["msLockOrientation"])
				screen["msLockOrientation"](orientation);
		}
		catch (e)
		{
			if (console && console.warn)
				console.warn("Failed to lock orientation: ", e);
		}
	};
	Runtime.prototype.onContextLost = function ()
	{
		this.glwrap.contextLost();
		this.is_WebGL_context_lost = true;
		var i, len, t;
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			t = this.types_by_index[i];
			if (t.onLostWebGLContext)
				t.onLostWebGLContext();
		}
	};
	Runtime.prototype.onContextRestored = function ()
	{
		this.is_WebGL_context_lost = false;
		var i, len, t;
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			t = this.types_by_index[i];
			if (t.onRestoreWebGLContext)
				t.onRestoreWebGLContext();
		}
	};
	Runtime.prototype.positionOverlayCanvas = function()
	{
		if (this.isDomFree)
			return;
		var isfullscreen = (document["mozFullScreen"] || document["webkitIsFullScreen"] || document["fullScreen"] || !!document["msFullscreenElement"] || this.isNodeFullscreen) && !this.isCordova;
		var overlay_position = isfullscreen ? jQuery(this.canvas).offset() : jQuery(this.canvas).position();
		overlay_position.position = "absolute";
		jQuery(this.overlay_canvas).css(overlay_position);
	};
	var caf = window["cancelAnimationFrame"] ||
	  window["mozCancelAnimationFrame"]    ||
	  window["webkitCancelAnimationFrame"] ||
	  window["msCancelAnimationFrame"]     ||
	  window["oCancelAnimationFrame"];
	Runtime.prototype["setSuspended"] = function (s)
	{
		var i, len;
		var self = this;
		if (s && !this.isSuspended)
		{
			cr.logexport("[Construct 2] Suspending");
			this.isSuspended = true;			// next tick will be last
			if (this.raf_id !== -1 && caf)		// note: CocoonJS does not implement cancelAnimationFrame
				caf(this.raf_id);
			if (this.timeout_id !== -1)
				clearTimeout(this.timeout_id);
			for (i = 0, len = this.suspend_events.length; i < len; i++)
				this.suspend_events[i](true);
		}
		else if (!s && this.isSuspended)
		{
			cr.logexport("[Construct 2] Resuming");
			this.isSuspended = false;
			this.last_tick_time = cr.performance_now();	// ensure first tick is a zero-dt one
			this.last_fps_time = cr.performance_now();	// reset FPS counter
			this.framecount = 0;
			this.logictime = 0;
			for (i = 0, len = this.suspend_events.length; i < len; i++)
				this.suspend_events[i](false);
			this.tick(false);						// kick off runtime again
		}
	};
	Runtime.prototype.addSuspendCallback = function (f)
	{
		this.suspend_events.push(f);
	};
	Runtime.prototype.GetObjectReference = function (i)
	{
;
		return this.objectRefTable[i];
	};
	Runtime.prototype.loadProject = function (data_response)
	{
;
		if (!data_response || !data_response["project"])
			cr.logerror("Project model unavailable");
		var pm = data_response["project"];
		this.name = pm[0];
		this.first_layout = pm[1];
		this.fullscreen_mode = pm[12];	// 0 = off, 1 = crop, 2 = scale inner, 3 = scale outer, 4 = letterbox scale, 5 = integer letterbox scale
		this.fullscreen_mode_set = pm[12];
		this.original_width = pm[10];
		this.original_height = pm[11];
		this.parallax_x_origin = this.original_width / 2;
		this.parallax_y_origin = this.original_height / 2;
		if (this.isDomFree && !this.isEjecta && (pm[12] >= 4 || pm[12] === 0))
		{
			cr.logexport("[Construct 2] Letterbox scale fullscreen modes are not supported on this platform - falling back to 'Scale outer'");
			this.fullscreen_mode = 3;
			this.fullscreen_mode_set = 3;
		}
		this.uses_loader_layout = pm[18];
		this.loaderstyle = pm[19];
		if (this.loaderstyle === 0)
		{
			var loaderImage = new Image();
			loaderImage.crossOrigin = "anonymous";
			this.setImageSrc(loaderImage, "loading-logo.png");
			this.loaderlogos = {
				logo: loaderImage
			};
		}
		else if (this.loaderstyle === 4)	// c2 splash
		{
			var loaderC2logo_1024 = new Image();
			loaderC2logo_1024.src = "";
			var loaderC2logo_512 = new Image();
			loaderC2logo_512.src = "";
			var loaderC2logo_256 = new Image();
			loaderC2logo_256.src = "";
			var loaderC2logo_128 = new Image();
			loaderC2logo_128.src = "";
			var loaderPowered_1024 = new Image();
			loaderPowered_1024.src = "";
			var loaderPowered_512 = new Image();
			loaderPowered_512.src = "";
			var loaderPowered_256 = new Image();
			loaderPowered_256.src = "";
			var loaderPowered_128 = new Image();
			loaderPowered_128.src = "";
			var loaderWebsite_1024 = new Image();
			loaderWebsite_1024.src = "";
			var loaderWebsite_512 = new Image();
			loaderWebsite_512.src = "";
			var loaderWebsite_256 = new Image();
			loaderWebsite_256.src = "";
			var loaderWebsite_128 = new Image();
			loaderWebsite_128.src = "";
			this.loaderlogos = {
				logo: [loaderC2logo_1024, loaderC2logo_512, loaderC2logo_256, loaderC2logo_128],
				powered: [loaderPowered_1024, loaderPowered_512, loaderPowered_256, loaderPowered_128],
				website: [loaderWebsite_1024, loaderWebsite_512, loaderWebsite_256, loaderWebsite_128]
			};
		}
		this.next_uid = pm[21];
		this.objectRefTable = cr.getObjectRefTable();
		this.system = new cr.system_object(this);
		var i, len, j, lenj, k, lenk, idstr, m, b, t, f, p;
		var plugin, plugin_ctor;
		for (i = 0, len = pm[2].length; i < len; i++)
		{
			m = pm[2][i];
			p = this.GetObjectReference(m[0]);
;
			cr.add_common_aces(m, p.prototype);
			plugin = new p(this);
			plugin.singleglobal = m[1];
			plugin.is_world = m[2];
			plugin.must_predraw = m[9];
			if (plugin.onCreate)
				plugin.onCreate();  // opportunity to override default ACEs
			cr.seal(plugin);
			this.plugins.push(plugin);
		}
		this.objectRefTable = cr.getObjectRefTable();
		for (i = 0, len = pm[3].length; i < len; i++)
		{
			m = pm[3][i];
			plugin_ctor = this.GetObjectReference(m[1]);
;
			plugin = null;
			for (j = 0, lenj = this.plugins.length; j < lenj; j++)
			{
				if (this.plugins[j] instanceof plugin_ctor)
				{
					plugin = this.plugins[j];
					break;
				}
			}
;
;
			var type_inst = new plugin.Type(plugin);
;
			type_inst.name = m[0];
			type_inst.is_family = m[2];
			type_inst.instvar_sids = m[3].slice(0);
			type_inst.vars_count = m[3].length;
			type_inst.behs_count = m[4];
			type_inst.fx_count = m[5];
			type_inst.sid = m[11];
			if (type_inst.is_family)
			{
				type_inst.members = [];				// types in this family
				type_inst.family_index = this.family_count++;
				type_inst.families = null;
			}
			else
			{
				type_inst.members = null;
				type_inst.family_index = -1;
				type_inst.families = [];			// families this type belongs to
			}
			type_inst.family_var_map = null;
			type_inst.family_beh_map = null;
			type_inst.family_fx_map = null;
			type_inst.is_contained = false;
			type_inst.container = null;
			if (m[6])
			{
				type_inst.texture_file = m[6][0];
				type_inst.texture_filesize = m[6][1];
				type_inst.texture_pixelformat = m[6][2];
			}
			else
			{
				type_inst.texture_file = null;
				type_inst.texture_filesize = 0;
				type_inst.texture_pixelformat = 0;		// rgba8
			}
			if (m[7])
			{
				type_inst.animations = m[7];
			}
			else
			{
				type_inst.animations = null;
			}
			type_inst.index = i;                                // save index in to types array in type
			type_inst.instances = [];                           // all instances of this type
			type_inst.deadCache = [];							// destroyed instances to recycle next create
			type_inst.solstack = [new cr.selection(type_inst)]; // initialise SOL stack with one empty SOL
			type_inst.cur_sol = 0;
			type_inst.default_instance = null;
			type_inst.default_layerindex = 0;
			type_inst.stale_iids = true;
			type_inst.updateIIDs = cr.type_updateIIDs;
			type_inst.getFirstPicked = cr.type_getFirstPicked;
			type_inst.getPairedInstance = cr.type_getPairedInstance;
			type_inst.getCurrentSol = cr.type_getCurrentSol;
			type_inst.pushCleanSol = cr.type_pushCleanSol;
			type_inst.pushCopySol = cr.type_pushCopySol;
			type_inst.popSol = cr.type_popSol;
			type_inst.getBehaviorByName = cr.type_getBehaviorByName;
			type_inst.getBehaviorIndexByName = cr.type_getBehaviorIndexByName;
			type_inst.getEffectIndexByName = cr.type_getEffectIndexByName;
			type_inst.applySolToContainer = cr.type_applySolToContainer;
			type_inst.getInstanceByIID = cr.type_getInstanceByIID;
			type_inst.collision_grid = new cr.SparseGrid(this.original_width, this.original_height);
			type_inst.any_cell_changed = true;
			type_inst.any_instance_parallaxed = false;
			type_inst.extra = {};
			type_inst.toString = cr.type_toString;
			type_inst.behaviors = [];
			for (j = 0, lenj = m[8].length; j < lenj; j++)
			{
				b = m[8][j];
				var behavior_ctor = this.GetObjectReference(b[1]);
				var behavior_plugin = null;
				for (k = 0, lenk = this.behaviors.length; k < lenk; k++)
				{
					if (this.behaviors[k] instanceof behavior_ctor)
					{
						behavior_plugin = this.behaviors[k];
						break;
					}
				}
				if (!behavior_plugin)
				{
					behavior_plugin = new behavior_ctor(this);
					behavior_plugin.my_types = [];						// types using this behavior
					behavior_plugin.my_instances = new cr.ObjectSet(); 	// instances of this behavior
					if (behavior_plugin.onCreate)
						behavior_plugin.onCreate();
					cr.seal(behavior_plugin);
					this.behaviors.push(behavior_plugin);
					if (cr.behaviors.solid && behavior_plugin instanceof cr.behaviors.solid)
						this.solidBehavior = behavior_plugin;
					if (cr.behaviors.jumpthru && behavior_plugin instanceof cr.behaviors.jumpthru)
						this.jumpthruBehavior = behavior_plugin;
					if (cr.behaviors.shadowcaster && behavior_plugin instanceof cr.behaviors.shadowcaster)
						this.shadowcasterBehavior = behavior_plugin;
				}
				if (behavior_plugin.my_types.indexOf(type_inst) === -1)
					behavior_plugin.my_types.push(type_inst);
				var behavior_type = new behavior_plugin.Type(behavior_plugin, type_inst);
				behavior_type.name = b[0];
				behavior_type.sid = b[2];
				behavior_type.onCreate();
				cr.seal(behavior_type);
				type_inst.behaviors.push(behavior_type);
			}
			type_inst.global = m[9];
			type_inst.isOnLoaderLayout = m[10];
			type_inst.effect_types = [];
			for (j = 0, lenj = m[12].length; j < lenj; j++)
			{
				type_inst.effect_types.push({
					id: m[12][j][0],
					name: m[12][j][1],
					shaderindex: -1,
					preservesOpaqueness: false,
					active: true,
					index: j
				});
			}
			type_inst.tile_poly_data = m[13];
			if (!this.uses_loader_layout || type_inst.is_family || type_inst.isOnLoaderLayout || !plugin.is_world)
			{
				type_inst.onCreate();
				cr.seal(type_inst);
			}
			if (type_inst.name)
				this.types[type_inst.name] = type_inst;
			this.types_by_index.push(type_inst);
			if (plugin.singleglobal)
			{
				var instance = new plugin.Instance(type_inst);
				instance.uid = this.next_uid++;
				instance.puid = this.next_puid++;
				instance.iid = 0;
				instance.get_iid = cr.inst_get_iid;
				instance.toString = cr.inst_toString;
				instance.properties = m[14];
				instance.onCreate();
				cr.seal(instance);
				type_inst.instances.push(instance);
				this.objectsByUid[instance.uid.toString()] = instance;
			}
		}
		for (i = 0, len = pm[4].length; i < len; i++)
		{
			var familydata = pm[4][i];
			var familytype = this.types_by_index[familydata[0]];
			var familymember;
			for (j = 1, lenj = familydata.length; j < lenj; j++)
			{
				familymember = this.types_by_index[familydata[j]];
				familymember.families.push(familytype);
				familytype.members.push(familymember);
			}
		}
		for (i = 0, len = pm[28].length; i < len; i++)
		{
			var containerdata = pm[28][i];
			var containertypes = [];
			for (j = 0, lenj = containerdata.length; j < lenj; j++)
				containertypes.push(this.types_by_index[containerdata[j]]);
			for (j = 0, lenj = containertypes.length; j < lenj; j++)
			{
				containertypes[j].is_contained = true;
				containertypes[j].container = containertypes;
			}
		}
		if (this.family_count > 0)
		{
			for (i = 0, len = this.types_by_index.length; i < len; i++)
			{
				t = this.types_by_index[i];
				if (t.is_family || !t.families.length)
					continue;
				t.family_var_map = new Array(this.family_count);
				t.family_beh_map = new Array(this.family_count);
				t.family_fx_map = new Array(this.family_count);
				var all_fx = [];
				var varsum = 0;
				var behsum = 0;
				var fxsum = 0;
				for (j = 0, lenj = t.families.length; j < lenj; j++)
				{
					f = t.families[j];
					t.family_var_map[f.family_index] = varsum;
					varsum += f.vars_count;
					t.family_beh_map[f.family_index] = behsum;
					behsum += f.behs_count;
					t.family_fx_map[f.family_index] = fxsum;
					fxsum += f.fx_count;
					for (k = 0, lenk = f.effect_types.length; k < lenk; k++)
						all_fx.push(cr.shallowCopy({}, f.effect_types[k]));
				}
				t.effect_types = all_fx.concat(t.effect_types);
				for (j = 0, lenj = t.effect_types.length; j < lenj; j++)
					t.effect_types[j].index = j;
			}
		}
		for (i = 0, len = pm[5].length; i < len; i++)
		{
			m = pm[5][i];
			var layout = new cr.layout(this, m);
			cr.seal(layout);
			this.layouts[layout.name] = layout;
			this.layouts_by_index.push(layout);
		}
		for (i = 0, len = pm[6].length; i < len; i++)
		{
			m = pm[6][i];
			var sheet = new cr.eventsheet(this, m);
			cr.seal(sheet);
			this.eventsheets[sheet.name] = sheet;
			this.eventsheets_by_index.push(sheet);
		}
		for (i = 0, len = this.eventsheets_by_index.length; i < len; i++)
			this.eventsheets_by_index[i].postInit();
		for (i = 0, len = this.eventsheets_by_index.length; i < len; i++)
			this.eventsheets_by_index[i].updateDeepIncludes();
		for (i = 0, len = this.triggers_to_postinit.length; i < len; i++)
			this.triggers_to_postinit[i].postInit();
		cr.clearArray(this.triggers_to_postinit)
		this.audio_to_preload = pm[7];
		this.files_subfolder = pm[8];
		this.pixel_rounding = pm[9];
		this.aspect_scale = 1.0;
		this.enableWebGL = pm[13];
		this.linearSampling = pm[14];
		this.alphaBackground = pm[15];
		this.versionstr = pm[16];
		this.useHighDpi = pm[17];
		this.orientations = pm[20];		// 0 = any, 1 = portrait, 2 = landscape
		this.autoLockOrientation = (this.orientations > 0);
		this.pauseOnBlur = pm[22];
		this.wantFullscreenScalingQuality = pm[23];		// false = low quality, true = high quality
		this.fullscreenScalingQuality = this.wantFullscreenScalingQuality;
		this.downscalingQuality = pm[24];	// 0 = low (mips off), 1 = medium (mips on, dense spritesheet), 2 = high (mips on, sparse spritesheet)
		this.preloadSounds = pm[25];		// 0 = no, 1 = yes
		this.projectName = pm[26];
		this.enableFrontToBack = pm[27] && !this.isIE;		// front-to-back renderer disabled in IE (but not Edge)
		this.start_time = Date.now();
		cr.clearArray(this.objectRefTable);
		this.initRendererAndLoader();
	};
	var anyImageHadError = false;
	Runtime.prototype.waitForImageLoad = function (img_, src_)
	{
		img_["cocoonLazyLoad"] = true;
		img_.onerror = function (e)
		{
			img_.c2error = true;
			anyImageHadError = true;
			if (console && console.error)
				console.error("Error loading image '" + img_.src + "': ", e);
		};
		if (this.isEjecta)
		{
			img_.src = src_;
		}
		else if (!img_.src)
		{
			if (typeof XAPKReader !== "undefined")
			{
				XAPKReader.get(src_, function (expanded_url)
				{
					img_.src = expanded_url;
				}, function (e)
				{
					img_.c2error = true;
					anyImageHadError = true;
					if (console && console.error)
						console.error("Error extracting image '" + src_ + "' from expansion file: ", e);
				});
			}
			else
			{
				img_.crossOrigin = "anonymous";			// required for Arcade sandbox compatibility
				this.setImageSrc(img_, src_);			// work around WKWebView problems
			}
		}
		this.wait_for_textures.push(img_);
	};
	Runtime.prototype.findWaitingTexture = function (src_)
	{
		var i, len;
		for (i = 0, len = this.wait_for_textures.length; i < len; i++)
		{
			if (this.wait_for_textures[i].cr_src === src_)
				return this.wait_for_textures[i];
		}
		return null;
	};
	var audio_preload_totalsize = 0;
	var audio_preload_started = false;
	Runtime.prototype.getready = function ()
	{
		if (!this.audioInstance)
			return;
		audio_preload_totalsize = this.audioInstance.setPreloadList(this.audio_to_preload);
	};
	Runtime.prototype.areAllTexturesAndSoundsLoaded = function ()
	{
		var totalsize = audio_preload_totalsize;
		var completedsize = 0;
		var audiocompletedsize = 0;
		var ret = true;
		var i, len, img;
		for (i = 0, len = this.wait_for_textures.length; i < len; i++)
		{
			img = this.wait_for_textures[i];
			var filesize = img.cr_filesize;
			if (!filesize || filesize <= 0)
				filesize = 50000;
			totalsize += filesize;
			if (!!img.src && (img.complete || img["loaded"]) && !img.c2error)
				completedsize += filesize;
			else
				ret = false;    // not all textures loaded
		}
		if (ret && this.preloadSounds && this.audioInstance)
		{
			if (!audio_preload_started)
			{
				this.audioInstance.startPreloads();
				audio_preload_started = true;
			}
			audiocompletedsize = this.audioInstance.getPreloadedSize();
			completedsize += audiocompletedsize;
			if (audiocompletedsize < audio_preload_totalsize)
				ret = false;		// not done yet
		}
		if (totalsize == 0)
			this.progress = 1;		// indicate to C2 splash loader that it can finish now
		else
			this.progress = (completedsize / totalsize);
		return ret;
	};
	var isC2SplashDone = false;
	Runtime.prototype.go = function ()
	{
		if (!this.ctx && !this.glwrap)
			return;
		var ctx = this.ctx || this.overlay_ctx;
		if (this.overlay_canvas)
			this.positionOverlayCanvas();
		var curwidth = window.innerWidth;
		var curheight = window.innerHeight;
		if (this.lastWindowWidth !== curwidth || this.lastWindowHeight !== curheight)
		{
			this["setSize"](curwidth, curheight);
		}
		this.progress = 0;
		this.last_progress = -1;
		var self = this;
		if (this.areAllTexturesAndSoundsLoaded() && (this.loaderstyle !== 4 || isC2SplashDone))
		{
			this.go_loading_finished();
		}
		else
		{
			var ms_elapsed = Date.now() - this.start_time;
			if (ctx)
			{
				var overlay_width = this.width;
				var overlay_height = this.height;
				var dpr = this.devicePixelRatio;
				if (this.loaderstyle < 3 && (this.isCocoonJs || (ms_elapsed >= 500 && this.last_progress != this.progress)))
				{
					ctx.clearRect(0, 0, overlay_width, overlay_height);
					var mx = overlay_width / 2;
					var my = overlay_height / 2;
					var haslogo = (this.loaderstyle === 0 && this.loaderlogos.logo.complete);
					var hlw = 40 * dpr;
					var hlh = 0;
					var logowidth = 80 * dpr;
					var logoheight;
					if (haslogo)
					{
						var loaderLogoImage = this.loaderlogos.logo;
						logowidth = loaderLogoImage.width * dpr;
						logoheight = loaderLogoImage.height * dpr;
						hlw = logowidth / 2;
						hlh = logoheight / 2;
						ctx.drawImage(loaderLogoImage, cr.floor(mx - hlw), cr.floor(my - hlh), logowidth, logoheight);
					}
					if (this.loaderstyle <= 1)
					{
						my += hlh + (haslogo ? 12 * dpr : 0);
						mx -= hlw;
						mx = cr.floor(mx) + 0.5;
						my = cr.floor(my) + 0.5;
						ctx.fillStyle = anyImageHadError ? "red" : "DodgerBlue";
						ctx.fillRect(mx, my, Math.floor(logowidth * this.progress), 6 * dpr);
						ctx.strokeStyle = "black";
						ctx.strokeRect(mx, my, logowidth, 6 * dpr);
						ctx.strokeStyle = "white";
						ctx.strokeRect(mx - 1 * dpr, my - 1 * dpr, logowidth + 2 * dpr, 8 * dpr);
					}
					else if (this.loaderstyle === 2)
					{
						ctx.font = (this.isEjecta ? "12pt ArialMT" : "12pt Arial");
						ctx.fillStyle = anyImageHadError ? "#f00" : "#999";
						ctx.textBaseLine = "middle";
						var percent_text = Math.round(this.progress * 100) + "%";
						var text_dim = ctx.measureText ? ctx.measureText(percent_text) : null;
						var text_width = text_dim ? text_dim.width : 0;
						ctx.fillText(percent_text, mx - (text_width / 2), my);
					}
					this.last_progress = this.progress;
				}
				else if (this.loaderstyle === 4)
				{
					this.draw_c2_splash_loader(ctx);
					if (raf)
						raf(function() { self.go(); });
					else
						setTimeout(function() { self.go(); }, 16);
					return;
				}
			}
			setTimeout(function() { self.go(); }, (this.isCocoonJs ? 10 : 100));
		}
	};
	var splashStartTime = -1;
	var splashFadeInDuration = 300;
	var splashFadeOutDuration = 300;
	var splashAfterFadeOutWait = (typeof cr_is_preview === "undefined" ? 200 : 0);
	var splashIsFadeIn = true;
	var splashIsFadeOut = false;
	var splashFadeInFinish = 0;
	var splashFadeOutStart = 0;
	var splashMinDisplayTime = (typeof cr_is_preview === "undefined" ? 3000 : 0);
	var renderViaCanvas = null;
	var renderViaCtx = null;
	var splashFrameNumber = 0;
	function maybeCreateRenderViaCanvas(w, h)
	{
		if (!renderViaCanvas || renderViaCanvas.width !== w || renderViaCanvas.height !== h)
		{
			renderViaCanvas = document.createElement("canvas");
			renderViaCanvas.width = w;
			renderViaCanvas.height = h;
			renderViaCtx = renderViaCanvas.getContext("2d");
		}
	};
	function mipImage(arr, size)
	{
		if (size <= 128)
			return arr[3];
		else if (size <= 256)
			return arr[2];
		else if (size <= 512)
			return arr[1];
		else
			return arr[0];
	};
	Runtime.prototype.draw_c2_splash_loader = function(ctx)
	{
		if (isC2SplashDone)
			return;
		var w = Math.ceil(this.width);
		var h = Math.ceil(this.height);
		var dpr = this.devicePixelRatio;
		var logoimages = this.loaderlogos.logo;
		var poweredimages = this.loaderlogos.powered;
		var websiteimages = this.loaderlogos.website;
		for (var i = 0; i < 4; ++i)
		{
			if (!logoimages[i].complete || !poweredimages[i].complete || !websiteimages[i].complete)
				return;
		}
		if (splashFrameNumber === 0)
			splashStartTime = Date.now();
		var nowTime = Date.now();
		var isRenderingVia = false;
		var renderToCtx = ctx;
		var drawW, drawH;
		if (splashIsFadeIn || splashIsFadeOut)
		{
			ctx.clearRect(0, 0, w, h);
			maybeCreateRenderViaCanvas(w, h);
			renderToCtx = renderViaCtx;
			isRenderingVia = true;
			if (splashIsFadeIn && splashFrameNumber === 1)
				splashStartTime = Date.now();
		}
		else
		{
			ctx.globalAlpha = 1;
		}
		renderToCtx.fillStyle = "#333333";
		renderToCtx.fillRect(0, 0, w, h);
		if (this.cssHeight > 256)
		{
			drawW = cr.clamp(h * 0.22, 105, w * 0.6);
			drawH = drawW * 0.25;
			renderToCtx.drawImage(mipImage(poweredimages, drawW), w * 0.5 - drawW/2, h * 0.2 - drawH/2, drawW, drawH);
			drawW = Math.min(h * 0.395, w * 0.95);
			drawH = drawW;
			renderToCtx.drawImage(mipImage(logoimages, drawW), w * 0.5 - drawW/2, h * 0.485 - drawH/2, drawW, drawH);
			drawW = cr.clamp(h * 0.22, 105, w * 0.6);
			drawH = drawW * 0.25;
			renderToCtx.drawImage(mipImage(websiteimages, drawW), w * 0.5 - drawW/2, h * 0.868 - drawH/2, drawW, drawH);
			renderToCtx.fillStyle = "#3C3C3C";
			drawW = w;
			drawH = Math.max(h * 0.005, 2);
			renderToCtx.fillRect(0, h * 0.8 - drawH/2, drawW, drawH);
			renderToCtx.fillStyle = anyImageHadError ? "red" : "#E0FF65";
			drawW = w * this.progress;
			renderToCtx.fillRect(w * 0.5 - drawW/2, h * 0.8 - drawH/2, drawW, drawH);
		}
		else
		{
			drawW = h * 0.55;
			drawH = drawW;
			renderToCtx.drawImage(mipImage(logoimages, drawW), w * 0.5 - drawW/2, h * 0.45 - drawH/2, drawW, drawH);
			renderToCtx.fillStyle = "#3C3C3C";
			drawW = w;
			drawH = Math.max(h * 0.005, 2);
			renderToCtx.fillRect(0, h * 0.85 - drawH/2, drawW, drawH);
			renderToCtx.fillStyle = anyImageHadError ? "red" : "#E0FF65";
			drawW = w * this.progress;
			renderToCtx.fillRect(w * 0.5 - drawW/2, h * 0.85 - drawH/2, drawW, drawH);
		}
		if (isRenderingVia)
		{
			if (splashIsFadeIn)
			{
				if (splashFrameNumber === 0)
					ctx.globalAlpha = 0;
				else
					ctx.globalAlpha = Math.min((nowTime - splashStartTime) / splashFadeInDuration, 1);
			}
			else if (splashIsFadeOut)
			{
				ctx.globalAlpha = Math.max(1 - (nowTime - splashFadeOutStart) / splashFadeOutDuration, 0);
			}
			ctx.drawImage(renderViaCanvas, 0, 0, w, h);
		}
		if (splashIsFadeIn && nowTime - splashStartTime >= splashFadeInDuration && splashFrameNumber >= 2)
		{
			splashIsFadeIn = false;
			splashFadeInFinish = nowTime;
		}
		if (!splashIsFadeIn && nowTime - splashFadeInFinish >= splashMinDisplayTime && !splashIsFadeOut && this.progress >= 1)
		{
			splashIsFadeOut = true;
			splashFadeOutStart = nowTime;
		}
		if ((splashIsFadeOut && nowTime - splashFadeOutStart >= splashFadeOutDuration + splashAfterFadeOutWait) ||
			(typeof cr_is_preview !== "undefined" && this.progress >= 1 && Date.now() - splashStartTime < 500))
		{
			isC2SplashDone = true;
			splashIsFadeIn = false;
			splashIsFadeOut = false;
			renderViaCanvas = null;
			renderViaCtx = null;
			this.loaderlogos = null;
		}
		++splashFrameNumber;
	};
	Runtime.prototype.go_loading_finished = function ()
	{
		if (this.overlay_canvas)
		{
			this.canvas.parentNode.removeChild(this.overlay_canvas);
			this.overlay_ctx = null;
			this.overlay_canvas = null;
		}
		this.start_time = Date.now();
		this.last_fps_time = cr.performance_now();       // for counting framerate
		var i, len, t;
		if (this.uses_loader_layout)
		{
			for (i = 0, len = this.types_by_index.length; i < len; i++)
			{
				t = this.types_by_index[i];
				if (!t.is_family && !t.isOnLoaderLayout && t.plugin.is_world)
				{
					t.onCreate();
					cr.seal(t);
				}
			}
		}
		else
			this.isloading = false;
		for (i = 0, len = this.layouts_by_index.length; i < len; i++)
		{
			this.layouts_by_index[i].createGlobalNonWorlds();
		}
		if (this.fullscreen_mode >= 2)
		{
			var orig_aspect = this.original_width / this.original_height;
			var cur_aspect = this.width / this.height;
			if ((this.fullscreen_mode !== 2 && cur_aspect > orig_aspect) || (this.fullscreen_mode === 2 && cur_aspect < orig_aspect))
				this.aspect_scale = this.height / this.original_height;
			else
				this.aspect_scale = this.width / this.original_width;
		}
		if (this.first_layout)
			this.layouts[this.first_layout].startRunning();
		else
			this.layouts_by_index[0].startRunning();
;
		if (!this.uses_loader_layout)
		{
			this.loadingprogress = 1;
			this.trigger(cr.system_object.prototype.cnds.OnLoadFinished, null);
			if (window["C2_RegisterSW"])		// note not all platforms use SW
				window["C2_RegisterSW"]();
		}
		if (navigator["splashscreen"] && navigator["splashscreen"]["hide"])
			navigator["splashscreen"]["hide"]();
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			t = this.types_by_index[i];
			if (t.onAppBegin)
				t.onAppBegin();
		}
		if (document["hidden"] || document["webkitHidden"] || document["mozHidden"] || document["msHidden"])
		{
			window["cr_setSuspended"](true);		// stop rendering
		}
		else
		{
			this.tick(false);
		}
		if (this.isDirectCanvas)
			AppMobi["webview"]["execute"]("onGameReady();");
	};
	Runtime.prototype.tick = function (background_wake, timestamp, debug_step)
	{
		if (!this.running_layout)
			return;
		var nowtime = cr.performance_now();
		var logic_start = nowtime;
		if (!debug_step && this.isSuspended && !background_wake)
			return;
		if (!background_wake)
		{
			if (raf)
				this.raf_id = raf(this.tickFunc);
			else
			{
				this.timeout_id = setTimeout(this.tickFunc, this.isMobile ? 1 : 16);
			}
		}
		var raf_time = timestamp || nowtime;
		var fsmode = this.fullscreen_mode;
		var isfullscreen = (document["mozFullScreen"] || document["webkitIsFullScreen"] || document["fullScreen"] || !!document["msFullscreenElement"]) && !this.isCordova;
		if ((isfullscreen || this.isNodeFullscreen) && this.fullscreen_scaling > 0)
			fsmode = this.fullscreen_scaling;
		if (fsmode > 0)	// r222: experimentally enabling this workaround for all platforms
		{
			var curwidth = window.innerWidth;
			var curheight = window.innerHeight;
			if (this.lastWindowWidth !== curwidth || this.lastWindowHeight !== curheight)
			{
				this["setSize"](curwidth, curheight);
			}
		}
		if (!this.isDomFree)
		{
			if (isfullscreen)
			{
				if (!this.firstInFullscreen)
				{
					this.fullscreenOldMarginCss = jQuery(this.canvas).css("margin") || "0";
					this.firstInFullscreen = true;
				}
				if (!this.isChrome && !this.isNWjs)
				{
					jQuery(this.canvas).css({
						"margin-left": "" + Math.floor((screen.width - (this.width / this.devicePixelRatio)) / 2) + "px",
						"margin-top": "" + Math.floor((screen.height - (this.height / this.devicePixelRatio)) / 2) + "px"
					});
				}
			}
			else
			{
				if (this.firstInFullscreen)
				{
					if (!this.isChrome && !this.isNWjs)
					{
						jQuery(this.canvas).css("margin", this.fullscreenOldMarginCss);
					}
					this.fullscreenOldMarginCss = "";
					this.firstInFullscreen = false;
					if (this.fullscreen_mode === 0)
					{
						this["setSize"](Math.round(this.oldWidth / this.devicePixelRatio), Math.round(this.oldHeight / this.devicePixelRatio), true);
					}
				}
				else
				{
					this.oldWidth = this.width;
					this.oldHeight = this.height;
				}
			}
		}
		if (this.isloading)
		{
			var done = this.areAllTexturesAndSoundsLoaded();		// updates this.progress
			this.loadingprogress = this.progress;
			if (done)
			{
				this.isloading = false;
				this.progress = 1;
				this.trigger(cr.system_object.prototype.cnds.OnLoadFinished, null);
				if (window["C2_RegisterSW"])
					window["C2_RegisterSW"]();
			}
		}
		this.logic(raf_time);
		if ((this.redraw || this.isCocoonJs) && !this.is_WebGL_context_lost && !this.suspendDrawing && !background_wake)
		{
			this.redraw = false;
			if (this.glwrap)
				this.drawGL();
			else
				this.draw();
			if (this.snapshotCanvas)
			{
				if (this.canvas && this.canvas.toDataURL)
				{
					this.snapshotData = this.canvas.toDataURL(this.snapshotCanvas[0], this.snapshotCanvas[1]);
					if (window["cr_onSnapshot"])
						window["cr_onSnapshot"](this.snapshotData);
					this.trigger(cr.system_object.prototype.cnds.OnCanvasSnapshot, null);
				}
				this.snapshotCanvas = null;
			}
		}
		if (!this.hit_breakpoint)
		{
			this.tickcount++;
			this.execcount++;
			this.framecount++;
		}
		this.logictime += cr.performance_now() - logic_start;
	};
	Runtime.prototype.logic = function (cur_time)
	{
		var i, leni, j, lenj, k, lenk, type, inst, binst;
		if (cur_time - this.last_fps_time >= 1000)  // every 1 second
		{
			this.last_fps_time += 1000;
			if (cur_time - this.last_fps_time >= 1000)
				this.last_fps_time = cur_time;
			this.fps = this.framecount;
			this.framecount = 0;
			this.cpuutilisation = this.logictime;
			this.logictime = 0;
		}
		var wallDt = 0;
		if (this.last_tick_time !== 0)
		{
			var ms_diff = cur_time - this.last_tick_time;
			if (ms_diff < 0)
				ms_diff = 0;
			wallDt = ms_diff / 1000.0; // dt measured in seconds
			this.dt1 = wallDt;
			if (this.dt1 > 0.5)
				this.dt1 = 0;
			else if (this.dt1 > 1 / this.minimumFramerate)
				this.dt1 = 1 / this.minimumFramerate;
		}
		this.last_tick_time = cur_time;
        this.dt = this.dt1 * this.timescale;
        this.kahanTime.add(this.dt);
		this.wallTime.add(wallDt);		// prevent min/max framerate affecting wall clock
		var isfullscreen = (document["mozFullScreen"] || document["webkitIsFullScreen"] || document["fullScreen"] || !!document["msFullscreenElement"] || this.isNodeFullscreen) && !this.isCordova;
		if (this.fullscreen_mode >= 2 /* scale */ || (isfullscreen && this.fullscreen_scaling > 0))
		{
			var orig_aspect = this.original_width / this.original_height;
			var cur_aspect = this.width / this.height;
			var mode = this.fullscreen_mode;
			if (isfullscreen && this.fullscreen_scaling > 0)
				mode = this.fullscreen_scaling;
			if ((mode !== 2 && cur_aspect > orig_aspect) || (mode === 2 && cur_aspect < orig_aspect))
			{
				this.aspect_scale = this.height / this.original_height;
			}
			else
			{
				this.aspect_scale = this.width / this.original_width;
			}
			if (this.running_layout)
			{
				this.running_layout.scrollToX(this.running_layout.scrollX);
				this.running_layout.scrollToY(this.running_layout.scrollY);
			}
		}
		else
			this.aspect_scale = (this.isRetina ? this.devicePixelRatio : 1);
		this.ClearDeathRow();
		this.isInOnDestroy++;
		this.system.runWaits();		// prevent instance list changing
		this.isInOnDestroy--;
		this.ClearDeathRow();		// allow instance list changing
		this.isInOnDestroy++;
        var tickarr = this.objects_to_pretick.valuesRef();
        for (i = 0, leni = tickarr.length; i < leni; i++)
            tickarr[i].pretick();
		for (i = 0, leni = this.types_by_index.length; i < leni; i++)
		{
			type = this.types_by_index[i];
			if (type.is_family || (!type.behaviors.length && !type.families.length))
				continue;
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				inst = type.instances[j];
				for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
				{
					inst.behavior_insts[k].tick();
				}
			}
		}
		for (i = 0, leni = this.types_by_index.length; i < leni; i++)
		{
			type = this.types_by_index[i];
			if (type.is_family || (!type.behaviors.length && !type.families.length))
				continue;	// type doesn't have any behaviors
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				inst = type.instances[j];
				for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
				{
					binst = inst.behavior_insts[k];
					if (binst.posttick)
						binst.posttick();
				}
			}
		}
        tickarr = this.objects_to_tick.valuesRef();
        for (i = 0, leni = tickarr.length; i < leni; i++)
            tickarr[i].tick();
		this.isInOnDestroy--;		// end preventing instance lists from being changed
		this.handleSaveLoad();		// save/load now if queued
		i = 0;
		while (this.changelayout && i++ < 10)
		{
			this.doChangeLayout(this.changelayout);
		}
        for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
            this.eventsheets_by_index[i].hasRun = false;
		if (this.running_layout.event_sheet)
			this.running_layout.event_sheet.run();
		cr.clearArray(this.registered_collisions);
		this.layout_first_tick = false;
		this.isInOnDestroy++;		// prevent instance lists from being changed
		for (i = 0, leni = this.types_by_index.length; i < leni; i++)
		{
			type = this.types_by_index[i];
			if (type.is_family || (!type.behaviors.length && !type.families.length))
				continue;	// type doesn't have any behaviors
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				var inst = type.instances[j];
				for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
				{
					binst = inst.behavior_insts[k];
					if (binst.tick2)
						binst.tick2();
				}
			}
		}
        tickarr = this.objects_to_tick2.valuesRef();
        for (i = 0, leni = tickarr.length; i < leni; i++)
            tickarr[i].tick2();
		this.isInOnDestroy--;		// end preventing instance lists from being changed
	};
	Runtime.prototype.onWindowBlur = function ()
	{
		var i, leni, j, lenj, k, lenk, type, inst, binst;
		for (i = 0, leni = this.types_by_index.length; i < leni; i++)
		{
			type = this.types_by_index[i];
			if (type.is_family)
				continue;
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				inst = type.instances[j];
				if (inst.onWindowBlur)
					inst.onWindowBlur();
				if (!inst.behavior_insts)
					continue;	// single-globals don't have behavior_insts
				for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
				{
					binst = inst.behavior_insts[k];
					if (binst.onWindowBlur)
						binst.onWindowBlur();
				}
			}
		}
	};
	Runtime.prototype.doChangeLayout = function (changeToLayout)
	{
		var prev_layout = this.running_layout;
		this.running_layout.stopRunning();
		var i, len, j, lenj, k, lenk, type, inst, binst;
		if (this.glwrap)
		{
			for (i = 0, len = this.types_by_index.length; i < len; i++)
			{
				type = this.types_by_index[i];
				if (type.is_family)
					continue;
				if (type.unloadTextures && (!type.global || type.instances.length === 0) && changeToLayout.initial_types.indexOf(type) === -1)
				{
					type.unloadTextures();
				}
			}
		}
		if (prev_layout == changeToLayout)
			cr.clearArray(this.system.waits);
		cr.clearArray(this.registered_collisions);
		this.runLayoutChangeMethods(true);
		changeToLayout.startRunning();
		this.runLayoutChangeMethods(false);
		this.redraw = true;
		this.layout_first_tick = true;
		this.ClearDeathRow();
	};
	Runtime.prototype.runLayoutChangeMethods = function (isBeforeChange)
	{
		var i, len, beh, type, j, lenj, inst, k, lenk, binst;
		for (i = 0, len = this.behaviors.length; i < len; i++)
		{
			beh = this.behaviors[i];
			if (isBeforeChange)
			{
				if (beh.onBeforeLayoutChange)
					beh.onBeforeLayoutChange();
			}
			else
			{
				if (beh.onLayoutChange)
					beh.onLayoutChange();
			}
		}
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			type = this.types_by_index[i];
			if (!type.global && !type.plugin.singleglobal)
				continue;
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				inst = type.instances[j];
				if (isBeforeChange)
				{
					if (inst.onBeforeLayoutChange)
						inst.onBeforeLayoutChange();
				}
				else
				{
					if (inst.onLayoutChange)
						inst.onLayoutChange();
				}
				if (inst.behavior_insts)
				{
					for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
					{
						binst = inst.behavior_insts[k];
						if (isBeforeChange)
						{
							if (binst.onBeforeLayoutChange)
								binst.onBeforeLayoutChange();
						}
						else
						{
							if (binst.onLayoutChange)
								binst.onLayoutChange();
						}
					}
				}
			}
		}
	};
	Runtime.prototype.pretickMe = function (inst)
    {
        this.objects_to_pretick.add(inst);
    };
	Runtime.prototype.unpretickMe = function (inst)
	{
		this.objects_to_pretick.remove(inst);
	};
    Runtime.prototype.tickMe = function (inst)
    {
        this.objects_to_tick.add(inst);
    };
	Runtime.prototype.untickMe = function (inst)
	{
		this.objects_to_tick.remove(inst);
	};
	Runtime.prototype.tick2Me = function (inst)
    {
        this.objects_to_tick2.add(inst);
    };
	Runtime.prototype.untick2Me = function (inst)
	{
		this.objects_to_tick2.remove(inst);
	};
    Runtime.prototype.getDt = function (inst)
    {
        if (!inst || inst.my_timescale === -1.0)
            return this.dt;
        return this.dt1 * inst.my_timescale;
    };
	Runtime.prototype.draw = function ()
	{
		this.running_layout.draw(this.ctx);
		if (this.isDirectCanvas)
			this.ctx["present"]();
	};
	Runtime.prototype.drawGL = function ()
	{
		if (this.enableFrontToBack)
		{
			this.earlyz_index = 1;		// start from front, 1-based to avoid exactly equalling near plane Z value
			this.running_layout.drawGL_earlyZPass(this.glwrap);
		}
		this.running_layout.drawGL(this.glwrap);
		this.glwrap.present();
	};
	Runtime.prototype.addDestroyCallback = function (f)
	{
		if (f)
			this.destroycallbacks.push(f);
	};
	Runtime.prototype.removeDestroyCallback = function (f)
	{
		cr.arrayFindRemove(this.destroycallbacks, f);
	};
	Runtime.prototype.getObjectByUID = function (uid_)
	{
;
		var uidstr = uid_.toString();
		if (this.objectsByUid.hasOwnProperty(uidstr))
			return this.objectsByUid[uidstr];
		else
			return null;
	};
	var objectset_cache = [];
	function alloc_objectset()
	{
		if (objectset_cache.length)
			return objectset_cache.pop();
		else
			return new cr.ObjectSet();
	};
	function free_objectset(s)
	{
		s.clear();
		objectset_cache.push(s);
	};
	Runtime.prototype.DestroyInstance = function (inst)
	{
		var i, len;
		var type = inst.type;
		var typename = type.name;
		var has_typename = this.deathRow.hasOwnProperty(typename);
		var obj_set = null;
		if (has_typename)
		{
			obj_set = this.deathRow[typename];
			if (obj_set.contains(inst))
				return;		// already had DestroyInstance called
		}
		else
		{
			obj_set = alloc_objectset();
			this.deathRow[typename] = obj_set;
		}
		obj_set.add(inst);
		this.hasPendingInstances = true;
		if (inst.is_contained)
		{
			for (i = 0, len = inst.siblings.length; i < len; i++)
			{
				this.DestroyInstance(inst.siblings[i]);
			}
		}
		if (this.isInClearDeathRow)
			obj_set.values_cache.push(inst);
		if (!this.isEndingLayout)
		{
			this.isInOnDestroy++;		// support recursion
			this.trigger(Object.getPrototypeOf(inst.type.plugin).cnds.OnDestroyed, inst);
			this.isInOnDestroy--;
		}
	};
	Runtime.prototype.ClearDeathRow = function ()
	{
		if (!this.hasPendingInstances)
			return;
		var inst, type, instances;
		var i, j, leni, lenj, obj_set;
		this.isInClearDeathRow = true;
		for (i = 0, leni = this.createRow.length; i < leni; ++i)
		{
			inst = this.createRow[i];
			type = inst.type;
			type.instances.push(inst);
			for (j = 0, lenj = type.families.length; j < lenj; ++j)
			{
				type.families[j].instances.push(inst);
				type.families[j].stale_iids = true;
			}
		}
		cr.clearArray(this.createRow);
		this.IterateDeathRow();		// moved to separate function so for-in performance doesn't hobble entire function
		cr.wipe(this.deathRow);		// all objectsets have already been recycled
		this.isInClearDeathRow = false;
		this.hasPendingInstances = false;
	};
	Runtime.prototype.IterateDeathRow = function ()
	{
		for (var p in this.deathRow)
		{
			if (this.deathRow.hasOwnProperty(p))
			{
				this.ClearDeathRowForType(this.deathRow[p]);
			}
		}
	};
	Runtime.prototype.ClearDeathRowForType = function (obj_set)
	{
		var arr = obj_set.valuesRef();			// get array of items from set
;
		var type = arr[0].type;
;
;
		var i, len, j, lenj, w, f, layer_instances, inst;
		cr.arrayRemoveAllFromObjectSet(type.instances, obj_set);
		type.stale_iids = true;
		if (type.instances.length === 0)
			type.any_instance_parallaxed = false;
		for (i = 0, len = type.families.length; i < len; ++i)
		{
			f = type.families[i];
			cr.arrayRemoveAllFromObjectSet(f.instances, obj_set);
			f.stale_iids = true;
		}
		for (i = 0, len = this.system.waits.length; i < len; ++i)
		{
			w = this.system.waits[i];
			if (w.sols.hasOwnProperty(type.index))
				cr.arrayRemoveAllFromObjectSet(w.sols[type.index].insts, obj_set);
			if (!type.is_family)
			{
				for (j = 0, lenj = type.families.length; j < lenj; ++j)
				{
					f = type.families[j];
					if (w.sols.hasOwnProperty(f.index))
						cr.arrayRemoveAllFromObjectSet(w.sols[f.index].insts, obj_set);
				}
			}
		}
		var first_layer = arr[0].layer;
		if (first_layer)
		{
			if (first_layer.useRenderCells)
			{
				layer_instances = first_layer.instances;
				for (i = 0, len = layer_instances.length; i < len; ++i)
				{
					inst = layer_instances[i];
					if (!obj_set.contains(inst))
						continue;		// not destroying this instance
					inst.update_bbox();
					first_layer.render_grid.update(inst, inst.rendercells, null);
					inst.rendercells.set(0, 0, -1, -1);
				}
			}
			cr.arrayRemoveAllFromObjectSet(first_layer.instances, obj_set);
			first_layer.setZIndicesStaleFrom(0);
		}
		for (i = 0; i < arr.length; ++i)		// check array length every time in case it changes
		{
			this.ClearDeathRowForSingleInstance(arr[i], type);
		}
		free_objectset(obj_set);
		this.redraw = true;
	};
	Runtime.prototype.ClearDeathRowForSingleInstance = function (inst, type)
	{
		var i, len, binst;
		for (i = 0, len = this.destroycallbacks.length; i < len; ++i)
			this.destroycallbacks[i](inst);
		if (inst.collcells)
		{
			type.collision_grid.update(inst, inst.collcells, null);
		}
		var layer = inst.layer;
		if (layer)
		{
			layer.removeFromInstanceList(inst, true);		// remove from both instance list and render grid
		}
		if (inst.behavior_insts)
		{
			for (i = 0, len = inst.behavior_insts.length; i < len; ++i)
			{
				binst = inst.behavior_insts[i];
				if (binst.onDestroy)
					binst.onDestroy();
				binst.behavior.my_instances.remove(inst);
			}
		}
		this.objects_to_pretick.remove(inst);
		this.objects_to_tick.remove(inst);
		this.objects_to_tick2.remove(inst);
		if (inst.onDestroy)
			inst.onDestroy();
		if (this.objectsByUid.hasOwnProperty(inst.uid.toString()))
			delete this.objectsByUid[inst.uid.toString()];
		this.objectcount--;
		if (type.deadCache.length < 100)
			type.deadCache.push(inst);
	};
	Runtime.prototype.createInstance = function (type, layer, sx, sy)
	{
		if (type.is_family)
		{
			var i = cr.floor(Math.random() * type.members.length);
			return this.createInstance(type.members[i], layer, sx, sy);
		}
		if (!type.default_instance)
		{
			return null;
		}
		return this.createInstanceFromInit(type.default_instance, layer, false, sx, sy, false);
	};
	var all_behaviors = [];
	Runtime.prototype.createInstanceFromInit = function (initial_inst, layer, is_startup_instance, sx, sy, skip_siblings)
	{
		var i, len, j, lenj, p, effect_fallback, x, y;
		if (!initial_inst)
			return null;
		var type = this.types_by_index[initial_inst[1]];
;
;
		var is_world = type.plugin.is_world;
;
		if (this.isloading && is_world && !type.isOnLoaderLayout)
			return null;
		if (is_world && !this.glwrap && initial_inst[0][11] === 11)
			return null;
		var original_layer = layer;
		if (!is_world)
			layer = null;
		var inst;
		if (type.deadCache.length)
		{
			inst = type.deadCache.pop();
			inst.recycled = true;
			type.plugin.Instance.call(inst, type);
		}
		else
		{
			inst = new type.plugin.Instance(type);
			inst.recycled = false;
		}
		if (is_startup_instance && !skip_siblings && !this.objectsByUid.hasOwnProperty(initial_inst[2].toString()))
			inst.uid = initial_inst[2];
		else
			inst.uid = this.next_uid++;
		this.objectsByUid[inst.uid.toString()] = inst;
		inst.puid = this.next_puid++;
		inst.iid = type.instances.length;
		for (i = 0, len = this.createRow.length; i < len; ++i)
		{
			if (this.createRow[i].type === type)
				inst.iid++;
		}
		inst.get_iid = cr.inst_get_iid;
		inst.toString = cr.inst_toString;
		var initial_vars = initial_inst[3];
		if (inst.recycled)
		{
			cr.wipe(inst.extra);
		}
		else
		{
			inst.extra = {};
			if (typeof cr_is_preview !== "undefined")
			{
				inst.instance_var_names = [];
				inst.instance_var_names.length = initial_vars.length;
				for (i = 0, len = initial_vars.length; i < len; i++)
					inst.instance_var_names[i] = initial_vars[i][1];
			}
			inst.instance_vars = [];
			inst.instance_vars.length = initial_vars.length;
		}
		for (i = 0, len = initial_vars.length; i < len; i++)
			inst.instance_vars[i] = initial_vars[i][0];
		if (is_world)
		{
			var wm = initial_inst[0];
;
			inst.x = cr.is_undefined(sx) ? wm[0] : sx;
			inst.y = cr.is_undefined(sy) ? wm[1] : sy;
			inst.z = wm[2];
			inst.width = wm[3];
			inst.height = wm[4];
			inst.depth = wm[5];
			inst.angle = wm[6];
			inst.opacity = wm[7];
			inst.hotspotX = wm[8];
			inst.hotspotY = wm[9];
			inst.blend_mode = wm[10];
			effect_fallback = wm[11];
			if (!this.glwrap && type.effect_types.length)	// no WebGL renderer and shaders used
				inst.blend_mode = effect_fallback;			// use fallback blend mode - destroy mode was handled above
			inst.compositeOp = cr.effectToCompositeOp(inst.blend_mode);
			if (this.gl)
				cr.setGLBlend(inst, inst.blend_mode, this.gl);
			if (inst.recycled)
			{
				for (i = 0, len = wm[12].length; i < len; i++)
				{
					for (j = 0, lenj = wm[12][i].length; j < lenj; j++)
						inst.effect_params[i][j] = wm[12][i][j];
				}
				inst.bbox.set(0, 0, 0, 0);
				inst.collcells.set(0, 0, -1, -1);
				inst.rendercells.set(0, 0, -1, -1);
				inst.bquad.set_from_rect(inst.bbox);
				cr.clearArray(inst.bbox_changed_callbacks);
			}
			else
			{
				inst.effect_params = wm[12].slice(0);
				for (i = 0, len = inst.effect_params.length; i < len; i++)
					inst.effect_params[i] = wm[12][i].slice(0);
				inst.active_effect_types = [];
				inst.active_effect_flags = [];
				inst.active_effect_flags.length = type.effect_types.length;
				inst.bbox = new cr.rect(0, 0, 0, 0);
				inst.collcells = new cr.rect(0, 0, -1, -1);
				inst.rendercells = new cr.rect(0, 0, -1, -1);
				inst.bquad = new cr.quad();
				inst.bbox_changed_callbacks = [];
				inst.set_bbox_changed = cr.set_bbox_changed;
				inst.add_bbox_changed_callback = cr.add_bbox_changed_callback;
				inst.contains_pt = cr.inst_contains_pt;
				inst.update_bbox = cr.update_bbox;
				inst.update_render_cell = cr.update_render_cell;
				inst.update_collision_cell = cr.update_collision_cell;
				inst.get_zindex = cr.inst_get_zindex;
			}
			inst.tilemap_exists = false;
			inst.tilemap_width = 0;
			inst.tilemap_height = 0;
			inst.tilemap_data = null;
			if (wm.length === 14)
			{
				inst.tilemap_exists = true;
				inst.tilemap_width = wm[13][0];
				inst.tilemap_height = wm[13][1];
				inst.tilemap_data = wm[13][2];
			}
			for (i = 0, len = type.effect_types.length; i < len; i++)
				inst.active_effect_flags[i] = true;
			inst.shaders_preserve_opaqueness = true;
			inst.updateActiveEffects = cr.inst_updateActiveEffects;
			inst.updateActiveEffects();
			inst.uses_shaders = !!inst.active_effect_types.length;
			inst.bbox_changed = true;
			inst.cell_changed = true;
			type.any_cell_changed = true;
			inst.visible = true;
            inst.my_timescale = -1.0;
			inst.layer = layer;
			inst.zindex = layer.instances.length;	// will be placed at top of current layer
			inst.earlyz_index = 0;
			if (typeof inst.collision_poly === "undefined")
				inst.collision_poly = null;
			inst.collisionsEnabled = true;
			this.redraw = true;
		}
		var initial_props, binst;
		cr.clearArray(all_behaviors);
		for (i = 0, len = type.families.length; i < len; i++)
		{
			all_behaviors.push.apply(all_behaviors, type.families[i].behaviors);
		}
		all_behaviors.push.apply(all_behaviors, type.behaviors);
		if (inst.recycled)
		{
			for (i = 0, len = all_behaviors.length; i < len; i++)
			{
				var btype = all_behaviors[i];
				binst = inst.behavior_insts[i];
				binst.recycled = true;
				btype.behavior.Instance.call(binst, btype, inst);
				initial_props = initial_inst[4][i];
				for (j = 0, lenj = initial_props.length; j < lenj; j++)
					binst.properties[j] = initial_props[j];
				binst.onCreate();
				btype.behavior.my_instances.add(inst);
			}
		}
		else
		{
			inst.behavior_insts = [];
			for (i = 0, len = all_behaviors.length; i < len; i++)
			{
				var btype = all_behaviors[i];
				var binst = new btype.behavior.Instance(btype, inst);
				binst.recycled = false;
				binst.properties = initial_inst[4][i].slice(0);
				binst.onCreate();
				cr.seal(binst);
				inst.behavior_insts.push(binst);
				btype.behavior.my_instances.add(inst);
			}
		}
		initial_props = initial_inst[5];
		if (inst.recycled)
		{
			for (i = 0, len = initial_props.length; i < len; i++)
				inst.properties[i] = initial_props[i];
		}
		else
			inst.properties = initial_props.slice(0);
		this.createRow.push(inst);
		this.hasPendingInstances = true;
		if (layer)
		{
;
			layer.appendToInstanceList(inst, true);
			if (layer.parallaxX !== 1 || layer.parallaxY !== 1)
				type.any_instance_parallaxed = true;
		}
		this.objectcount++;
		if (type.is_contained)
		{
			inst.is_contained = true;
			if (inst.recycled)
				cr.clearArray(inst.siblings);
			else
				inst.siblings = [];			// note: should not include self in siblings
			if (!is_startup_instance && !skip_siblings)	// layout links initial instances
			{
				for (i = 0, len = type.container.length; i < len; i++)
				{
					if (type.container[i] === type)
						continue;
					if (!type.container[i].default_instance)
					{
						return null;
					}
					inst.siblings.push(this.createInstanceFromInit(type.container[i].default_instance, original_layer, false, is_world ? inst.x : sx, is_world ? inst.y : sy, true));
				}
				for (i = 0, len = inst.siblings.length; i < len; i++)
				{
					inst.siblings[i].siblings.push(inst);
					for (j = 0; j < len; j++)
					{
						if (i !== j)
							inst.siblings[i].siblings.push(inst.siblings[j]);
					}
				}
			}
		}
		else
		{
			inst.is_contained = false;
			inst.siblings = null;
		}
		inst.onCreate();
		if (!inst.recycled)
			cr.seal(inst);
		for (i = 0, len = inst.behavior_insts.length; i < len; i++)
		{
			if (inst.behavior_insts[i].postCreate)
				inst.behavior_insts[i].postCreate();
		}
		return inst;
	};
	Runtime.prototype.getLayerByName = function (layer_name)
	{
		var i, len;
		for (i = 0, len = this.running_layout.layers.length; i < len; i++)
		{
			var layer = this.running_layout.layers[i];
			if (cr.equals_nocase(layer.name, layer_name))
				return layer;
		}
		return null;
	};
	Runtime.prototype.getLayerByNumber = function (index)
	{
		index = cr.floor(index);
		if (index < 0)
			index = 0;
		if (index >= this.running_layout.layers.length)
			index = this.running_layout.layers.length - 1;
		return this.running_layout.layers[index];
	};
	Runtime.prototype.getLayer = function (l)
	{
		if (cr.is_number(l))
			return this.getLayerByNumber(l);
		else
			return this.getLayerByName(l.toString());
	};
	Runtime.prototype.clearSol = function (solModifiers)
	{
		var i, len;
		for (i = 0, len = solModifiers.length; i < len; i++)
		{
			solModifiers[i].getCurrentSol().select_all = true;
		}
	};
	Runtime.prototype.pushCleanSol = function (solModifiers)
	{
		var i, len;
		for (i = 0, len = solModifiers.length; i < len; i++)
		{
			solModifiers[i].pushCleanSol();
		}
	};
	Runtime.prototype.pushCopySol = function (solModifiers)
	{
		var i, len;
		for (i = 0, len = solModifiers.length; i < len; i++)
		{
			solModifiers[i].pushCopySol();
		}
	};
	Runtime.prototype.popSol = function (solModifiers)
	{
		var i, len;
		for (i = 0, len = solModifiers.length; i < len; i++)
		{
			solModifiers[i].popSol();
		}
	};
	Runtime.prototype.updateAllCells = function (type)
	{
		if (!type.any_cell_changed)
			return;		// all instances must already be up-to-date
		var i, len, instances = type.instances;
		for (i = 0, len = instances.length; i < len; ++i)
		{
			instances[i].update_collision_cell();
		}
		var createRow = this.createRow;
		for (i = 0, len = createRow.length; i < len; ++i)
		{
			if (createRow[i].type === type)
				createRow[i].update_collision_cell();
		}
		type.any_cell_changed = false;
	};
	Runtime.prototype.getCollisionCandidates = function (layer, rtype, bbox, candidates)
	{
		var i, len, t;
		var is_parallaxed = (layer ? (layer.parallaxX !== 1 || layer.parallaxY !== 1) : false);
		if (rtype.is_family)
		{
			for (i = 0, len = rtype.members.length; i < len; ++i)
			{
				t = rtype.members[i];
				if (is_parallaxed || t.any_instance_parallaxed)
				{
					cr.appendArray(candidates, t.instances);
				}
				else
				{
					this.updateAllCells(t);
					t.collision_grid.queryRange(bbox, candidates);
				}
			}
		}
		else
		{
			if (is_parallaxed || rtype.any_instance_parallaxed)
			{
				cr.appendArray(candidates, rtype.instances);
			}
			else
			{
				this.updateAllCells(rtype);
				rtype.collision_grid.queryRange(bbox, candidates);
			}
		}
	};
	Runtime.prototype.getTypesCollisionCandidates = function (layer, types, bbox, candidates)
	{
		var i, len;
		for (i = 0, len = types.length; i < len; ++i)
		{
			this.getCollisionCandidates(layer, types[i], bbox, candidates);
		}
	};
	Runtime.prototype.getSolidCollisionCandidates = function (layer, bbox, candidates)
	{
		var solid = this.getSolidBehavior();
		if (!solid)
			return null;
		this.getTypesCollisionCandidates(layer, solid.my_types, bbox, candidates);
	};
	Runtime.prototype.getJumpthruCollisionCandidates = function (layer, bbox, candidates)
	{
		var jumpthru = this.getJumpthruBehavior();
		if (!jumpthru)
			return null;
		this.getTypesCollisionCandidates(layer, jumpthru.my_types, bbox, candidates);
	};
	Runtime.prototype.testAndSelectCanvasPointOverlap = function (type, ptx, pty, inverted)
	{
		var sol = type.getCurrentSol();
		var i, j, inst, len;
		var orblock = this.getCurrentEventStack().current_event.orblock;
		var lx, ly, arr;
		if (sol.select_all)
		{
			if (!inverted)
			{
				sol.select_all = false;
				cr.clearArray(sol.instances);   // clear contents
			}
			for (i = 0, len = type.instances.length; i < len; i++)
			{
				inst = type.instances[i];
				inst.update_bbox();
				lx = inst.layer.canvasToLayer(ptx, pty, true);
				ly = inst.layer.canvasToLayer(ptx, pty, false);
				if (inst.contains_pt(lx, ly))
				{
					if (inverted)
						return false;
					else
						sol.instances.push(inst);
				}
				else if (orblock)
					sol.else_instances.push(inst);
			}
		}
		else
		{
			j = 0;
			arr = (orblock ? sol.else_instances : sol.instances);
			for (i = 0, len = arr.length; i < len; i++)
			{
				inst = arr[i];
				inst.update_bbox();
				lx = inst.layer.canvasToLayer(ptx, pty, true);
				ly = inst.layer.canvasToLayer(ptx, pty, false);
				if (inst.contains_pt(lx, ly))
				{
					if (inverted)
						return false;
					else if (orblock)
						sol.instances.push(inst);
					else
					{
						sol.instances[j] = sol.instances[i];
						j++;
					}
				}
			}
			if (!inverted)
				arr.length = j;
		}
		type.applySolToContainer();
		if (inverted)
			return true;		// did not find anything overlapping
		else
			return sol.hasObjects();
	};
	Runtime.prototype.testOverlap = function (a, b)
	{
		if (!a || !b || a === b || !a.collisionsEnabled || !b.collisionsEnabled)
			return false;
		a.update_bbox();
		b.update_bbox();
		var layera = a.layer;
		var layerb = b.layer;
		var different_layers = (layera !== layerb && (layera.parallaxX !== layerb.parallaxX || layerb.parallaxY !== layerb.parallaxY || layera.scale !== layerb.scale || layera.angle !== layerb.angle || layera.zoomRate !== layerb.zoomRate));
		var i, len, i2, i21, x, y, haspolya, haspolyb, polya, polyb;
		if (!different_layers)	// same layers: easy check
		{
			if (!a.bbox.intersects_rect(b.bbox))
				return false;
			if (!a.bquad.intersects_quad(b.bquad))
				return false;
			if (a.tilemap_exists && b.tilemap_exists)
				return false;
			if (a.tilemap_exists)
				return this.testTilemapOverlap(a, b);
			if (b.tilemap_exists)
				return this.testTilemapOverlap(b, a);
			haspolya = (a.collision_poly && !a.collision_poly.is_empty());
			haspolyb = (b.collision_poly && !b.collision_poly.is_empty());
			if (!haspolya && !haspolyb)
				return true;
			if (haspolya)
			{
				a.collision_poly.cache_poly(a.width, a.height, a.angle);
				polya = a.collision_poly;
			}
			else
			{
				this.temp_poly.set_from_quad(a.bquad, a.x, a.y, a.width, a.height);
				polya = this.temp_poly;
			}
			if (haspolyb)
			{
				b.collision_poly.cache_poly(b.width, b.height, b.angle);
				polyb = b.collision_poly;
			}
			else
			{
				this.temp_poly.set_from_quad(b.bquad, b.x, b.y, b.width, b.height);
				polyb = this.temp_poly;
			}
			return polya.intersects_poly(polyb, b.x - a.x, b.y - a.y);
		}
		else	// different layers: need to do full translated check
		{
			haspolya = (a.collision_poly && !a.collision_poly.is_empty());
			haspolyb = (b.collision_poly && !b.collision_poly.is_empty());
			if (haspolya)
			{
				a.collision_poly.cache_poly(a.width, a.height, a.angle);
				this.temp_poly.set_from_poly(a.collision_poly);
			}
			else
			{
				this.temp_poly.set_from_quad(a.bquad, a.x, a.y, a.width, a.height);
			}
			polya = this.temp_poly;
			if (haspolyb)
			{
				b.collision_poly.cache_poly(b.width, b.height, b.angle);
				this.temp_poly2.set_from_poly(b.collision_poly);
			}
			else
			{
				this.temp_poly2.set_from_quad(b.bquad, b.x, b.y, b.width, b.height);
			}
			polyb = this.temp_poly2;
			for (i = 0, len = polya.pts_count; i < len; i++)
			{
				i2 = i * 2;
				i21 = i2 + 1;
				x = polya.pts_cache[i2];
				y = polya.pts_cache[i21];
				polya.pts_cache[i2] = layera.layerToCanvas(x + a.x, y + a.y, true);
				polya.pts_cache[i21] = layera.layerToCanvas(x + a.x, y + a.y, false);
			}
			polya.update_bbox();
			for (i = 0, len = polyb.pts_count; i < len; i++)
			{
				i2 = i * 2;
				i21 = i2 + 1;
				x = polyb.pts_cache[i2];
				y = polyb.pts_cache[i21];
				polyb.pts_cache[i2] = layerb.layerToCanvas(x + b.x, y + b.y, true);
				polyb.pts_cache[i21] = layerb.layerToCanvas(x + b.x, y + b.y, false);
			}
			polyb.update_bbox();
			return polya.intersects_poly(polyb, 0, 0);
		}
	};
	var tmpQuad = new cr.quad();
	var tmpRect = new cr.rect(0, 0, 0, 0);
	var collrect_candidates = [];
	Runtime.prototype.testTilemapOverlap = function (tm, a)
	{
		var i, len, c, rc;
		var bbox = a.bbox;
		var tmx = tm.x;
		var tmy = tm.y;
		tm.getCollisionRectCandidates(bbox, collrect_candidates);
		var collrects = collrect_candidates;
		var haspolya = (a.collision_poly && !a.collision_poly.is_empty());
		for (i = 0, len = collrects.length; i < len; ++i)
		{
			c = collrects[i];
			rc = c.rc;
			if (bbox.intersects_rect_off(rc, tmx, tmy))
			{
				tmpQuad.set_from_rect(rc);
				tmpQuad.offset(tmx, tmy);
				if (tmpQuad.intersects_quad(a.bquad))
				{
					if (haspolya)
					{
						a.collision_poly.cache_poly(a.width, a.height, a.angle);
						if (c.poly)
						{
							if (c.poly.intersects_poly(a.collision_poly, a.x - (tmx + rc.left), a.y - (tmy + rc.top)))
							{
								cr.clearArray(collrect_candidates);
								return true;
							}
						}
						else
						{
							this.temp_poly.set_from_quad(tmpQuad, 0, 0, rc.right - rc.left, rc.bottom - rc.top);
							if (this.temp_poly.intersects_poly(a.collision_poly, a.x, a.y))
							{
								cr.clearArray(collrect_candidates);
								return true;
							}
						}
					}
					else
					{
						if (c.poly)
						{
							this.temp_poly.set_from_quad(a.bquad, 0, 0, a.width, a.height);
							if (c.poly.intersects_poly(this.temp_poly, -(tmx + rc.left), -(tmy + rc.top)))
							{
								cr.clearArray(collrect_candidates);
								return true;
							}
						}
						else
						{
							cr.clearArray(collrect_candidates);
							return true;
						}
					}
				}
			}
		}
		cr.clearArray(collrect_candidates);
		return false;
	};
	Runtime.prototype.testRectOverlap = function (r, b)
	{
		if (!b || !b.collisionsEnabled)
			return false;
		b.update_bbox();
		var layerb = b.layer;
		var haspolyb, polyb;
		if (!b.bbox.intersects_rect(r))
			return false;
		if (b.tilemap_exists)
		{
			b.getCollisionRectCandidates(r, collrect_candidates);
			var collrects = collrect_candidates;
			var i, len, c, tilerc;
			var tmx = b.x;
			var tmy = b.y;
			for (i = 0, len = collrects.length; i < len; ++i)
			{
				c = collrects[i];
				tilerc = c.rc;
				if (r.intersects_rect_off(tilerc, tmx, tmy))
				{
					if (c.poly)
					{
						this.temp_poly.set_from_rect(r, 0, 0);
						if (c.poly.intersects_poly(this.temp_poly, -(tmx + tilerc.left), -(tmy + tilerc.top)))
						{
							cr.clearArray(collrect_candidates);
							return true;
						}
					}
					else
					{
						cr.clearArray(collrect_candidates);
						return true;
					}
				}
			}
			cr.clearArray(collrect_candidates);
			return false;
		}
		else
		{
			tmpQuad.set_from_rect(r);
			if (!b.bquad.intersects_quad(tmpQuad))
				return false;
			haspolyb = (b.collision_poly && !b.collision_poly.is_empty());
			if (!haspolyb)
				return true;
			b.collision_poly.cache_poly(b.width, b.height, b.angle);
			tmpQuad.offset(-r.left, -r.top);
			this.temp_poly.set_from_quad(tmpQuad, 0, 0, 1, 1);
			return b.collision_poly.intersects_poly(this.temp_poly, r.left - b.x, r.top - b.y);
		}
	};
	Runtime.prototype.testSegmentOverlap = function (x1, y1, x2, y2, b)
	{
		if (!b || !b.collisionsEnabled)
			return false;
		b.update_bbox();
		var layerb = b.layer;
		var haspolyb, polyb;
		tmpRect.set(cr.min(x1, x2), cr.min(y1, y2), cr.max(x1, x2), cr.max(y1, y2));
		if (!b.bbox.intersects_rect(tmpRect))
			return false;
		if (b.tilemap_exists)
		{
			b.getCollisionRectCandidates(tmpRect, collrect_candidates);
			var collrects = collrect_candidates;
			var i, len, c, tilerc;
			var tmx = b.x;
			var tmy = b.y;
			for (i = 0, len = collrects.length; i < len; ++i)
			{
				c = collrects[i];
				tilerc = c.rc;
				if (tmpRect.intersects_rect_off(tilerc, tmx, tmy))
				{
					tmpQuad.set_from_rect(tilerc);
					tmpQuad.offset(tmx, tmy);
					if (tmpQuad.intersects_segment(x1, y1, x2, y2))
					{
						if (c.poly)
						{
							if (c.poly.intersects_segment(tmx + tilerc.left, tmy + tilerc.top, x1, y1, x2, y2))
							{
								cr.clearArray(collrect_candidates);
								return true;
							}
						}
						else
						{
							cr.clearArray(collrect_candidates);
							return true;
						}
					}
				}
			}
			cr.clearArray(collrect_candidates);
			return false;
		}
		else
		{
			if (!b.bquad.intersects_segment(x1, y1, x2, y2))
				return false;
			haspolyb = (b.collision_poly && !b.collision_poly.is_empty());
			if (!haspolyb)
				return true;
			b.collision_poly.cache_poly(b.width, b.height, b.angle);
			return b.collision_poly.intersects_segment(b.x, b.y, x1, y1, x2, y2);
		}
	};
	Runtime.prototype.typeHasBehavior = function (t, b)
	{
		if (!b)
			return false;
		var i, len, j, lenj, f;
		for (i = 0, len = t.behaviors.length; i < len; i++)
		{
			if (t.behaviors[i].behavior instanceof b)
				return true;
		}
		if (!t.is_family)
		{
			for (i = 0, len = t.families.length; i < len; i++)
			{
				f = t.families[i];
				for (j = 0, lenj = f.behaviors.length; j < lenj; j++)
				{
					if (f.behaviors[j].behavior instanceof b)
						return true;
				}
			}
		}
		return false;
	};
	Runtime.prototype.typeHasNoSaveBehavior = function (t)
	{
		return this.typeHasBehavior(t, cr.behaviors.NoSave);
	};
	Runtime.prototype.typeHasPersistBehavior = function (t)
	{
		return this.typeHasBehavior(t, cr.behaviors.Persist);
	};
	Runtime.prototype.getSolidBehavior = function ()
	{
		return this.solidBehavior;
	};
	Runtime.prototype.getJumpthruBehavior = function ()
	{
		return this.jumpthruBehavior;
	};
	var candidates = [];
	Runtime.prototype.testOverlapSolid = function (inst)
	{
		var i, len, s;
		inst.update_bbox();
		this.getSolidCollisionCandidates(inst.layer, inst.bbox, candidates);
		for (i = 0, len = candidates.length; i < len; ++i)
		{
			s = candidates[i];
			if (!s.extra["solidEnabled"])
				continue;
			if (this.testOverlap(inst, s))
			{
				cr.clearArray(candidates);
				return s;
			}
		}
		cr.clearArray(candidates);
		return null;
	};
	Runtime.prototype.testRectOverlapSolid = function (r)
	{
		var i, len, s;
		this.getSolidCollisionCandidates(null, r, candidates);
		for (i = 0, len = candidates.length; i < len; ++i)
		{
			s = candidates[i];
			if (!s.extra["solidEnabled"])
				continue;
			if (this.testRectOverlap(r, s))
			{
				cr.clearArray(candidates);
				return s;
			}
		}
		cr.clearArray(candidates);
		return null;
	};
	var jumpthru_array_ret = [];
	Runtime.prototype.testOverlapJumpThru = function (inst, all)
	{
		var ret = null;
		if (all)
		{
			ret = jumpthru_array_ret;
			cr.clearArray(ret);
		}
		inst.update_bbox();
		this.getJumpthruCollisionCandidates(inst.layer, inst.bbox, candidates);
		var i, len, j;
		for (i = 0, len = candidates.length; i < len; ++i)
		{
			j = candidates[i];
			if (!j.extra["jumpthruEnabled"])
				continue;
			if (this.testOverlap(inst, j))
			{
				if (all)
					ret.push(j);
				else
				{
					cr.clearArray(candidates);
					return j;
				}
			}
		}
		cr.clearArray(candidates);
		return ret;
	};
	Runtime.prototype.pushOutSolid = function (inst, xdir, ydir, dist, include_jumpthrus, specific_jumpthru)
	{
		var push_dist = dist || 50;
		var oldx = inst.x
		var oldy = inst.y;
		var i;
		var last_overlapped = null, secondlast_overlapped = null;
		for (i = 0; i < push_dist; i++)
		{
			inst.x = (oldx + (xdir * i));
			inst.y = (oldy + (ydir * i));
			inst.set_bbox_changed();
			if (!this.testOverlap(inst, last_overlapped))
			{
				last_overlapped = this.testOverlapSolid(inst);
				if (last_overlapped)
					secondlast_overlapped = last_overlapped;
				if (!last_overlapped)
				{
					if (include_jumpthrus)
					{
						if (specific_jumpthru)
							last_overlapped = (this.testOverlap(inst, specific_jumpthru) ? specific_jumpthru : null);
						else
							last_overlapped = this.testOverlapJumpThru(inst);
						if (last_overlapped)
							secondlast_overlapped = last_overlapped;
					}
					if (!last_overlapped)
					{
						if (secondlast_overlapped)
							this.pushInFractional(inst, xdir, ydir, secondlast_overlapped, 16);
						return true;
					}
				}
			}
		}
		inst.x = oldx;
		inst.y = oldy;
		inst.set_bbox_changed();
		return false;
	};
	Runtime.prototype.pushOut = function (inst, xdir, ydir, dist, otherinst)
	{
		var push_dist = dist || 50;
		var oldx = inst.x
		var oldy = inst.y;
		var i;
		for (i = 0; i < push_dist; i++)
		{
			inst.x = (oldx + (xdir * i));
			inst.y = (oldy + (ydir * i));
			inst.set_bbox_changed();
			if (!this.testOverlap(inst, otherinst))
				return true;
		}
		inst.x = oldx;
		inst.y = oldy;
		inst.set_bbox_changed();
		return false;
	};
	Runtime.prototype.pushInFractional = function (inst, xdir, ydir, obj, limit)
	{
		var divisor = 2;
		var frac;
		var forward = false;
		var overlapping = false;
		var bestx = inst.x;
		var besty = inst.y;
		while (divisor <= limit)
		{
			frac = 1 / divisor;
			divisor *= 2;
			inst.x += xdir * frac * (forward ? 1 : -1);
			inst.y += ydir * frac * (forward ? 1 : -1);
			inst.set_bbox_changed();
			if (this.testOverlap(inst, obj))
			{
				forward = true;
				overlapping = true;
			}
			else
			{
				forward = false;
				overlapping = false;
				bestx = inst.x;
				besty = inst.y;
			}
		}
		if (overlapping)
		{
			inst.x = bestx;
			inst.y = besty;
			inst.set_bbox_changed();
		}
	};
	Runtime.prototype.pushOutSolidNearest = function (inst, max_dist_)
	{
		var max_dist = (cr.is_undefined(max_dist_) ? 100 : max_dist_);
		var dist = 0;
		var oldx = inst.x
		var oldy = inst.y;
		var dir = 0;
		var dx = 0, dy = 0;
		var last_overlapped = this.testOverlapSolid(inst);
		if (!last_overlapped)
			return true;		// already clear of solids
		while (dist <= max_dist)
		{
			switch (dir) {
			case 0:		dx = 0; dy = -1; dist++; break;
			case 1:		dx = 1; dy = -1; break;
			case 2:		dx = 1; dy = 0; break;
			case 3:		dx = 1; dy = 1; break;
			case 4:		dx = 0; dy = 1; break;
			case 5:		dx = -1; dy = 1; break;
			case 6:		dx = -1; dy = 0; break;
			case 7:		dx = -1; dy = -1; break;
			}
			dir = (dir + 1) % 8;
			inst.x = cr.floor(oldx + (dx * dist));
			inst.y = cr.floor(oldy + (dy * dist));
			inst.set_bbox_changed();
			if (!this.testOverlap(inst, last_overlapped))
			{
				last_overlapped = this.testOverlapSolid(inst);
				if (!last_overlapped)
					return true;
			}
		}
		inst.x = oldx;
		inst.y = oldy;
		inst.set_bbox_changed();
		return false;
	};
	Runtime.prototype.registerCollision = function (a, b)
	{
		if (!a.collisionsEnabled || !b.collisionsEnabled)
			return;
		this.registered_collisions.push([a, b]);
	};
	Runtime.prototype.checkRegisteredCollision = function (a, b)
	{
		var i, len, x;
		for (i = 0, len = this.registered_collisions.length; i < len; i++)
		{
			x = this.registered_collisions[i];
			if ((x[0] == a && x[1] == b) || (x[0] == b && x[1] == a))
				return true;
		}
		return false;
	};
	Runtime.prototype.calculateSolidBounceAngle = function(inst, startx, starty, obj)
	{
		var objx = inst.x;
		var objy = inst.y;
		var radius = cr.max(10, cr.distanceTo(startx, starty, objx, objy));
		var startangle = cr.angleTo(startx, starty, objx, objy);
		var firstsolid = obj || this.testOverlapSolid(inst);
		if (!firstsolid)
			return cr.clamp_angle(startangle + cr.PI);
		var cursolid = firstsolid;
		var i, curangle, anticlockwise_free_angle, clockwise_free_angle;
		var increment = cr.to_radians(5);	// 5 degree increments
		for (i = 1; i < 36; i++)
		{
			curangle = startangle - i * increment;
			inst.x = startx + Math.cos(curangle) * radius;
			inst.y = starty + Math.sin(curangle) * radius;
			inst.set_bbox_changed();
			if (!this.testOverlap(inst, cursolid))
			{
				cursolid = obj ? null : this.testOverlapSolid(inst);
				if (!cursolid)
				{
					anticlockwise_free_angle = curangle;
					break;
				}
			}
		}
		if (i === 36)
			anticlockwise_free_angle = cr.clamp_angle(startangle + cr.PI);
		var cursolid = firstsolid;
		for (i = 1; i < 36; i++)
		{
			curangle = startangle + i * increment;
			inst.x = startx + Math.cos(curangle) * radius;
			inst.y = starty + Math.sin(curangle) * radius;
			inst.set_bbox_changed();
			if (!this.testOverlap(inst, cursolid))
			{
				cursolid = obj ? null : this.testOverlapSolid(inst);
				if (!cursolid)
				{
					clockwise_free_angle = curangle;
					break;
				}
			}
		}
		if (i === 36)
			clockwise_free_angle = cr.clamp_angle(startangle + cr.PI);
		inst.x = objx;
		inst.y = objy;
		inst.set_bbox_changed();
		if (clockwise_free_angle === anticlockwise_free_angle)
			return clockwise_free_angle;
		var half_diff = cr.angleDiff(clockwise_free_angle, anticlockwise_free_angle) / 2;
		var normal;
		if (cr.angleClockwise(clockwise_free_angle, anticlockwise_free_angle))
		{
			normal = cr.clamp_angle(anticlockwise_free_angle + half_diff + cr.PI);
		}
		else
		{
			normal = cr.clamp_angle(clockwise_free_angle + half_diff);
		}
;
		var vx = Math.cos(startangle);
		var vy = Math.sin(startangle);
		var nx = Math.cos(normal);
		var ny = Math.sin(normal);
		var v_dot_n = vx * nx + vy * ny;
		var rx = vx - 2 * v_dot_n * nx;
		var ry = vy - 2 * v_dot_n * ny;
		return cr.angleTo(0, 0, rx, ry);
	};
	var triggerSheetIndex = -1;
	Runtime.prototype.trigger = function (method, inst, value /* for fast triggers */)
	{
;
		if (!this.running_layout)
			return false;
		var sheet = this.running_layout.event_sheet;
		if (!sheet)
			return false;     // no event sheet active; nothing to trigger
		var ret = false;
		var r, i, len;
		triggerSheetIndex++;
		var deep_includes = sheet.deep_includes;
		for (i = 0, len = deep_includes.length; i < len; ++i)
		{
			r = this.triggerOnSheet(method, inst, deep_includes[i], value);
			ret = ret || r;
		}
		r = this.triggerOnSheet(method, inst, sheet, value);
		ret = ret || r;
		triggerSheetIndex--;
		return ret;
    };
    Runtime.prototype.triggerOnSheet = function (method, inst, sheet, value)
    {
        var ret = false;
		var i, leni, r, families;
		if (!inst)
		{
			r = this.triggerOnSheetForTypeName(method, inst, "system", sheet, value);
			ret = ret || r;
		}
		else
		{
			r = this.triggerOnSheetForTypeName(method, inst, inst.type.name, sheet, value);
			ret = ret || r;
			families = inst.type.families;
			for (i = 0, leni = families.length; i < leni; ++i)
			{
				r = this.triggerOnSheetForTypeName(method, inst, families[i].name, sheet, value);
				ret = ret || r;
			}
		}
		return ret;             // true if anything got triggered
	};
	Runtime.prototype.triggerOnSheetForTypeName = function (method, inst, type_name, sheet, value)
	{
		var i, leni;
		var ret = false, ret2 = false;
		var trig, index;
		var fasttrigger = (typeof value !== "undefined");
		var triggers = (fasttrigger ? sheet.fasttriggers : sheet.triggers);
		var obj_entry = triggers[type_name];
		if (!obj_entry)
			return ret;
		var triggers_list = null;
		for (i = 0, leni = obj_entry.length; i < leni; ++i)
		{
			if (obj_entry[i].method == method)
			{
				triggers_list = obj_entry[i].evs;
				break;
			}
		}
		if (!triggers_list)
			return ret;
		var triggers_to_fire;
		if (fasttrigger)
		{
			triggers_to_fire = triggers_list[value];
		}
		else
		{
			triggers_to_fire = triggers_list;
		}
		if (!triggers_to_fire)
			return null;
		for (i = 0, leni = triggers_to_fire.length; i < leni; i++)
		{
			trig = triggers_to_fire[i][0];
			index = triggers_to_fire[i][1];
			ret2 = this.executeSingleTrigger(inst, type_name, trig, index);
			ret = ret || ret2;
		}
		return ret;
	};
	Runtime.prototype.executeSingleTrigger = function (inst, type_name, trig, index)
	{
		var i, leni;
		var ret = false;
		this.trigger_depth++;
		var current_event = this.getCurrentEventStack().current_event;
		if (current_event)
			this.pushCleanSol(current_event.solModifiersIncludingParents);
		var isrecursive = (this.trigger_depth > 1);		// calling trigger from inside another trigger
		this.pushCleanSol(trig.solModifiersIncludingParents);
		if (isrecursive)
			this.pushLocalVarStack();
		var event_stack = this.pushEventStack(trig);
		event_stack.current_event = trig;
		if (inst)
		{
			var sol = this.types[type_name].getCurrentSol();
			sol.select_all = false;
			cr.clearArray(sol.instances);
			sol.instances[0] = inst;
			this.types[type_name].applySolToContainer();
		}
		var ok_to_run = true;
		if (trig.parent)
		{
			var temp_parents_arr = event_stack.temp_parents_arr;
			var cur_parent = trig.parent;
			while (cur_parent)
			{
				temp_parents_arr.push(cur_parent);
				cur_parent = cur_parent.parent;
			}
			temp_parents_arr.reverse();
			for (i = 0, leni = temp_parents_arr.length; i < leni; i++)
			{
				if (!temp_parents_arr[i].run_pretrigger())   // parent event failed
				{
					ok_to_run = false;
					break;
				}
			}
		}
		if (ok_to_run)
		{
			this.execcount++;
			if (trig.orblock)
				trig.run_orblocktrigger(index);
			else
				trig.run();
			ret = ret || event_stack.last_event_true;
		}
		this.popEventStack();
		if (isrecursive)
			this.popLocalVarStack();
		this.popSol(trig.solModifiersIncludingParents);
		if (current_event)
			this.popSol(current_event.solModifiersIncludingParents);
		if (this.hasPendingInstances && this.isInOnDestroy === 0 && triggerSheetIndex === 0 && !this.isRunningEvents)
		{
			this.ClearDeathRow();
		}
		this.trigger_depth--;
		return ret;
	};
	Runtime.prototype.getCurrentCondition = function ()
	{
		var evinfo = this.getCurrentEventStack();
		return evinfo.current_event.conditions[evinfo.cndindex];
	};
	Runtime.prototype.getCurrentConditionObjectType = function ()
	{
		var cnd = this.getCurrentCondition();
		return cnd.type;
	};
	Runtime.prototype.isCurrentConditionFirst = function ()
	{
		var evinfo = this.getCurrentEventStack();
		return evinfo.cndindex === 0;
	};
	Runtime.prototype.getCurrentAction = function ()
	{
		var evinfo = this.getCurrentEventStack();
		return evinfo.current_event.actions[evinfo.actindex];
	};
	Runtime.prototype.pushLocalVarStack = function ()
	{
		this.localvar_stack_index++;
		if (this.localvar_stack_index >= this.localvar_stack.length)
			this.localvar_stack.push([]);
	};
	Runtime.prototype.popLocalVarStack = function ()
	{
;
		this.localvar_stack_index--;
	};
	Runtime.prototype.getCurrentLocalVarStack = function ()
	{
		return this.localvar_stack[this.localvar_stack_index];
	};
	Runtime.prototype.pushEventStack = function (cur_event)
	{
		this.event_stack_index++;
		if (this.event_stack_index >= this.event_stack.length)
			this.event_stack.push(new cr.eventStackFrame());
		var ret = this.getCurrentEventStack();
		ret.reset(cur_event);
		return ret;
	};
	Runtime.prototype.popEventStack = function ()
	{
;
		this.event_stack_index--;
	};
	Runtime.prototype.getCurrentEventStack = function ()
	{
		return this.event_stack[this.event_stack_index];
	};
	Runtime.prototype.pushLoopStack = function (name_)
	{
		this.loop_stack_index++;
		if (this.loop_stack_index >= this.loop_stack.length)
		{
			this.loop_stack.push(cr.seal({ name: name_, index: 0, stopped: false }));
		}
		var ret = this.getCurrentLoop();
		ret.name = name_;
		ret.index = 0;
		ret.stopped = false;
		return ret;
	};
	Runtime.prototype.popLoopStack = function ()
	{
;
		this.loop_stack_index--;
	};
	Runtime.prototype.getCurrentLoop = function ()
	{
		return this.loop_stack[this.loop_stack_index];
	};
	Runtime.prototype.getEventVariableByName = function (name, scope)
	{
		var i, leni, j, lenj, sheet, e;
		while (scope)
		{
			for (i = 0, leni = scope.subevents.length; i < leni; i++)
			{
				e = scope.subevents[i];
				if (e instanceof cr.eventvariable && cr.equals_nocase(name, e.name))
					return e;
			}
			scope = scope.parent;
		}
		for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
		{
			sheet = this.eventsheets_by_index[i];
			for (j = 0, lenj = sheet.events.length; j < lenj; j++)
			{
				e = sheet.events[j];
				if (e instanceof cr.eventvariable && cr.equals_nocase(name, e.name))
					return e;
			}
		}
		return null;
	};
	Runtime.prototype.getLayoutBySid = function (sid_)
	{
		var i, len;
		for (i = 0, len = this.layouts_by_index.length; i < len; i++)
		{
			if (this.layouts_by_index[i].sid === sid_)
				return this.layouts_by_index[i];
		}
		return null;
	};
	Runtime.prototype.getObjectTypeBySid = function (sid_)
	{
		var i, len;
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			if (this.types_by_index[i].sid === sid_)
				return this.types_by_index[i];
		}
		return null;
	};
	Runtime.prototype.getGroupBySid = function (sid_)
	{
		var i, len;
		for (i = 0, len = this.allGroups.length; i < len; i++)
		{
			if (this.allGroups[i].sid === sid_)
				return this.allGroups[i];
		}
		return null;
	};
	Runtime.prototype.doCanvasSnapshot = function (format_, quality_)
	{
		this.snapshotCanvas = [format_, quality_];
		this.redraw = true;		// force redraw so snapshot is always taken
	};
	function IsIndexedDBAvailable()
	{
		try {
			return !!window.indexedDB;
		}
		catch (e)
		{
			return false;
		}
	};
	function makeSaveDb(e)
	{
		var db = e.target.result;
		db.createObjectStore("saves", { keyPath: "slot" });
	};
	function IndexedDB_WriteSlot(slot_, data_, oncomplete_, onerror_)
	{
		try {
			var request = indexedDB.open("_C2SaveStates");
			request.onupgradeneeded = makeSaveDb;
			request.onerror = onerror_;
			request.onsuccess = function (e)
			{
				var db = e.target.result;
				db.onerror = onerror_;
				var transaction = db.transaction(["saves"], "readwrite");
				var objectStore = transaction.objectStore("saves");
				var putReq = objectStore.put({"slot": slot_, "data": data_ });
				putReq.onsuccess = oncomplete_;
			};
		}
		catch (err)
		{
			onerror_(err);
		}
	};
	function IndexedDB_ReadSlot(slot_, oncomplete_, onerror_)
	{
		try {
			var request = indexedDB.open("_C2SaveStates");
			request.onupgradeneeded = makeSaveDb;
			request.onerror = onerror_;
			request.onsuccess = function (e)
			{
				var db = e.target.result;
				db.onerror = onerror_;
				var transaction = db.transaction(["saves"]);
				var objectStore = transaction.objectStore("saves");
				var readReq = objectStore.get(slot_);
				readReq.onsuccess = function (e)
				{
					if (readReq.result)
						oncomplete_(readReq.result["data"]);
					else
						oncomplete_(null);
				};
			};
		}
		catch (err)
		{
			onerror_(err);
		}
	};
	Runtime.prototype.signalContinuousPreview = function ()
	{
		this.signalledContinuousPreview = true;
	};
	function doContinuousPreviewReload()
	{
		cr.logexport("Reloading for continuous preview");
		if (!!window["c2cocoonjs"])
		{
			CocoonJS["App"]["reload"]();
		}
		else
		{
			if (window.location.search.indexOf("continuous") > -1)
				window.location.reload(true);
			else
				window.location = window.location + "?continuous";
		}
	};
	Runtime.prototype.handleSaveLoad = function ()
	{
		var self = this;
		var savingToSlot = this.saveToSlot;
		var savingJson = this.lastSaveJson;
		var loadingFromSlot = this.loadFromSlot;
		var continuous = false;
		if (this.signalledContinuousPreview)
		{
			continuous = true;
			savingToSlot = "__c2_continuouspreview";
			this.signalledContinuousPreview = false;
		}
		if (savingToSlot.length)
		{
			this.ClearDeathRow();
			savingJson = this.saveToJSONString();
			if (IsIndexedDBAvailable() && !this.isCocoonJs)
			{
				IndexedDB_WriteSlot(savingToSlot, savingJson, function ()
				{
					cr.logexport("Saved state to IndexedDB storage (" + savingJson.length + " bytes)");
					self.lastSaveJson = savingJson;
					self.trigger(cr.system_object.prototype.cnds.OnSaveComplete, null);
					self.lastSaveJson = "";
					if (continuous)
						doContinuousPreviewReload();
				}, function (e)
				{
					try {
						localStorage.setItem("__c2save_" + savingToSlot, savingJson);
						cr.logexport("Saved state to WebStorage (" + savingJson.length + " bytes)");
						self.lastSaveJson = savingJson;
						self.trigger(cr.system_object.prototype.cnds.OnSaveComplete, null);
						self.lastSaveJson = "";
						if (continuous)
							doContinuousPreviewReload();
					}
					catch (f)
					{
						cr.logexport("Failed to save game state: " + e + "; " + f);
						self.trigger(cr.system_object.prototype.cnds.OnSaveFailed, null);
					}
				});
			}
			else
			{
				try {
					localStorage.setItem("__c2save_" + savingToSlot, savingJson);
					cr.logexport("Saved state to WebStorage (" + savingJson.length + " bytes)");
					self.lastSaveJson = savingJson;
					this.trigger(cr.system_object.prototype.cnds.OnSaveComplete, null);
					self.lastSaveJson = "";
					if (continuous)
						doContinuousPreviewReload();
				}
				catch (e)
				{
					cr.logexport("Error saving to WebStorage: " + e);
					self.trigger(cr.system_object.prototype.cnds.OnSaveFailed, null);
				}
			}
			this.saveToSlot = "";
			this.loadFromSlot = "";
			this.loadFromJson = "";
		}
		if (loadingFromSlot.length)
		{
			if (IsIndexedDBAvailable() && !this.isCocoonJs)
			{
				IndexedDB_ReadSlot(loadingFromSlot, function (result_)
				{
					if (result_)
					{
						self.loadFromJson = result_;
						cr.logexport("Loaded state from IndexedDB storage (" + self.loadFromJson.length + " bytes)");
					}
					else
					{
						self.loadFromJson = localStorage.getItem("__c2save_" + loadingFromSlot) || "";
						cr.logexport("Loaded state from WebStorage (" + self.loadFromJson.length + " bytes)");
					}
					self.suspendDrawing = false;
					if (!self.loadFromJson.length)
						self.trigger(cr.system_object.prototype.cnds.OnLoadFailed, null);
				}, function (e)
				{
					self.loadFromJson = localStorage.getItem("__c2save_" + loadingFromSlot) || "";
					cr.logexport("Loaded state from WebStorage (" + self.loadFromJson.length + " bytes)");
					self.suspendDrawing = false;
					if (!self.loadFromJson.length)
						self.trigger(cr.system_object.prototype.cnds.OnLoadFailed, null);
				});
			}
			else
			{
				try {
					this.loadFromJson = localStorage.getItem("__c2save_" + loadingFromSlot) || "";
					cr.logexport("Loaded state from WebStorage (" + this.loadFromJson.length + " bytes)");
				}
				catch (e)
				{
					this.loadFromJson = "";
				}
				this.suspendDrawing = false;
				if (!self.loadFromJson.length)
					self.trigger(cr.system_object.prototype.cnds.OnLoadFailed, null);
			}
			this.loadFromSlot = "";
			this.saveToSlot = "";
		}
		if (this.loadFromJson.length)
		{
			this.ClearDeathRow();
			this.loadFromJSONString(this.loadFromJson);
			this.lastSaveJson = this.loadFromJson;
			this.trigger(cr.system_object.prototype.cnds.OnLoadComplete, null);
			this.lastSaveJson = "";
			this.loadFromJson = "";
		}
	};
	function CopyExtraObject(extra)
	{
		var p, ret = {};
		for (p in extra)
		{
			if (extra.hasOwnProperty(p))
			{
				if (extra[p] instanceof cr.ObjectSet)
					continue;
				if (extra[p] && typeof extra[p].c2userdata !== "undefined")
					continue;
				if (p === "spriteCreatedDestroyCallback")
					continue;
				ret[p] = extra[p];
			}
		}
		return ret;
	};
	Runtime.prototype.saveToJSONString = function()
	{
		var i, len, j, lenj, type, layout, typeobj, g, c, a, v, p;
		var o = {
			"c2save":				true,
			"version":				1,
			"rt": {
				"time":				this.kahanTime.sum,
				"walltime":			this.wallTime.sum,
				"timescale":		this.timescale,
				"tickcount":		this.tickcount,
				"execcount":		this.execcount,
				"next_uid":			this.next_uid,
				"running_layout":	this.running_layout.sid,
				"start_time_offset": (Date.now() - this.start_time)
			},
			"types": {},
			"layouts": {},
			"events": {
				"groups": {},
				"cnds": {},
				"acts": {},
				"vars": {}
			}
		};
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			type = this.types_by_index[i];
			if (type.is_family || this.typeHasNoSaveBehavior(type))
				continue;
			typeobj = {
				"instances": []
			};
			if (cr.hasAnyOwnProperty(type.extra))
				typeobj["ex"] = CopyExtraObject(type.extra);
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				typeobj["instances"].push(this.saveInstanceToJSON(type.instances[j]));
			}
			o["types"][type.sid.toString()] = typeobj;
		}
		for (i = 0, len = this.layouts_by_index.length; i < len; i++)
		{
			layout = this.layouts_by_index[i];
			o["layouts"][layout.sid.toString()] = layout.saveToJSON();
		}
		var ogroups = o["events"]["groups"];
		for (i = 0, len = this.allGroups.length; i < len; i++)
		{
			g = this.allGroups[i];
			ogroups[g.sid.toString()] = this.groups_by_name[g.group_name].group_active;
		}
		var ocnds = o["events"]["cnds"];
		for (p in this.cndsBySid)
		{
			if (this.cndsBySid.hasOwnProperty(p))
			{
				c = this.cndsBySid[p];
				if (cr.hasAnyOwnProperty(c.extra))
					ocnds[p] = { "ex": CopyExtraObject(c.extra) };
			}
		}
		var oacts = o["events"]["acts"];
		for (p in this.actsBySid)
		{
			if (this.actsBySid.hasOwnProperty(p))
			{
				a = this.actsBySid[p];
				if (cr.hasAnyOwnProperty(a.extra))
					oacts[p] = { "ex": CopyExtraObject(a.extra) };
			}
		}
		var ovars = o["events"]["vars"];
		for (p in this.varsBySid)
		{
			if (this.varsBySid.hasOwnProperty(p))
			{
				v = this.varsBySid[p];
				if (!v.is_constant && (!v.parent || v.is_static))
					ovars[p] = v.data;
			}
		}
		o["system"] = this.system.saveToJSON();
		return JSON.stringify(o);
	};
	Runtime.prototype.refreshUidMap = function ()
	{
		var i, len, type, j, lenj, inst;
		this.objectsByUid = {};
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			type = this.types_by_index[i];
			if (type.is_family)
				continue;
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				inst = type.instances[j];
				this.objectsByUid[inst.uid.toString()] = inst;
			}
		}
	};
	Runtime.prototype.loadFromJSONString = function (str)
	{
		var o = JSON.parse(str);
		if (!o["c2save"])
			return;		// probably not a c2 save state
		if (o["version"] > 1)
			return;		// from future version of c2; assume not compatible
		this.isLoadingState = true;
		var rt = o["rt"];
		this.kahanTime.reset();
		this.kahanTime.sum = rt["time"];
		this.wallTime.reset();
		this.wallTime.sum = rt["walltime"] || 0;
		this.timescale = rt["timescale"];
		this.tickcount = rt["tickcount"];
		this.execcount = rt["execcount"];
		this.start_time = Date.now() - rt["start_time_offset"];
		var layout_sid = rt["running_layout"];
		if (layout_sid !== this.running_layout.sid)
		{
			var changeToLayout = this.getLayoutBySid(layout_sid);
			if (changeToLayout)
				this.doChangeLayout(changeToLayout);
			else
				return;		// layout that was saved on has gone missing (deleted?)
		}
		var i, len, j, lenj, k, lenk, p, type, existing_insts, load_insts, inst, binst, layout, layer, g, iid, t;
		var otypes = o["types"];
		for (p in otypes)
		{
			if (otypes.hasOwnProperty(p))
			{
				type = this.getObjectTypeBySid(parseInt(p, 10));
				if (!type || type.is_family || this.typeHasNoSaveBehavior(type))
					continue;
				if (otypes[p]["ex"])
					type.extra = otypes[p]["ex"];
				else
					cr.wipe(type.extra);
				existing_insts = type.instances;
				load_insts = otypes[p]["instances"];
				for (i = 0, len = cr.min(existing_insts.length, load_insts.length); i < len; i++)
				{
					this.loadInstanceFromJSON(existing_insts[i], load_insts[i]);
				}
				for (i = load_insts.length, len = existing_insts.length; i < len; i++)
					this.DestroyInstance(existing_insts[i]);
				for (i = existing_insts.length, len = load_insts.length; i < len; i++)
				{
					layer = null;
					if (type.plugin.is_world)
					{
						layer = this.running_layout.getLayerBySid(load_insts[i]["w"]["l"]);
						if (!layer)
							continue;
					}
					inst = this.createInstanceFromInit(type.default_instance, layer, false, 0, 0, true);
					this.loadInstanceFromJSON(inst, load_insts[i]);
				}
				type.stale_iids = true;
			}
		}
		this.ClearDeathRow();
		this.refreshUidMap();
		var olayouts = o["layouts"];
		for (p in olayouts)
		{
			if (olayouts.hasOwnProperty(p))
			{
				layout = this.getLayoutBySid(parseInt(p, 10));
				if (!layout)
					continue;		// must've gone missing
				layout.loadFromJSON(olayouts[p]);
			}
		}
		var ogroups = o["events"]["groups"];
		for (p in ogroups)
		{
			if (ogroups.hasOwnProperty(p))
			{
				g = this.getGroupBySid(parseInt(p, 10));
				if (g && this.groups_by_name[g.group_name])
					this.groups_by_name[g.group_name].setGroupActive(ogroups[p]);
			}
		}
		var ocnds = o["events"]["cnds"];
		for (p in this.cndsBySid)
		{
			if (this.cndsBySid.hasOwnProperty(p))
			{
				if (ocnds.hasOwnProperty(p))
				{
					this.cndsBySid[p].extra = ocnds[p]["ex"];
				}
				else
				{
					this.cndsBySid[p].extra = {};
				}
			}
		}
		var oacts = o["events"]["acts"];
		for (p in this.actsBySid)
		{
			if (this.actsBySid.hasOwnProperty(p))
			{
				if (oacts.hasOwnProperty(p))
				{
					this.actsBySid[p].extra = oacts[p]["ex"];
				}
				else
				{
					this.actsBySid[p].extra = {};
				}
			}
		}
		var ovars = o["events"]["vars"];
		for (p in ovars)
		{
			if (ovars.hasOwnProperty(p) && this.varsBySid.hasOwnProperty(p))
			{
				this.varsBySid[p].data = ovars[p];
			}
		}
		this.next_uid = rt["next_uid"];
		this.isLoadingState = false;
		for (i = 0, len = this.fireOnCreateAfterLoad.length; i < len; ++i)
		{
			inst = this.fireOnCreateAfterLoad[i];
			this.trigger(Object.getPrototypeOf(inst.type.plugin).cnds.OnCreated, inst);
		}
		cr.clearArray(this.fireOnCreateAfterLoad);
		this.system.loadFromJSON(o["system"]);
		for (i = 0, len = this.types_by_index.length; i < len; i++)
		{
			type = this.types_by_index[i];
			if (type.is_family || this.typeHasNoSaveBehavior(type))
				continue;
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
			{
				inst = type.instances[j];
				if (type.is_contained)
				{
					iid = inst.get_iid();
					cr.clearArray(inst.siblings);
					for (k = 0, lenk = type.container.length; k < lenk; k++)
					{
						t = type.container[k];
						if (type === t)
							continue;
;
						inst.siblings.push(t.instances[iid]);
					}
				}
				if (inst.afterLoad)
					inst.afterLoad();
				if (inst.behavior_insts)
				{
					for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
					{
						binst = inst.behavior_insts[k];
						if (binst.afterLoad)
							binst.afterLoad();
					}
				}
			}
		}
		this.redraw = true;
	};
	Runtime.prototype.saveInstanceToJSON = function(inst, state_only)
	{
		var i, len, world, behinst, et;
		var type = inst.type;
		var plugin = type.plugin;
		var o = {};
		if (state_only)
			o["c2"] = true;		// mark as known json data from Construct 2
		else
			o["uid"] = inst.uid;
		if (cr.hasAnyOwnProperty(inst.extra))
			o["ex"] = CopyExtraObject(inst.extra);
		if (inst.instance_vars && inst.instance_vars.length)
		{
			o["ivs"] = {};
			for (i = 0, len = inst.instance_vars.length; i < len; i++)
			{
				o["ivs"][inst.type.instvar_sids[i].toString()] = inst.instance_vars[i];
			}
		}
		if (plugin.is_world)
		{
			world = {
				"x": inst.x,
				"y": inst.y,
				"w": inst.width,
				"h": inst.height,
				"l": inst.layer.sid,
				"zi": inst.get_zindex()
			};
			if (inst.angle !== 0)
				world["a"] = inst.angle;
			if (inst.opacity !== 1)
				world["o"] = inst.opacity;
			if (inst.hotspotX !== 0.5)
				world["hX"] = inst.hotspotX;
			if (inst.hotspotY !== 0.5)
				world["hY"] = inst.hotspotY;
			if (inst.blend_mode !== 0)
				world["bm"] = inst.blend_mode;
			if (!inst.visible)
				world["v"] = inst.visible;
			if (!inst.collisionsEnabled)
				world["ce"] = inst.collisionsEnabled;
			if (inst.my_timescale !== -1)
				world["mts"] = inst.my_timescale;
			if (type.effect_types.length)
			{
				world["fx"] = [];
				for (i = 0, len = type.effect_types.length; i < len; i++)
				{
					et = type.effect_types[i];
					world["fx"].push({"name": et.name,
									  "active": inst.active_effect_flags[et.index],
									  "params": inst.effect_params[et.index] });
				}
			}
			o["w"] = world;
		}
		if (inst.behavior_insts && inst.behavior_insts.length)
		{
			o["behs"] = {};
			for (i = 0, len = inst.behavior_insts.length; i < len; i++)
			{
				behinst = inst.behavior_insts[i];
				if (behinst.saveToJSON)
					o["behs"][behinst.type.sid.toString()] = behinst.saveToJSON();
			}
		}
		if (inst.saveToJSON)
			o["data"] = inst.saveToJSON();
		return o;
	};
	Runtime.prototype.getInstanceVarIndexBySid = function (type, sid_)
	{
		var i, len;
		for (i = 0, len = type.instvar_sids.length; i < len; i++)
		{
			if (type.instvar_sids[i] === sid_)
				return i;
		}
		return -1;
	};
	Runtime.prototype.getBehaviorIndexBySid = function (inst, sid_)
	{
		var i, len;
		for (i = 0, len = inst.behavior_insts.length; i < len; i++)
		{
			if (inst.behavior_insts[i].type.sid === sid_)
				return i;
		}
		return -1;
	};
	Runtime.prototype.loadInstanceFromJSON = function(inst, o, state_only)
	{
		var p, i, len, iv, oivs, world, fxindex, obehs, behindex;
		var oldlayer;
		var type = inst.type;
		var plugin = type.plugin;
		if (state_only)
		{
			if (!o["c2"])
				return;
		}
		else
			inst.uid = o["uid"];
		if (o["ex"])
			inst.extra = o["ex"];
		else
			cr.wipe(inst.extra);
		oivs = o["ivs"];
		if (oivs)
		{
			for (p in oivs)
			{
				if (oivs.hasOwnProperty(p))
				{
					iv = this.getInstanceVarIndexBySid(type, parseInt(p, 10));
					if (iv < 0 || iv >= inst.instance_vars.length)
						continue;		// must've gone missing
					inst.instance_vars[iv] = oivs[p];
				}
			}
		}
		if (plugin.is_world)
		{
			world = o["w"];
			if (inst.layer.sid !== world["l"])
			{
				oldlayer = inst.layer;
				inst.layer = this.running_layout.getLayerBySid(world["l"]);
				if (inst.layer)
				{
					oldlayer.removeFromInstanceList(inst, true);
					inst.layer.appendToInstanceList(inst, true);
					inst.set_bbox_changed();
					inst.layer.setZIndicesStaleFrom(0);
				}
				else
				{
					inst.layer = oldlayer;
					if (!state_only)
						this.DestroyInstance(inst);
				}
			}
			inst.x = world["x"];
			inst.y = world["y"];
			inst.width = world["w"];
			inst.height = world["h"];
			inst.zindex = world["zi"];
			inst.angle = world.hasOwnProperty("a") ? world["a"] : 0;
			inst.opacity = world.hasOwnProperty("o") ? world["o"] : 1;
			inst.hotspotX = world.hasOwnProperty("hX") ? world["hX"] : 0.5;
			inst.hotspotY = world.hasOwnProperty("hY") ? world["hY"] : 0.5;
			inst.visible = world.hasOwnProperty("v") ? world["v"] : true;
			inst.collisionsEnabled = world.hasOwnProperty("ce") ? world["ce"] : true;
			inst.my_timescale = world.hasOwnProperty("mts") ? world["mts"] : -1;
			inst.blend_mode = world.hasOwnProperty("bm") ? world["bm"] : 0;;
			inst.compositeOp = cr.effectToCompositeOp(inst.blend_mode);
			if (this.gl)
				cr.setGLBlend(inst, inst.blend_mode, this.gl);
			inst.set_bbox_changed();
			if (world.hasOwnProperty("fx"))
			{
				for (i = 0, len = world["fx"].length; i < len; i++)
				{
					fxindex = type.getEffectIndexByName(world["fx"][i]["name"]);
					if (fxindex < 0)
						continue;		// must've gone missing
					inst.active_effect_flags[fxindex] = world["fx"][i]["active"];
					inst.effect_params[fxindex] = world["fx"][i]["params"];
				}
			}
			inst.updateActiveEffects();
		}
		obehs = o["behs"];
		if (obehs)
		{
			for (p in obehs)
			{
				if (obehs.hasOwnProperty(p))
				{
					behindex = this.getBehaviorIndexBySid(inst, parseInt(p, 10));
					if (behindex < 0)
						continue;		// must've gone missing
					inst.behavior_insts[behindex].loadFromJSON(obehs[p]);
				}
			}
		}
		if (o["data"])
			inst.loadFromJSON(o["data"]);
	};
	Runtime.prototype.fetchLocalFileViaCordova = function (filename, successCallback, errorCallback)
	{
		var path = cordova["file"]["applicationDirectory"] + "www/" + filename;
		window["resolveLocalFileSystemURL"](path, function (entry)
		{
			entry.file(successCallback, errorCallback);
		}, errorCallback);
	};
	Runtime.prototype.fetchLocalFileViaCordovaAsText = function (filename, successCallback, errorCallback)
	{
		this.fetchLocalFileViaCordova(filename, function (file)
		{
			var reader = new FileReader();
			reader.onload = function (e)
			{
				successCallback(e.target.result);
			};
			reader.onerror = errorCallback;
			reader.readAsText(file);
		}, errorCallback);
	};
	var queuedArrayBufferReads = [];
	var activeArrayBufferReads = 0;
	var MAX_ARRAYBUFFER_READS = 8;
	Runtime.prototype.maybeStartNextArrayBufferRead = function()
	{
		if (!queuedArrayBufferReads.length)
			return;		// none left
		if (activeArrayBufferReads >= MAX_ARRAYBUFFER_READS)
			return;		// already got maximum number in-flight
		activeArrayBufferReads++;
		var job = queuedArrayBufferReads.shift();
		this.doFetchLocalFileViaCordovaAsArrayBuffer(job.filename, job.successCallback, job.errorCallback);
	};
	Runtime.prototype.fetchLocalFileViaCordovaAsArrayBuffer = function (filename, successCallback_, errorCallback_)
	{
		var self = this;
		queuedArrayBufferReads.push({
			filename: filename,
			successCallback: function (result)
			{
				activeArrayBufferReads--;
				self.maybeStartNextArrayBufferRead();
				successCallback_(result);
			},
			errorCallback: function (err)
			{
				activeArrayBufferReads--;
				self.maybeStartNextArrayBufferRead();
				errorCallback_(err);
			}
		});
		this.maybeStartNextArrayBufferRead();
	};
	Runtime.prototype.doFetchLocalFileViaCordovaAsArrayBuffer = function (filename, successCallback, errorCallback)
	{
		this.fetchLocalFileViaCordova(filename, function (file)
		{
			var reader = new FileReader();
			reader.onload = function (e)
			{
				successCallback(e.target.result);
			};
			reader.readAsArrayBuffer(file);
		}, errorCallback);
	};
	Runtime.prototype.fetchLocalFileViaCordovaAsURL = function (filename, successCallback, errorCallback)
	{
		this.fetchLocalFileViaCordovaAsArrayBuffer(filename, function (arrayBuffer)
		{
			var blob = new Blob([arrayBuffer]);
			var url = URL.createObjectURL(blob);
			successCallback(url);
		}, errorCallback);
	};
	Runtime.prototype.isAbsoluteUrl = function (url)
	{
		return /^(?:[a-z]+:)?\/\//.test(url) || url.substr(0, 5) === "data:"  || url.substr(0, 5) === "blob:";
	};
	Runtime.prototype.setImageSrc = function (img, src)
	{
		if (this.isWKWebView && !this.isAbsoluteUrl(src))
		{
			this.fetchLocalFileViaCordovaAsURL(src, function (url)
			{
				img.src = url;
			}, function (err)
			{
				alert("Failed to load image: " + err);
			});
		}
		else
		{
			img.src = src;
		}
	};
	Runtime.prototype.setCtxImageSmoothingEnabled = function (ctx, e)
	{
		if (typeof ctx["imageSmoothingEnabled"] !== "undefined")
		{
			ctx["imageSmoothingEnabled"] = e;
		}
		else
		{
			ctx["webkitImageSmoothingEnabled"] = e;
			ctx["mozImageSmoothingEnabled"] = e;
			ctx["msImageSmoothingEnabled"] = e;
		}
	};
	cr.runtime = Runtime;
	cr.createRuntime = function (canvasid)
	{
		return new Runtime(document.getElementById(canvasid));
	};
	cr.createDCRuntime = function (w, h)
	{
		return new Runtime({ "dc": true, "width": w, "height": h });
	};
	window["cr_createRuntime"] = cr.createRuntime;
	window["cr_createDCRuntime"] = cr.createDCRuntime;
	window["createCocoonJSRuntime"] = function ()
	{
		window["c2cocoonjs"] = true;
		var canvas = document.createElement("screencanvas") || document.createElement("canvas");
		canvas.screencanvas = true;
		document.body.appendChild(canvas);
		var rt = new Runtime(canvas);
		window["c2runtime"] = rt;
		window.addEventListener("orientationchange", function () {
			window["c2runtime"]["setSize"](window.innerWidth, window.innerHeight);
		});
		window["c2runtime"]["setSize"](window.innerWidth, window.innerHeight);
		return rt;
	};
	window["createEjectaRuntime"] = function ()
	{
		var canvas = document.getElementById("canvas");
		var rt = new Runtime(canvas);
		window["c2runtime"] = rt;
		window["c2runtime"]["setSize"](window.innerWidth, window.innerHeight);
		return rt;
	};
}());
window["cr_getC2Runtime"] = function()
{
	var canvas = document.getElementById("c2canvas");
	if (canvas)
		return canvas["c2runtime"];
	else if (window["c2runtime"])
		return window["c2runtime"];
	else
		return null;
}
window["cr_getSnapshot"] = function (format_, quality_)
{
	var runtime = window["cr_getC2Runtime"]();
	if (runtime)
		runtime.doCanvasSnapshot(format_, quality_);
}
window["cr_sizeCanvas"] = function(w, h)
{
	if (w === 0 || h === 0)
		return;
	var runtime = window["cr_getC2Runtime"]();
	if (runtime)
		runtime["setSize"](w, h);
}
window["cr_setSuspended"] = function(s)
{
	var runtime = window["cr_getC2Runtime"]();
	if (runtime)
		runtime["setSuspended"](s);
}
;
(function()
{
	function Layout(runtime, m)
	{
		this.runtime = runtime;
		this.event_sheet = null;
		this.scrollX = (this.runtime.original_width / 2);
		this.scrollY = (this.runtime.original_height / 2);
		this.scale = 1.0;
		this.angle = 0;
		this.first_visit = true;
		this.name = m[0];
		this.originalWidth = m[1];
		this.originalHeight = m[2];
		this.width = m[1];
		this.height = m[2];
		this.unbounded_scrolling = m[3];
		this.sheetname = m[4];
		this.sid = m[5];
		var lm = m[6];
		var i, len;
		this.layers = [];
		this.initial_types = [];
		for (i = 0, len = lm.length; i < len; i++)
		{
			var layer = new cr.layer(this, lm[i]);
			layer.number = i;
			cr.seal(layer);
			this.layers.push(layer);
		}
		var im = m[7];
		this.initial_nonworld = [];
		for (i = 0, len = im.length; i < len; i++)
		{
			var inst = im[i];
			var type = this.runtime.types_by_index[inst[1]];
;
			if (!type.default_instance)
				type.default_instance = inst;
			this.initial_nonworld.push(inst);
			if (this.initial_types.indexOf(type) === -1)
				this.initial_types.push(type);
		}
		this.effect_types = [];
		this.active_effect_types = [];
		this.shaders_preserve_opaqueness = true;
		this.effect_params = [];
		for (i = 0, len = m[8].length; i < len; i++)
		{
			this.effect_types.push({
				id: m[8][i][0],
				name: m[8][i][1],
				shaderindex: -1,
				preservesOpaqueness: false,
				active: true,
				index: i
			});
			this.effect_params.push(m[8][i][2].slice(0));
		}
		this.updateActiveEffects();
		this.rcTex = new cr.rect(0, 0, 1, 1);
		this.rcTex2 = new cr.rect(0, 0, 1, 1);
		this.persist_data = {};
	};
	Layout.prototype.saveObjectToPersist = function (inst)
	{
		var sidStr = inst.type.sid.toString();
		if (!this.persist_data.hasOwnProperty(sidStr))
			this.persist_data[sidStr] = [];
		var type_persist = this.persist_data[sidStr];
		type_persist.push(this.runtime.saveInstanceToJSON(inst));
	};
	Layout.prototype.hasOpaqueBottomLayer = function ()
	{
		var layer = this.layers[0];
		return !layer.transparent && layer.opacity === 1.0 && !layer.forceOwnTexture && layer.visible;
	};
	Layout.prototype.updateActiveEffects = function ()
	{
		cr.clearArray(this.active_effect_types);
		this.shaders_preserve_opaqueness = true;
		var i, len, et;
		for (i = 0, len = this.effect_types.length; i < len; i++)
		{
			et = this.effect_types[i];
			if (et.active)
			{
				this.active_effect_types.push(et);
				if (!et.preservesOpaqueness)
					this.shaders_preserve_opaqueness = false;
			}
		}
	};
	Layout.prototype.getEffectByName = function (name_)
	{
		var i, len, et;
		for (i = 0, len = this.effect_types.length; i < len; i++)
		{
			et = this.effect_types[i];
			if (et.name === name_)
				return et;
		}
		return null;
	};
	var created_instances = [];
	function sort_by_zindex(a, b)
	{
		return a.zindex - b.zindex;
	};
	var first_layout = true;
	Layout.prototype.startRunning = function ()
	{
		if (this.sheetname)
		{
			this.event_sheet = this.runtime.eventsheets[this.sheetname];
;
			this.event_sheet.updateDeepIncludes();
		}
		this.runtime.running_layout = this;
		this.width = this.originalWidth;
		this.height = this.originalHeight;
		this.scrollX = (this.runtime.original_width / 2);
		this.scrollY = (this.runtime.original_height / 2);
		var i, k, len, lenk, type, type_instances, inst, iid, t, s, p, q, type_data, layer;
		for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
		{
			type = this.runtime.types_by_index[i];
			if (type.is_family)
				continue;		// instances are only transferred for their real type
			type_instances = type.instances;
			for (k = 0, lenk = type_instances.length; k < lenk; k++)
			{
				inst = type_instances[k];
				if (inst.layer)
				{
					var num = inst.layer.number;
					if (num >= this.layers.length)
						num = this.layers.length - 1;
					inst.layer = this.layers[num];
					if (inst.layer.instances.indexOf(inst) === -1)
						inst.layer.instances.push(inst);
					inst.layer.zindices_stale = true;
				}
			}
		}
		if (!first_layout)
		{
			for (i = 0, len = this.layers.length; i < len; ++i)
			{
				this.layers[i].instances.sort(sort_by_zindex);
			}
		}
		var layer;
		cr.clearArray(created_instances);
		this.boundScrolling();
		for (i = 0, len = this.layers.length; i < len; i++)
		{
			layer = this.layers[i];
			layer.createInitialInstances();		// fills created_instances
			layer.updateViewport(null);
		}
		var uids_changed = false;
		if (!this.first_visit)
		{
			for (p in this.persist_data)
			{
				if (this.persist_data.hasOwnProperty(p))
				{
					type = this.runtime.getObjectTypeBySid(parseInt(p, 10));
					if (!type || type.is_family || !this.runtime.typeHasPersistBehavior(type))
						continue;
					type_data = this.persist_data[p];
					for (i = 0, len = type_data.length; i < len; i++)
					{
						layer = null;
						if (type.plugin.is_world)
						{
							layer = this.getLayerBySid(type_data[i]["w"]["l"]);
							if (!layer)
								continue;
						}
						inst = this.runtime.createInstanceFromInit(type.default_instance, layer, false, 0, 0, true);
						this.runtime.loadInstanceFromJSON(inst, type_data[i]);
						uids_changed = true;
						created_instances.push(inst);
					}
					cr.clearArray(type_data);
				}
			}
			for (i = 0, len = this.layers.length; i < len; i++)
			{
				this.layers[i].instances.sort(sort_by_zindex);
				this.layers[i].zindices_stale = true;		// in case of duplicates/holes
			}
		}
		if (uids_changed)
		{
			this.runtime.ClearDeathRow();
			this.runtime.refreshUidMap();
		}
		for (i = 0; i < created_instances.length; i++)
		{
			inst = created_instances[i];
			if (!inst.type.is_contained)
				continue;
			iid = inst.get_iid();
			for (k = 0, lenk = inst.type.container.length; k < lenk; k++)
			{
				t = inst.type.container[k];
				if (inst.type === t)
					continue;
				if (t.instances.length > iid)
					inst.siblings.push(t.instances[iid]);
				else
				{
					if (!t.default_instance)
					{
					}
					else
					{
						s = this.runtime.createInstanceFromInit(t.default_instance, inst.layer, true, inst.x, inst.y, true);
						this.runtime.ClearDeathRow();
						t.updateIIDs();
						inst.siblings.push(s);
						created_instances.push(s);		// come back around and link up its own instances too
					}
				}
			}
		}
		for (i = 0, len = this.initial_nonworld.length; i < len; i++)
		{
			inst = this.runtime.createInstanceFromInit(this.initial_nonworld[i], null, true);
;
		}
		this.runtime.changelayout = null;
		this.runtime.ClearDeathRow();
		if (this.runtime.ctx && !this.runtime.isDomFree)
		{
			for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
			{
				t = this.runtime.types_by_index[i];
				if (t.is_family || !t.instances.length || !t.preloadCanvas2D)
					continue;
				t.preloadCanvas2D(this.runtime.ctx);
			}
		}
		/*
		if (this.runtime.glwrap)
		{
			console.log("Estimated VRAM at layout start: " + this.runtime.glwrap.textureCount() + " textures, approx. " + Math.round(this.runtime.glwrap.estimateVRAM() / 1024) + " kb");
		}
		*/
		if (this.runtime.isLoadingState)
		{
			cr.shallowAssignArray(this.runtime.fireOnCreateAfterLoad, created_instances);
		}
		else
		{
			for (i = 0, len = created_instances.length; i < len; i++)
			{
				inst = created_instances[i];
				this.runtime.trigger(Object.getPrototypeOf(inst.type.plugin).cnds.OnCreated, inst);
			}
		}
		cr.clearArray(created_instances);
		if (!this.runtime.isLoadingState)
		{
			this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutStart, null);
		}
		this.first_visit = false;
	};
	Layout.prototype.createGlobalNonWorlds = function ()
	{
		var i, k, len, initial_inst, inst, type;
		for (i = 0, k = 0, len = this.initial_nonworld.length; i < len; i++)
		{
			initial_inst = this.initial_nonworld[i];
			type = this.runtime.types_by_index[initial_inst[1]];
			if (type.global)
			{
				if (!type.is_contained)
				{
					inst = this.runtime.createInstanceFromInit(initial_inst, null, true);
				}
			}
			else
			{
				this.initial_nonworld[k] = initial_inst;
				k++;
			}
		}
		cr.truncateArray(this.initial_nonworld, k);
	};
	Layout.prototype.stopRunning = function ()
	{
;
		/*
		if (this.runtime.glwrap)
		{
			console.log("Estimated VRAM at layout end: " + this.runtime.glwrap.textureCount() + " textures, approx. " + Math.round(this.runtime.glwrap.estimateVRAM() / 1024) + " kb");
		}
		*/
		if (!this.runtime.isLoadingState)
		{
			this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutEnd, null);
		}
		this.runtime.isEndingLayout = true;
		cr.clearArray(this.runtime.system.waits);
		var i, leni, j, lenj;
		var layer_instances, inst, type;
		if (!this.first_visit)
		{
			for (i = 0, leni = this.layers.length; i < leni; i++)
			{
				this.layers[i].updateZIndices();
				layer_instances = this.layers[i].instances;
				for (j = 0, lenj = layer_instances.length; j < lenj; j++)
				{
					inst = layer_instances[j];
					if (!inst.type.global)
					{
						if (this.runtime.typeHasPersistBehavior(inst.type))
							this.saveObjectToPersist(inst);
					}
				}
			}
		}
		for (i = 0, leni = this.layers.length; i < leni; i++)
		{
			layer_instances = this.layers[i].instances;
			for (j = 0, lenj = layer_instances.length; j < lenj; j++)
			{
				inst = layer_instances[j];
				if (!inst.type.global)
				{
					this.runtime.DestroyInstance(inst);
				}
			}
			this.runtime.ClearDeathRow();
			cr.clearArray(layer_instances);
			this.layers[i].zindices_stale = true;
		}
		for (i = 0, leni = this.runtime.types_by_index.length; i < leni; i++)
		{
			type = this.runtime.types_by_index[i];
			if (type.global || type.plugin.is_world || type.plugin.singleglobal || type.is_family)
				continue;
			for (j = 0, lenj = type.instances.length; j < lenj; j++)
				this.runtime.DestroyInstance(type.instances[j]);
			this.runtime.ClearDeathRow();
		}
		first_layout = false;
		this.runtime.isEndingLayout = false;
	};
	var temp_rect = new cr.rect(0, 0, 0, 0);
	Layout.prototype.recreateInitialObjects = function (type, x1, y1, x2, y2)
	{
		temp_rect.set(x1, y1, x2, y2);
		var i, len;
		for (i = 0, len = this.layers.length; i < len; i++)
		{
			this.layers[i].recreateInitialObjects(type, temp_rect);
		}
	};
	Layout.prototype.draw = function (ctx)
	{
		var layout_canvas;
		var layout_ctx = ctx;
		var ctx_changed = false;
		var render_offscreen = !this.runtime.fullscreenScalingQuality;
		if (render_offscreen)
		{
			if (!this.runtime.layout_canvas)
			{
				this.runtime.layout_canvas = document.createElement("canvas");
				layout_canvas = this.runtime.layout_canvas;
				layout_canvas.width = this.runtime.draw_width;
				layout_canvas.height = this.runtime.draw_height;
				this.runtime.layout_ctx = layout_canvas.getContext("2d");
				ctx_changed = true;
			}
			layout_canvas = this.runtime.layout_canvas;
			layout_ctx = this.runtime.layout_ctx;
			if (layout_canvas.width !== this.runtime.draw_width)
			{
				layout_canvas.width = this.runtime.draw_width;
				ctx_changed = true;
			}
			if (layout_canvas.height !== this.runtime.draw_height)
			{
				layout_canvas.height = this.runtime.draw_height;
				ctx_changed = true;
			}
			if (ctx_changed)
			{
				this.runtime.setCtxImageSmoothingEnabled(layout_ctx, this.runtime.linearSampling);
			}
		}
		layout_ctx.globalAlpha = 1;
		layout_ctx.globalCompositeOperation = "source-over";
		if (this.runtime.alphaBackground && !this.hasOpaqueBottomLayer())
			layout_ctx.clearRect(0, 0, this.runtime.draw_width, this.runtime.draw_height);
		var i, len, l;
		for (i = 0, len = this.layers.length; i < len; i++)
		{
			l = this.layers[i];
			if (l.visible && l.opacity > 0 && l.blend_mode !== 11 && (l.instances.length || !l.transparent))
				l.draw(layout_ctx);
			else
				l.updateViewport(null);		// even if not drawing, keep viewport up to date
		}
		if (render_offscreen)
		{
			ctx.drawImage(layout_canvas, 0, 0, this.runtime.width, this.runtime.height);
		}
	};
	Layout.prototype.drawGL_earlyZPass = function (glw)
	{
		glw.setEarlyZPass(true);
		if (!this.runtime.layout_tex)
		{
			this.runtime.layout_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
		}
		if (this.runtime.layout_tex.c2width !== this.runtime.draw_width || this.runtime.layout_tex.c2height !== this.runtime.draw_height)
		{
			glw.deleteTexture(this.runtime.layout_tex);
			this.runtime.layout_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
		}
		glw.setRenderingToTexture(this.runtime.layout_tex);
		if (!this.runtime.fullscreenScalingQuality)
		{
			glw.setSize(this.runtime.draw_width, this.runtime.draw_height);
		}
		var i, l;
		for (i = this.layers.length - 1; i >= 0; --i)
		{
			l = this.layers[i];
			if (l.visible && l.opacity === 1 && l.shaders_preserve_opaqueness &&
				l.blend_mode === 0 && (l.instances.length || !l.transparent))
			{
				l.drawGL_earlyZPass(glw);
			}
			else
			{
				l.updateViewport(null);		// even if not drawing, keep viewport up to date
			}
		}
		glw.setEarlyZPass(false);
	};
	Layout.prototype.drawGL = function (glw)
	{
		var render_to_texture = (this.active_effect_types.length > 0 ||
								 this.runtime.uses_background_blending ||
								 !this.runtime.fullscreenScalingQuality ||
								 this.runtime.enableFrontToBack);
		if (render_to_texture)
		{
			if (!this.runtime.layout_tex)
			{
				this.runtime.layout_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
			}
			if (this.runtime.layout_tex.c2width !== this.runtime.draw_width || this.runtime.layout_tex.c2height !== this.runtime.draw_height)
			{
				glw.deleteTexture(this.runtime.layout_tex);
				this.runtime.layout_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
			}
			glw.setRenderingToTexture(this.runtime.layout_tex);
			if (!this.runtime.fullscreenScalingQuality)
			{
				glw.setSize(this.runtime.draw_width, this.runtime.draw_height);
			}
		}
		else
		{
			if (this.runtime.layout_tex)
			{
				glw.setRenderingToTexture(null);
				glw.deleteTexture(this.runtime.layout_tex);
				this.runtime.layout_tex = null;
			}
		}
		if (this.runtime.alphaBackground && !this.hasOpaqueBottomLayer())
			glw.clear(0, 0, 0, 0);
		var i, len, l;
		for (i = 0, len = this.layers.length; i < len; i++)
		{
			l = this.layers[i];
			if (l.visible && l.opacity > 0 && (l.instances.length || !l.transparent))
				l.drawGL(glw);
			else
				l.updateViewport(null);		// even if not drawing, keep viewport up to date
		}
		if (render_to_texture)
		{
			if (this.active_effect_types.length === 0 ||
				(this.active_effect_types.length === 1 && this.runtime.fullscreenScalingQuality))
			{
				if (this.active_effect_types.length === 1)
				{
					var etindex = this.active_effect_types[0].index;
					glw.switchProgram(this.active_effect_types[0].shaderindex);
					glw.setProgramParameters(null,								// backTex
											 1.0 / this.runtime.draw_width,		// pixelWidth
											 1.0 / this.runtime.draw_height,	// pixelHeight
											 0.0, 0.0,							// destStart
											 1.0, 1.0,							// destEnd
											 this.scale,						// layerScale
											 this.angle,						// layerAngle
											 0.0, 0.0,							// viewOrigin
											 this.runtime.draw_width / 2, this.runtime.draw_height / 2,	// scrollPos
											 this.runtime.kahanTime.sum,		// seconds
											 this.effect_params[etindex]);		// fx parameters
					if (glw.programIsAnimated(this.active_effect_types[0].shaderindex))
						this.runtime.redraw = true;
				}
				else
					glw.switchProgram(0);
				if (!this.runtime.fullscreenScalingQuality)
				{
					glw.setSize(this.runtime.width, this.runtime.height);
				}
				glw.setRenderingToTexture(null);				// to backbuffer
				glw.setDepthTestEnabled(false);					// ignore depth buffer, copy full texture
				glw.setOpacity(1);
				glw.setTexture(this.runtime.layout_tex);
				glw.setAlphaBlend();
				glw.resetModelView();
				glw.updateModelView();
				var halfw = this.runtime.width / 2;
				var halfh = this.runtime.height / 2;
				glw.quad(-halfw, halfh, halfw, halfh, halfw, -halfh, -halfw, -halfh);
				glw.setTexture(null);
				glw.setDepthTestEnabled(true);					// turn depth test back on
			}
			else
			{
				this.renderEffectChain(glw, null, null, null);
			}
		}
	};
	Layout.prototype.getRenderTarget = function()
	{
		if (this.active_effect_types.length > 0 ||
				this.runtime.uses_background_blending ||
				!this.runtime.fullscreenScalingQuality ||
				this.runtime.enableFrontToBack)
		{
			return this.runtime.layout_tex;
		}
		else
		{
			return null;
		}
	};
	Layout.prototype.getMinLayerScale = function ()
	{
		var m = this.layers[0].getScale();
		var i, len, l;
		for (i = 1, len = this.layers.length; i < len; i++)
		{
			l = this.layers[i];
			if (l.parallaxX === 0 && l.parallaxY === 0)
				continue;
			if (l.getScale() < m)
				m = l.getScale();
		}
		return m;
	};
	Layout.prototype.scrollToX = function (x)
	{
		if (!this.unbounded_scrolling)
		{
			var widthBoundary = (this.runtime.draw_width * (1 / this.getMinLayerScale()) / 2);
			if (x > this.width - widthBoundary)
				x = this.width - widthBoundary;
			if (x < widthBoundary)
				x = widthBoundary;
		}
		if (this.scrollX !== x)
		{
			this.scrollX = x;
			this.runtime.redraw = true;
		}
	};
	Layout.prototype.scrollToY = function (y)
	{
		if (!this.unbounded_scrolling)
		{
			var heightBoundary = (this.runtime.draw_height * (1 / this.getMinLayerScale()) / 2);
			if (y > this.height - heightBoundary)
				y = this.height - heightBoundary;
			if (y < heightBoundary)
				y = heightBoundary;
		}
		if (this.scrollY !== y)
		{
			this.scrollY = y;
			this.runtime.redraw = true;
		}
	};
	Layout.prototype.boundScrolling = function ()
	{
		this.scrollToX(this.scrollX);
		this.scrollToY(this.scrollY);
	};
	Layout.prototype.renderEffectChain = function (glw, layer, inst, rendertarget)
	{
		var active_effect_types = inst ?
							inst.active_effect_types :
							layer ?
								layer.active_effect_types :
								this.active_effect_types;
		var layerScale = 1, layerAngle = 0, viewOriginLeft = 0, viewOriginTop = 0, viewOriginRight = this.runtime.draw_width, viewOriginBottom = this.runtime.draw_height;
		if (inst)
		{
			layerScale = inst.layer.getScale();
			layerAngle = inst.layer.getAngle();
			viewOriginLeft = inst.layer.viewLeft;
			viewOriginTop = inst.layer.viewTop;
			viewOriginRight = inst.layer.viewRight;
			viewOriginBottom = inst.layer.viewBottom;
		}
		else if (layer)
		{
			layerScale = layer.getScale();
			layerAngle = layer.getAngle();
			viewOriginLeft = layer.viewLeft;
			viewOriginTop = layer.viewTop;
			viewOriginRight = layer.viewRight;
			viewOriginBottom = layer.viewBottom;
		}
		var fx_tex = this.runtime.fx_tex;
		var i, len, last, temp, fx_index = 0, other_fx_index = 1;
		var y, h;
		var windowWidth = this.runtime.draw_width;
		var windowHeight = this.runtime.draw_height;
		var halfw = windowWidth / 2;
		var halfh = windowHeight / 2;
		var rcTex = layer ? layer.rcTex : this.rcTex;
		var rcTex2 = layer ? layer.rcTex2 : this.rcTex2;
		var screenleft = 0, clearleft = 0;
		var screentop = 0, cleartop = 0;
		var screenright = windowWidth, clearright = windowWidth;
		var screenbottom = windowHeight, clearbottom = windowHeight;
		var boxExtendHorizontal = 0;
		var boxExtendVertical = 0;
		var inst_layer_angle = inst ? inst.layer.getAngle() : 0;
		if (inst)
		{
			for (i = 0, len = active_effect_types.length; i < len; i++)
			{
				boxExtendHorizontal += glw.getProgramBoxExtendHorizontal(active_effect_types[i].shaderindex);
				boxExtendVertical += glw.getProgramBoxExtendVertical(active_effect_types[i].shaderindex);
			}
			var bbox = inst.bbox;
			screenleft = layer.layerToCanvas(bbox.left, bbox.top, true, true);
			screentop = layer.layerToCanvas(bbox.left, bbox.top, false, true);
			screenright = layer.layerToCanvas(bbox.right, bbox.bottom, true, true);
			screenbottom = layer.layerToCanvas(bbox.right, bbox.bottom, false, true);
			if (inst_layer_angle !== 0)
			{
				var screentrx = layer.layerToCanvas(bbox.right, bbox.top, true, true);
				var screentry = layer.layerToCanvas(bbox.right, bbox.top, false, true);
				var screenblx = layer.layerToCanvas(bbox.left, bbox.bottom, true, true);
				var screenbly = layer.layerToCanvas(bbox.left, bbox.bottom, false, true);
				temp = Math.min(screenleft, screenright, screentrx, screenblx);
				screenright = Math.max(screenleft, screenright, screentrx, screenblx);
				screenleft = temp;
				temp = Math.min(screentop, screenbottom, screentry, screenbly);
				screenbottom = Math.max(screentop, screenbottom, screentry, screenbly);
				screentop = temp;
			}
			screenleft -= boxExtendHorizontal;
			screentop -= boxExtendVertical;
			screenright += boxExtendHorizontal;
			screenbottom += boxExtendVertical;
			rcTex2.left = screenleft / windowWidth;
			rcTex2.top = 1 - screentop / windowHeight;
			rcTex2.right = screenright / windowWidth;
			rcTex2.bottom = 1 - screenbottom / windowHeight;
			clearleft = screenleft = cr.floor(screenleft);
			cleartop = screentop = cr.floor(screentop);
			clearright = screenright = cr.ceil(screenright);
			clearbottom = screenbottom = cr.ceil(screenbottom);
			clearleft -= boxExtendHorizontal;
			cleartop -= boxExtendVertical;
			clearright += boxExtendHorizontal;
			clearbottom += boxExtendVertical;
			if (screenleft < 0)					screenleft = 0;
			if (screentop < 0)					screentop = 0;
			if (screenright > windowWidth)		screenright = windowWidth;
			if (screenbottom > windowHeight)	screenbottom = windowHeight;
			if (clearleft < 0)					clearleft = 0;
			if (cleartop < 0)					cleartop = 0;
			if (clearright > windowWidth)		clearright = windowWidth;
			if (clearbottom > windowHeight)		clearbottom = windowHeight;
			rcTex.left = screenleft / windowWidth;
			rcTex.top = 1 - screentop / windowHeight;
			rcTex.right = screenright / windowWidth;
			rcTex.bottom = 1 - screenbottom / windowHeight;
		}
		else
		{
			rcTex.left = rcTex2.left = 0;
			rcTex.top = rcTex2.top = 0;
			rcTex.right = rcTex2.right = 1;
			rcTex.bottom = rcTex2.bottom = 1;
		}
		var pre_draw = (inst && (glw.programUsesDest(active_effect_types[0].shaderindex) || boxExtendHorizontal !== 0 || boxExtendVertical !== 0 || inst.opacity !== 1 || inst.type.plugin.must_predraw)) || (layer && !inst && layer.opacity !== 1);
		glw.setAlphaBlend();
		if (pre_draw)
		{
			if (!fx_tex[fx_index])
			{
				fx_tex[fx_index] = glw.createEmptyTexture(windowWidth, windowHeight, this.runtime.linearSampling);
			}
			if (fx_tex[fx_index].c2width !== windowWidth || fx_tex[fx_index].c2height !== windowHeight)
			{
				glw.deleteTexture(fx_tex[fx_index]);
				fx_tex[fx_index] = glw.createEmptyTexture(windowWidth, windowHeight, this.runtime.linearSampling);
			}
			glw.switchProgram(0);
			glw.setRenderingToTexture(fx_tex[fx_index]);
			h = clearbottom - cleartop;
			y = (windowHeight - cleartop) - h;
			glw.clearRect(clearleft, y, clearright - clearleft, h);
			if (inst)
			{
				inst.drawGL(glw);
			}
			else
			{
				glw.setTexture(this.runtime.layer_tex);
				glw.setOpacity(layer.opacity);
				glw.resetModelView();
				glw.translate(-halfw, -halfh);
				glw.updateModelView();
				glw.quadTex(screenleft, screenbottom, screenright, screenbottom, screenright, screentop, screenleft, screentop, rcTex);
			}
			rcTex2.left = rcTex2.top = 0;
			rcTex2.right = rcTex2.bottom = 1;
			if (inst)
			{
				temp = rcTex.top;
				rcTex.top = rcTex.bottom;
				rcTex.bottom = temp;
			}
			fx_index = 1;
			other_fx_index = 0;
		}
		glw.setOpacity(1);
		var last = active_effect_types.length - 1;
		var post_draw = glw.programUsesCrossSampling(active_effect_types[last].shaderindex) ||
						(!layer && !inst && !this.runtime.fullscreenScalingQuality);
		var etindex = 0;
		for (i = 0, len = active_effect_types.length; i < len; i++)
		{
			if (!fx_tex[fx_index])
			{
				fx_tex[fx_index] = glw.createEmptyTexture(windowWidth, windowHeight, this.runtime.linearSampling);
			}
			if (fx_tex[fx_index].c2width !== windowWidth || fx_tex[fx_index].c2height !== windowHeight)
			{
				glw.deleteTexture(fx_tex[fx_index]);
				fx_tex[fx_index] = glw.createEmptyTexture(windowWidth, windowHeight, this.runtime.linearSampling);
			}
			glw.switchProgram(active_effect_types[i].shaderindex);
			etindex = active_effect_types[i].index;
			if (glw.programIsAnimated(active_effect_types[i].shaderindex))
				this.runtime.redraw = true;
			if (i == 0 && !pre_draw)
			{
				glw.setRenderingToTexture(fx_tex[fx_index]);
				h = clearbottom - cleartop;
				y = (windowHeight - cleartop) - h;
				glw.clearRect(clearleft, y, clearright - clearleft, h);
				if (inst)
				{
					var pixelWidth;
					var pixelHeight;
					if (inst.curFrame && inst.curFrame.texture_img)
					{
						var img = inst.curFrame.texture_img;
						pixelWidth = 1.0 / img.width;
						pixelHeight = 1.0 / img.height;
					}
					else
					{
						pixelWidth = 1.0 / inst.width;
						pixelHeight = 1.0 / inst.height;
					}
					glw.setProgramParameters(rendertarget,					// backTex
											 pixelWidth,
											 pixelHeight,
											 rcTex2.left, rcTex2.top,		// destStart
											 rcTex2.right, rcTex2.bottom,	// destEnd
											 layerScale,
											 layerAngle,
											 viewOriginLeft, viewOriginTop,
											 (viewOriginLeft + viewOriginRight) / 2, (viewOriginTop + viewOriginBottom) / 2,
											 this.runtime.kahanTime.sum,
											 inst.effect_params[etindex]);	// fx params
					inst.drawGL(glw);
				}
				else
				{
					glw.setProgramParameters(rendertarget,					// backTex
											 1.0 / windowWidth,				// pixelWidth
											 1.0 / windowHeight,			// pixelHeight
											 0.0, 0.0,						// destStart
											 1.0, 1.0,						// destEnd
											 layerScale,
											 layerAngle,
											 viewOriginLeft, viewOriginTop,
											 (viewOriginLeft + viewOriginRight) / 2, (viewOriginTop + viewOriginBottom) / 2,
											 this.runtime.kahanTime.sum,
											 layer ?						// fx params
												layer.effect_params[etindex] :
												this.effect_params[etindex]);
					glw.setTexture(layer ? this.runtime.layer_tex : this.runtime.layout_tex);
					glw.resetModelView();
					glw.translate(-halfw, -halfh);
					glw.updateModelView();
					glw.quadTex(screenleft, screenbottom, screenright, screenbottom, screenright, screentop, screenleft, screentop, rcTex);
				}
				rcTex2.left = rcTex2.top = 0;
				rcTex2.right = rcTex2.bottom = 1;
				if (inst && !post_draw)
				{
					temp = screenbottom;
					screenbottom = screentop;
					screentop = temp;
				}
			}
			else
			{
				glw.setProgramParameters(rendertarget,						// backTex
										 1.0 / windowWidth,					// pixelWidth
										 1.0 / windowHeight,				// pixelHeight
										 rcTex2.left, rcTex2.top,			// destStart
										 rcTex2.right, rcTex2.bottom,		// destEnd
										 layerScale,
										 layerAngle,
										 viewOriginLeft, viewOriginTop,
										 (viewOriginLeft + viewOriginRight) / 2, (viewOriginTop + viewOriginBottom) / 2,
										 this.runtime.kahanTime.sum,
										 inst ?								// fx params
											inst.effect_params[etindex] :
											layer ?
												layer.effect_params[etindex] :
												this.effect_params[etindex]);
				glw.setTexture(null);
				if (i === last && !post_draw)
				{
					if (inst)
						glw.setBlend(inst.srcBlend, inst.destBlend);
					else if (layer)
						glw.setBlend(layer.srcBlend, layer.destBlend);
					glw.setRenderingToTexture(rendertarget);
				}
				else
				{
					glw.setRenderingToTexture(fx_tex[fx_index]);
					h = clearbottom - cleartop;
					y = (windowHeight - cleartop) - h;
					glw.clearRect(clearleft, y, clearright - clearleft, h);
				}
				glw.setTexture(fx_tex[other_fx_index]);
				glw.resetModelView();
				glw.translate(-halfw, -halfh);
				glw.updateModelView();
				glw.quadTex(screenleft, screenbottom, screenright, screenbottom, screenright, screentop, screenleft, screentop, rcTex);
				if (i === last && !post_draw)
					glw.setTexture(null);
			}
			fx_index = (fx_index === 0 ? 1 : 0);
			other_fx_index = (fx_index === 0 ? 1 : 0);		// will be opposite to fx_index since it was just assigned
		}
		if (post_draw)
		{
			glw.switchProgram(0);
			if (inst)
				glw.setBlend(inst.srcBlend, inst.destBlend);
			else if (layer)
				glw.setBlend(layer.srcBlend, layer.destBlend);
			else
			{
				if (!this.runtime.fullscreenScalingQuality)
				{
					glw.setSize(this.runtime.width, this.runtime.height);
					halfw = this.runtime.width / 2;
					halfh = this.runtime.height / 2;
					screenleft = 0;
					screentop = 0;
					screenright = this.runtime.width;
					screenbottom = this.runtime.height;
				}
			}
			glw.setRenderingToTexture(rendertarget);
			glw.setTexture(fx_tex[other_fx_index]);
			glw.resetModelView();
			glw.translate(-halfw, -halfh);
			glw.updateModelView();
			if (inst && active_effect_types.length === 1 && !pre_draw)
				glw.quadTex(screenleft, screentop, screenright, screentop, screenright, screenbottom, screenleft, screenbottom, rcTex);
			else
				glw.quadTex(screenleft, screenbottom, screenright, screenbottom, screenright, screentop, screenleft, screentop, rcTex);
			glw.setTexture(null);
		}
	};
	Layout.prototype.getLayerBySid = function (sid_)
	{
		var i, len;
		for (i = 0, len = this.layers.length; i < len; i++)
		{
			if (this.layers[i].sid === sid_)
				return this.layers[i];
		}
		return null;
	};
	Layout.prototype.saveToJSON = function ()
	{
		var i, len, layer, et;
		var o = {
			"sx": this.scrollX,
			"sy": this.scrollY,
			"s": this.scale,
			"a": this.angle,
			"w": this.width,
			"h": this.height,
			"fv": this.first_visit,			// added r127
			"persist": this.persist_data,
			"fx": [],
			"layers": {}
		};
		for (i = 0, len = this.effect_types.length; i < len; i++)
		{
			et = this.effect_types[i];
			o["fx"].push({"name": et.name, "active": et.active, "params": this.effect_params[et.index] });
		}
		for (i = 0, len = this.layers.length; i < len; i++)
		{
			layer = this.layers[i];
			o["layers"][layer.sid.toString()] = layer.saveToJSON();
		}
		return o;
	};
	Layout.prototype.loadFromJSON = function (o)
	{
		var i, j, len, fx, p, layer;
		this.scrollX = o["sx"];
		this.scrollY = o["sy"];
		this.scale = o["s"];
		this.angle = o["a"];
		this.width = o["w"];
		this.height = o["h"];
		this.persist_data = o["persist"];
		if (typeof o["fv"] !== "undefined")
			this.first_visit = o["fv"];
		var ofx = o["fx"];
		for (i = 0, len = ofx.length; i < len; i++)
		{
			fx = this.getEffectByName(ofx[i]["name"]);
			if (!fx)
				continue;		// must've gone missing
			fx.active = ofx[i]["active"];
			this.effect_params[fx.index] = ofx[i]["params"];
		}
		this.updateActiveEffects();
		var olayers = o["layers"];
		for (p in olayers)
		{
			if (olayers.hasOwnProperty(p))
			{
				layer = this.getLayerBySid(parseInt(p, 10));
				if (!layer)
					continue;		// must've gone missing
				layer.loadFromJSON(olayers[p]);
			}
		}
	};
	cr.layout = Layout;
	function Layer(layout, m)
	{
		this.layout = layout;
		this.runtime = layout.runtime;
		this.instances = [];        // running instances
		this.scale = 1.0;
		this.angle = 0;
		this.disableAngle = false;
		this.tmprect = new cr.rect(0, 0, 0, 0);
		this.tmpquad = new cr.quad();
		this.viewLeft = 0;
		this.viewRight = 0;
		this.viewTop = 0;
		this.viewBottom = 0;
		this.zindices_stale = false;
		this.zindices_stale_from = -1;		// first index that has changed, or -1 if no bound
		this.clear_earlyz_index = 0;
		this.name = m[0];
		this.index = m[1];
		this.sid = m[2];
		this.visible = m[3];		// initially visible
		this.background_color = m[4];
		this.transparent = m[5];
		this.parallaxX = m[6];
		this.parallaxY = m[7];
		this.opacity = m[8];
		this.forceOwnTexture = m[9];
		this.useRenderCells = m[10];
		this.zoomRate = m[11];
		this.blend_mode = m[12];
		this.effect_fallback = m[13];
		this.compositeOp = "source-over";
		this.srcBlend = 0;
		this.destBlend = 0;
		this.render_grid = null;
		this.last_render_list = alloc_arr();
		this.render_list_stale = true;
		this.last_render_cells = new cr.rect(0, 0, -1, -1);
		this.cur_render_cells = new cr.rect(0, 0, -1, -1);
		if (this.useRenderCells)
		{
			this.render_grid = new cr.RenderGrid(this.runtime.original_width, this.runtime.original_height);
		}
		this.render_offscreen = false;
		var im = m[14];
		var i, len;
		this.startup_initial_instances = [];		// for restoring initial_instances after load
		this.initial_instances = [];
		this.created_globals = [];		// global object UIDs already created - for save/load to avoid recreating
		for (i = 0, len = im.length; i < len; i++)
		{
			var inst = im[i];
			var type = this.runtime.types_by_index[inst[1]];
;
			if (!type.default_instance)
			{
				type.default_instance = inst;
				type.default_layerindex = this.index;
			}
			this.initial_instances.push(inst);
			if (this.layout.initial_types.indexOf(type) === -1)
				this.layout.initial_types.push(type);
		}
		cr.shallowAssignArray(this.startup_initial_instances, this.initial_instances);
		this.effect_types = [];
		this.active_effect_types = [];
		this.shaders_preserve_opaqueness = true;
		this.effect_params = [];
		for (i = 0, len = m[15].length; i < len; i++)
		{
			this.effect_types.push({
				id: m[15][i][0],
				name: m[15][i][1],
				shaderindex: -1,
				preservesOpaqueness: false,
				active: true,
				index: i
			});
			this.effect_params.push(m[15][i][2].slice(0));
		}
		this.updateActiveEffects();
		this.rcTex = new cr.rect(0, 0, 1, 1);
		this.rcTex2 = new cr.rect(0, 0, 1, 1);
	};
	Layer.prototype.updateActiveEffects = function ()
	{
		cr.clearArray(this.active_effect_types);
		this.shaders_preserve_opaqueness = true;
		var i, len, et;
		for (i = 0, len = this.effect_types.length; i < len; i++)
		{
			et = this.effect_types[i];
			if (et.active)
			{
				this.active_effect_types.push(et);
				if (!et.preservesOpaqueness)
					this.shaders_preserve_opaqueness = false;
			}
		}
	};
	Layer.prototype.getEffectByName = function (name_)
	{
		var i, len, et;
		for (i = 0, len = this.effect_types.length; i < len; i++)
		{
			et = this.effect_types[i];
			if (et.name === name_)
				return et;
		}
		return null;
	};
	Layer.prototype.createInitialInstances = function ()
	{
		var i, k, len, inst, initial_inst, type, keep, hasPersistBehavior;
		for (i = 0, k = 0, len = this.initial_instances.length; i < len; i++)
		{
			initial_inst = this.initial_instances[i];
			type = this.runtime.types_by_index[initial_inst[1]];
;
			hasPersistBehavior = this.runtime.typeHasPersistBehavior(type);
			keep = true;
			if (!hasPersistBehavior || this.layout.first_visit)
			{
				inst = this.runtime.createInstanceFromInit(initial_inst, this, true);
				if (!inst)
					continue;		// may have skipped creation due to fallback effect "destroy"
				created_instances.push(inst);
				if (inst.type.global)
				{
					keep = false;
					this.created_globals.push(inst.uid);
				}
			}
			if (keep)
			{
				this.initial_instances[k] = this.initial_instances[i];
				k++;
			}
		}
		this.initial_instances.length = k;
		this.runtime.ClearDeathRow();		// flushes creation row so IIDs will be correct
		if (!this.runtime.glwrap && this.effect_types.length)	// no WebGL renderer and shaders used
			this.blend_mode = this.effect_fallback;				// use fallback blend mode
		this.compositeOp = cr.effectToCompositeOp(this.blend_mode);
		if (this.runtime.gl)
			cr.setGLBlend(this, this.blend_mode, this.runtime.gl);
		this.render_list_stale = true;
	};
	Layer.prototype.recreateInitialObjects = function (only_type, rc)
	{
		var i, len, initial_inst, type, wm, x, y, inst, j, lenj, s;
		var types_by_index = this.runtime.types_by_index;
		var only_type_is_family = only_type.is_family;
		var only_type_members = only_type.members;
		for (i = 0, len = this.initial_instances.length; i < len; ++i)
		{
			initial_inst = this.initial_instances[i];
			wm = initial_inst[0];
			x = wm[0];
			y = wm[1];
			if (!rc.contains_pt(x, y))
				continue;		// not in the given area
			type = types_by_index[initial_inst[1]];
			if (type !== only_type)
			{
				if (only_type_is_family)
				{
					if (only_type_members.indexOf(type) < 0)
						continue;
				}
				else
					continue;		// only_type is not a family, and the initial inst type does not match
			}
			inst = this.runtime.createInstanceFromInit(initial_inst, this, false);
			this.runtime.isInOnDestroy++;
			this.runtime.trigger(Object.getPrototypeOf(type.plugin).cnds.OnCreated, inst);
			if (inst.is_contained)
			{
				for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
				{
					s = inst.siblings[i];
					this.runtime.trigger(Object.getPrototypeOf(s.type.plugin).cnds.OnCreated, s);
				}
			}
			this.runtime.isInOnDestroy--;
		}
	};
	Layer.prototype.removeFromInstanceList = function (inst, remove_from_grid)
	{
		var index = cr.fastIndexOf(this.instances, inst);
		if (index < 0)
			return;		// not found
		if (remove_from_grid && this.useRenderCells && inst.rendercells && inst.rendercells.right >= inst.rendercells.left)
		{
			inst.update_bbox();											// make sure actually in its current rendercells
			this.render_grid.update(inst, inst.rendercells, null);		// no new range provided - remove only
			inst.rendercells.set(0, 0, -1, -1);							// set to invalid state to indicate not inserted
		}
		if (index === this.instances.length - 1)
			this.instances.pop();
		else
		{
			cr.arrayRemove(this.instances, index);
			this.setZIndicesStaleFrom(index);
		}
		this.render_list_stale = true;
	};
	Layer.prototype.appendToInstanceList = function (inst, add_to_grid)
	{
;
		inst.zindex = this.instances.length;
		this.instances.push(inst);
		if (add_to_grid && this.useRenderCells && inst.rendercells)
		{
			inst.set_bbox_changed();		// will cause immediate update and new insertion to grid
		}
		this.render_list_stale = true;
	};
	Layer.prototype.prependToInstanceList = function (inst, add_to_grid)
	{
;
		this.instances.unshift(inst);
		this.setZIndicesStaleFrom(0);
		if (add_to_grid && this.useRenderCells && inst.rendercells)
		{
			inst.set_bbox_changed();		// will cause immediate update and new insertion to grid
		}
	};
	Layer.prototype.moveInstanceAdjacent = function (inst, other, isafter)
	{
;
		var myZ = inst.get_zindex();
		var insertZ = other.get_zindex();
		cr.arrayRemove(this.instances, myZ);
		if (myZ < insertZ)
			insertZ--;
		if (isafter)
			insertZ++;
		if (insertZ === this.instances.length)
			this.instances.push(inst);
		else
			this.instances.splice(insertZ, 0, inst);
		this.setZIndicesStaleFrom(myZ < insertZ ? myZ : insertZ);
	};
	Layer.prototype.setZIndicesStaleFrom = function (index)
	{
		if (this.zindices_stale_from === -1)			// not yet set
			this.zindices_stale_from = index;
		else if (index < this.zindices_stale_from)		// determine minimum z index affected
			this.zindices_stale_from = index;
		this.zindices_stale = true;
		this.render_list_stale = true;
	};
	Layer.prototype.updateZIndices = function ()
	{
		if (!this.zindices_stale)
			return;
		if (this.zindices_stale_from === -1)
			this.zindices_stale_from = 0;
		var i, len, inst;
		if (this.useRenderCells)
		{
			for (i = this.zindices_stale_from, len = this.instances.length; i < len; ++i)
			{
				inst = this.instances[i];
				inst.zindex = i;
				this.render_grid.markRangeChanged(inst.rendercells);
			}
		}
		else
		{
			for (i = this.zindices_stale_from, len = this.instances.length; i < len; ++i)
			{
				this.instances[i].zindex = i;
			}
		}
		this.zindices_stale = false;
		this.zindices_stale_from = -1;
	};
	Layer.prototype.getScale = function (include_aspect)
	{
		return this.getNormalScale() * (this.runtime.fullscreenScalingQuality || include_aspect ? this.runtime.aspect_scale : 1);
	};
	Layer.prototype.getNormalScale = function ()
	{
		return ((this.scale * this.layout.scale) - 1) * this.zoomRate + 1;
	};
	Layer.prototype.getAngle = function ()
	{
		if (this.disableAngle)
			return 0;
		return cr.clamp_angle(this.layout.angle + this.angle);
	};
	var arr_cache = [];
	function alloc_arr()
	{
		if (arr_cache.length)
			return arr_cache.pop();
		else
			return [];
	}
	function free_arr(a)
	{
		cr.clearArray(a);
		arr_cache.push(a);
	};
	function mergeSortedZArrays(a, b, out)
	{
		var i = 0, j = 0, k = 0, lena = a.length, lenb = b.length, ai, bj;
		out.length = lena + lenb;
		for ( ; i < lena && j < lenb; ++k)
		{
			ai = a[i];
			bj = b[j];
			if (ai.zindex < bj.zindex)
			{
				out[k] = ai;
				++i;
			}
			else
			{
				out[k] = bj;
				++j;
			}
		}
		for ( ; i < lena; ++i, ++k)
			out[k] = a[i];
		for ( ; j < lenb; ++j, ++k)
			out[k] = b[j];
	};
	var next_arr = [];
	function mergeAllSortedZArrays_pass(arr, first_pass)
	{
		var i, len, arr1, arr2, out;
		for (i = 0, len = arr.length; i < len - 1; i += 2)
		{
			arr1 = arr[i];
			arr2 = arr[i+1];
			out = alloc_arr();
			mergeSortedZArrays(arr1, arr2, out);
			if (!first_pass)
			{
				free_arr(arr1);
				free_arr(arr2);
			}
			next_arr.push(out);
		}
		if (len % 2 === 1)
		{
			if (first_pass)
			{
				arr1 = alloc_arr();
				cr.shallowAssignArray(arr1, arr[len - 1]);
				next_arr.push(arr1);
			}
			else
			{
				next_arr.push(arr[len - 1]);
			}
		}
		cr.shallowAssignArray(arr, next_arr);
		cr.clearArray(next_arr);
	};
	function mergeAllSortedZArrays(arr)
	{
		var first_pass = true;
		while (arr.length > 1)
		{
			mergeAllSortedZArrays_pass(arr, first_pass);
			first_pass = false;
		}
		return arr[0];
	};
	var render_arr = [];
	Layer.prototype.getRenderCellInstancesToDraw = function ()
	{
;
		this.updateZIndices();
		this.render_grid.queryRange(this.viewLeft, this.viewTop, this.viewRight, this.viewBottom, render_arr);
		if (!render_arr.length)
			return alloc_arr();
		if (render_arr.length === 1)
		{
			var a = alloc_arr();
			cr.shallowAssignArray(a, render_arr[0]);
			cr.clearArray(render_arr);
			return a;
		}
		var draw_list = mergeAllSortedZArrays(render_arr);
		cr.clearArray(render_arr);
		return draw_list;
	};
	Layer.prototype.draw = function (ctx)
	{
		this.render_offscreen = (this.forceOwnTexture || this.opacity !== 1.0 || this.blend_mode !== 0);
		var layer_canvas = this.runtime.canvas;
		var layer_ctx = ctx;
		var ctx_changed = false;
		if (this.render_offscreen)
		{
			if (!this.runtime.layer_canvas)
			{
				this.runtime.layer_canvas = document.createElement("canvas");
;
				layer_canvas = this.runtime.layer_canvas;
				layer_canvas.width = this.runtime.draw_width;
				layer_canvas.height = this.runtime.draw_height;
				this.runtime.layer_ctx = layer_canvas.getContext("2d");
;
				ctx_changed = true;
			}
			layer_canvas = this.runtime.layer_canvas;
			layer_ctx = this.runtime.layer_ctx;
			if (layer_canvas.width !== this.runtime.draw_width)
			{
				layer_canvas.width = this.runtime.draw_width;
				ctx_changed = true;
			}
			if (layer_canvas.height !== this.runtime.draw_height)
			{
				layer_canvas.height = this.runtime.draw_height;
				ctx_changed = true;
			}
			if (ctx_changed)
			{
				this.runtime.setCtxImageSmoothingEnabled(layer_ctx, this.runtime.linearSampling);
			}
			if (this.transparent)
				layer_ctx.clearRect(0, 0, this.runtime.draw_width, this.runtime.draw_height);
		}
		layer_ctx.globalAlpha = 1;
		layer_ctx.globalCompositeOperation = "source-over";
		if (!this.transparent)
		{
			layer_ctx.fillStyle = "rgb(" + this.background_color[0] + "," + this.background_color[1] + "," + this.background_color[2] + ")";
			layer_ctx.fillRect(0, 0, this.runtime.draw_width, this.runtime.draw_height);
		}
		layer_ctx.save();
		this.disableAngle = true;
		var px = this.canvasToLayer(0, 0, true, true);
		var py = this.canvasToLayer(0, 0, false, true);
		this.disableAngle = false;
		if (this.runtime.pixel_rounding)
		{
			px = Math.round(px);
			py = Math.round(py);
		}
		this.rotateViewport(px, py, layer_ctx);
		var myscale = this.getScale();
		layer_ctx.scale(myscale, myscale);
		layer_ctx.translate(-px, -py);
		var instances_to_draw;
		if (this.useRenderCells)
		{
			this.cur_render_cells.left = this.render_grid.XToCell(this.viewLeft);
			this.cur_render_cells.top = this.render_grid.YToCell(this.viewTop);
			this.cur_render_cells.right = this.render_grid.XToCell(this.viewRight);
			this.cur_render_cells.bottom = this.render_grid.YToCell(this.viewBottom);
			if (this.render_list_stale || !this.cur_render_cells.equals(this.last_render_cells))
			{
				free_arr(this.last_render_list);
				instances_to_draw = this.getRenderCellInstancesToDraw();
				this.render_list_stale = false;
				this.last_render_cells.copy(this.cur_render_cells);
			}
			else
				instances_to_draw = this.last_render_list;
		}
		else
			instances_to_draw = this.instances;
		var i, len, inst, last_inst = null;
		for (i = 0, len = instances_to_draw.length; i < len; ++i)
		{
			inst = instances_to_draw[i];
			if (inst === last_inst)
				continue;
			this.drawInstance(inst, layer_ctx);
			last_inst = inst;
		}
		if (this.useRenderCells)
			this.last_render_list = instances_to_draw;
		layer_ctx.restore();
		if (this.render_offscreen)
		{
			ctx.globalCompositeOperation = this.compositeOp;
			ctx.globalAlpha = this.opacity;
			ctx.drawImage(layer_canvas, 0, 0);
		}
	};
	Layer.prototype.drawInstance = function(inst, layer_ctx)
	{
		if (!inst.visible || inst.width === 0 || inst.height === 0)
			return;
		inst.update_bbox();
		var bbox = inst.bbox;
		if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
			return;
		layer_ctx.globalCompositeOperation = inst.compositeOp;
		inst.draw(layer_ctx);
	};
	Layer.prototype.updateViewport = function (ctx)
	{
		this.disableAngle = true;
		var px = this.canvasToLayer(0, 0, true, true);
		var py = this.canvasToLayer(0, 0, false, true);
		this.disableAngle = false;
		if (this.runtime.pixel_rounding)
		{
			px = Math.round(px);
			py = Math.round(py);
		}
		this.rotateViewport(px, py, ctx);
	};
	Layer.prototype.rotateViewport = function (px, py, ctx)
	{
		var myscale = this.getScale();
		this.viewLeft = px;
		this.viewTop = py;
		this.viewRight = px + (this.runtime.draw_width * (1 / myscale));
		this.viewBottom = py + (this.runtime.draw_height * (1 / myscale));
		var temp;
		if (this.viewLeft > this.viewRight)
		{
			temp = this.viewLeft;
			this.viewLeft = this.viewRight;
			this.viewRight = temp;
		}
		if (this.viewTop > this.viewBottom)
		{
			temp = this.viewTop;
			this.viewTop = this.viewBottom;
			this.viewBottom = temp;
		}
		var myAngle = this.getAngle();
		if (myAngle !== 0)
		{
			if (ctx)
			{
				ctx.translate(this.runtime.draw_width / 2, this.runtime.draw_height / 2);
				ctx.rotate(-myAngle);
				ctx.translate(this.runtime.draw_width / -2, this.runtime.draw_height / -2);
			}
			this.tmprect.set(this.viewLeft, this.viewTop, this.viewRight, this.viewBottom);
			this.tmprect.offset((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
			this.tmpquad.set_from_rotated_rect(this.tmprect, myAngle);
			this.tmpquad.bounding_box(this.tmprect);
			this.tmprect.offset((this.viewLeft + this.viewRight) / 2, (this.viewTop + this.viewBottom) / 2);
			this.viewLeft = this.tmprect.left;
			this.viewTop = this.tmprect.top;
			this.viewRight = this.tmprect.right;
			this.viewBottom = this.tmprect.bottom;
		}
	}
	Layer.prototype.drawGL_earlyZPass = function (glw)
	{
		var windowWidth = this.runtime.draw_width;
		var windowHeight = this.runtime.draw_height;
		var shaderindex = 0;
		var etindex = 0;
		this.render_offscreen = this.forceOwnTexture;
		if (this.render_offscreen)
		{
			if (!this.runtime.layer_tex)
			{
				this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
			}
			if (this.runtime.layer_tex.c2width !== this.runtime.draw_width || this.runtime.layer_tex.c2height !== this.runtime.draw_height)
			{
				glw.deleteTexture(this.runtime.layer_tex);
				this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
			}
			glw.setRenderingToTexture(this.runtime.layer_tex);
		}
		this.disableAngle = true;
		var px = this.canvasToLayer(0, 0, true, true);
		var py = this.canvasToLayer(0, 0, false, true);
		this.disableAngle = false;
		if (this.runtime.pixel_rounding)
		{
			px = Math.round(px);
			py = Math.round(py);
		}
		this.rotateViewport(px, py, null);
		var myscale = this.getScale();
		glw.resetModelView();
		glw.scale(myscale, myscale);
		glw.rotateZ(-this.getAngle());
		glw.translate((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
		glw.updateModelView();
		var instances_to_draw;
		if (this.useRenderCells)
		{
			this.cur_render_cells.left = this.render_grid.XToCell(this.viewLeft);
			this.cur_render_cells.top = this.render_grid.YToCell(this.viewTop);
			this.cur_render_cells.right = this.render_grid.XToCell(this.viewRight);
			this.cur_render_cells.bottom = this.render_grid.YToCell(this.viewBottom);
			if (this.render_list_stale || !this.cur_render_cells.equals(this.last_render_cells))
			{
				free_arr(this.last_render_list);
				instances_to_draw = this.getRenderCellInstancesToDraw();
				this.render_list_stale = false;
				this.last_render_cells.copy(this.cur_render_cells);
			}
			else
				instances_to_draw = this.last_render_list;
		}
		else
			instances_to_draw = this.instances;
		var i, inst, last_inst = null;
		for (i = instances_to_draw.length - 1; i >= 0; --i)
		{
			inst = instances_to_draw[i];
			if (inst === last_inst)
				continue;
			this.drawInstanceGL_earlyZPass(instances_to_draw[i], glw);
			last_inst = inst;
		}
		if (this.useRenderCells)
			this.last_render_list = instances_to_draw;
		if (!this.transparent)
		{
			this.clear_earlyz_index = this.runtime.earlyz_index++;
			glw.setEarlyZIndex(this.clear_earlyz_index);
			glw.setColorFillMode(1, 1, 1, 1);
			glw.fullscreenQuad();		// fill remaining space in depth buffer with current Z value
			glw.restoreEarlyZMode();
		}
	};
	Layer.prototype.drawGL = function (glw)
	{
		var windowWidth = this.runtime.draw_width;
		var windowHeight = this.runtime.draw_height;
		var shaderindex = 0;
		var etindex = 0;
		this.render_offscreen = (this.forceOwnTexture || this.opacity !== 1.0 || this.active_effect_types.length > 0 || this.blend_mode !== 0);
		if (this.render_offscreen)
		{
			if (!this.runtime.layer_tex)
			{
				this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
			}
			if (this.runtime.layer_tex.c2width !== this.runtime.draw_width || this.runtime.layer_tex.c2height !== this.runtime.draw_height)
			{
				glw.deleteTexture(this.runtime.layer_tex);
				this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.draw_width, this.runtime.draw_height, this.runtime.linearSampling);
			}
			glw.setRenderingToTexture(this.runtime.layer_tex);
			if (this.transparent)
				glw.clear(0, 0, 0, 0);
		}
		if (!this.transparent)
		{
			if (this.runtime.enableFrontToBack)
			{
				glw.setEarlyZIndex(this.clear_earlyz_index);
				glw.setColorFillMode(this.background_color[0] / 255, this.background_color[1] / 255, this.background_color[2] / 255, 1);
				glw.fullscreenQuad();
				glw.setTextureFillMode();
			}
			else
			{
				glw.clear(this.background_color[0] / 255, this.background_color[1] / 255, this.background_color[2] / 255, 1);
			}
		}
		this.disableAngle = true;
		var px = this.canvasToLayer(0, 0, true, true);
		var py = this.canvasToLayer(0, 0, false, true);
		this.disableAngle = false;
		if (this.runtime.pixel_rounding)
		{
			px = Math.round(px);
			py = Math.round(py);
		}
		this.rotateViewport(px, py, null);
		var myscale = this.getScale();
		glw.resetModelView();
		glw.scale(myscale, myscale);
		glw.rotateZ(-this.getAngle());
		glw.translate((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
		glw.updateModelView();
		var instances_to_draw;
		if (this.useRenderCells)
		{
			this.cur_render_cells.left = this.render_grid.XToCell(this.viewLeft);
			this.cur_render_cells.top = this.render_grid.YToCell(this.viewTop);
			this.cur_render_cells.right = this.render_grid.XToCell(this.viewRight);
			this.cur_render_cells.bottom = this.render_grid.YToCell(this.viewBottom);
			if (this.render_list_stale || !this.cur_render_cells.equals(this.last_render_cells))
			{
				free_arr(this.last_render_list);
				instances_to_draw = this.getRenderCellInstancesToDraw();
				this.render_list_stale = false;
				this.last_render_cells.copy(this.cur_render_cells);
			}
			else
				instances_to_draw = this.last_render_list;
		}
		else
			instances_to_draw = this.instances;
		var i, len, inst, last_inst = null;
		for (i = 0, len = instances_to_draw.length; i < len; ++i)
		{
			inst = instances_to_draw[i];
			if (inst === last_inst)
				continue;
			this.drawInstanceGL(instances_to_draw[i], glw);
			last_inst = inst;
		}
		if (this.useRenderCells)
			this.last_render_list = instances_to_draw;
		if (this.render_offscreen)
		{
			shaderindex = this.active_effect_types.length ? this.active_effect_types[0].shaderindex : 0;
			etindex = this.active_effect_types.length ? this.active_effect_types[0].index : 0;
			if (this.active_effect_types.length === 0 || (this.active_effect_types.length === 1 &&
				!glw.programUsesCrossSampling(shaderindex) && this.opacity === 1))
			{
				if (this.active_effect_types.length === 1)
				{
					glw.switchProgram(shaderindex);
					glw.setProgramParameters(this.layout.getRenderTarget(),		// backTex
											 1.0 / this.runtime.draw_width,		// pixelWidth
											 1.0 / this.runtime.draw_height,	// pixelHeight
											 0.0, 0.0,							// destStart
											 1.0, 1.0,							// destEnd
											 myscale,							// layerScale
											 this.getAngle(),
											 this.viewLeft, this.viewTop,
											 (this.viewLeft + this.viewRight) / 2, (this.viewTop + this.viewBottom) / 2,
											 this.runtime.kahanTime.sum,
											 this.effect_params[etindex]);		// fx parameters
					if (glw.programIsAnimated(shaderindex))
						this.runtime.redraw = true;
				}
				else
					glw.switchProgram(0);
				glw.setRenderingToTexture(this.layout.getRenderTarget());
				glw.setOpacity(this.opacity);
				glw.setTexture(this.runtime.layer_tex);
				glw.setBlend(this.srcBlend, this.destBlend);
				glw.resetModelView();
				glw.updateModelView();
				var halfw = this.runtime.draw_width / 2;
				var halfh = this.runtime.draw_height / 2;
				glw.quad(-halfw, halfh, halfw, halfh, halfw, -halfh, -halfw, -halfh);
				glw.setTexture(null);
			}
			else
			{
				this.layout.renderEffectChain(glw, this, null, this.layout.getRenderTarget());
			}
		}
	};
	Layer.prototype.drawInstanceGL = function (inst, glw)
	{
;
		if (!inst.visible || inst.width === 0 || inst.height === 0)
			return;
		inst.update_bbox();
		var bbox = inst.bbox;
		if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
			return;
		glw.setEarlyZIndex(inst.earlyz_index);
		if (inst.uses_shaders)
		{
			this.drawInstanceWithShadersGL(inst, glw);
		}
		else
		{
			glw.switchProgram(0);		// un-set any previously set shader
			glw.setBlend(inst.srcBlend, inst.destBlend);
			inst.drawGL(glw);
		}
	};
	Layer.prototype.drawInstanceGL_earlyZPass = function (inst, glw)
	{
;
		if (!inst.visible || inst.width === 0 || inst.height === 0)
			return;
		inst.update_bbox();
		var bbox = inst.bbox;
		if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
			return;
		inst.earlyz_index = this.runtime.earlyz_index++;
		if (inst.blend_mode !== 0 || inst.opacity !== 1 || !inst.shaders_preserve_opaqueness || !inst.drawGL_earlyZPass)
			return;
		glw.setEarlyZIndex(inst.earlyz_index);
		inst.drawGL_earlyZPass(glw);
	};
	Layer.prototype.drawInstanceWithShadersGL = function (inst, glw)
	{
		var shaderindex = inst.active_effect_types[0].shaderindex;
		var etindex = inst.active_effect_types[0].index;
		var myscale = this.getScale();
		if (inst.active_effect_types.length === 1 && !glw.programUsesCrossSampling(shaderindex) &&
			!glw.programExtendsBox(shaderindex) && ((!inst.angle && !inst.layer.getAngle()) || !glw.programUsesDest(shaderindex)) &&
			inst.opacity === 1 && !inst.type.plugin.must_predraw)
		{
			glw.switchProgram(shaderindex);
			glw.setBlend(inst.srcBlend, inst.destBlend);
			if (glw.programIsAnimated(shaderindex))
				this.runtime.redraw = true;
			var destStartX = 0, destStartY = 0, destEndX = 0, destEndY = 0;
			if (glw.programUsesDest(shaderindex))
			{
				var bbox = inst.bbox;
				var screenleft = this.layerToCanvas(bbox.left, bbox.top, true, true);
				var screentop = this.layerToCanvas(bbox.left, bbox.top, false, true);
				var screenright = this.layerToCanvas(bbox.right, bbox.bottom, true, true);
				var screenbottom = this.layerToCanvas(bbox.right, bbox.bottom, false, true);
				destStartX = screenleft / windowWidth;
				destStartY = 1 - screentop / windowHeight;
				destEndX = screenright / windowWidth;
				destEndY = 1 - screenbottom / windowHeight;
			}
			var pixelWidth;
			var pixelHeight;
			if (inst.curFrame && inst.curFrame.texture_img)
			{
				var img = inst.curFrame.texture_img;
				pixelWidth = 1.0 / img.width;
				pixelHeight = 1.0 / img.height;
			}
			else
			{
				pixelWidth = 1.0 / inst.width;
				pixelHeight = 1.0 / inst.height;
			}
			glw.setProgramParameters(this.render_offscreen ? this.runtime.layer_tex : this.layout.getRenderTarget(), // backTex
									 pixelWidth,
									 pixelHeight,
									 destStartX, destStartY,
									 destEndX, destEndY,
									 myscale,
									 this.getAngle(),
									 this.viewLeft, this.viewTop,
									 (this.viewLeft + this.viewRight) / 2, (this.viewTop + this.viewBottom) / 2,
									 this.runtime.kahanTime.sum,
									 inst.effect_params[etindex]);
			inst.drawGL(glw);
		}
		else
		{
			this.layout.renderEffectChain(glw, this, inst, this.render_offscreen ? this.runtime.layer_tex : this.layout.getRenderTarget());
			glw.resetModelView();
			glw.scale(myscale, myscale);
			glw.rotateZ(-this.getAngle());
			glw.translate((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
			glw.updateModelView();
		}
	};
	Layer.prototype.canvasToLayer = function (ptx, pty, getx, using_draw_area)
	{
		var multiplier = this.runtime.devicePixelRatio;
		if (this.runtime.isRetina)
		{
			ptx *= multiplier;
			pty *= multiplier;
		}
		var ox = this.runtime.parallax_x_origin;
		var oy = this.runtime.parallax_y_origin;
		var par_x = ((this.layout.scrollX - ox) * this.parallaxX) + ox;
		var par_y = ((this.layout.scrollY - oy) * this.parallaxY) + oy;
		var x = par_x;
		var y = par_y;
		var invScale = 1 / this.getScale(!using_draw_area);
		if (using_draw_area)
		{
			x -= (this.runtime.draw_width * invScale) / 2;
			y -= (this.runtime.draw_height * invScale) / 2;
		}
		else
		{
			x -= (this.runtime.width * invScale) / 2;
			y -= (this.runtime.height * invScale) / 2;
		}
		x += ptx * invScale;
		y += pty * invScale;
		var a = this.getAngle();
		if (a !== 0)
		{
			x -= par_x;
			y -= par_y;
			var cosa = Math.cos(a);
			var sina = Math.sin(a);
			var x_temp = (x * cosa) - (y * sina);
			y = (y * cosa) + (x * sina);
			x = x_temp;
			x += par_x;
			y += par_y;
		}
		return getx ? x : y;
	};
	Layer.prototype.layerToCanvas = function (ptx, pty, getx, using_draw_area)
	{
		var ox = this.runtime.parallax_x_origin;
		var oy = this.runtime.parallax_y_origin;
		var par_x = ((this.layout.scrollX - ox) * this.parallaxX) + ox;
		var par_y = ((this.layout.scrollY - oy) * this.parallaxY) + oy;
		var x = par_x;
		var y = par_y;
		var a = this.getAngle();
		if (a !== 0)
		{
			ptx -= par_x;
			pty -= par_y;
			var cosa = Math.cos(-a);
			var sina = Math.sin(-a);
			var x_temp = (ptx * cosa) - (pty * sina);
			pty = (pty * cosa) + (ptx * sina);
			ptx = x_temp;
			ptx += par_x;
			pty += par_y;
		}
		var invScale = 1 / this.getScale(!using_draw_area);
		if (using_draw_area)
		{
			x -= (this.runtime.draw_width * invScale) / 2;
			y -= (this.runtime.draw_height * invScale) / 2;
		}
		else
		{
			x -= (this.runtime.width * invScale) / 2;
			y -= (this.runtime.height * invScale) / 2;
		}
		x = (ptx - x) / invScale;
		y = (pty - y) / invScale;
		var multiplier = this.runtime.devicePixelRatio;
		if (this.runtime.isRetina && !using_draw_area)
		{
			x /= multiplier;
			y /= multiplier;
		}
		return getx ? x : y;
	};
	Layer.prototype.rotatePt = function (x_, y_, getx)
	{
		if (this.getAngle() === 0)
			return getx ? x_ : y_;
		var nx = this.layerToCanvas(x_, y_, true);
		var ny = this.layerToCanvas(x_, y_, false);
		this.disableAngle = true;
		var px = this.canvasToLayer(nx, ny, true);
		var py = this.canvasToLayer(nx, ny, true);
		this.disableAngle = false;
		return getx ? px : py;
	};
	Layer.prototype.saveToJSON = function ()
	{
		var i, len, et;
		var o = {
			"s": this.scale,
			"a": this.angle,
			"vl": this.viewLeft,
			"vt": this.viewTop,
			"vr": this.viewRight,
			"vb": this.viewBottom,
			"v": this.visible,
			"bc": this.background_color,
			"t": this.transparent,
			"px": this.parallaxX,
			"py": this.parallaxY,
			"o": this.opacity,
			"zr": this.zoomRate,
			"fx": [],
			"cg": this.created_globals,		// added r197; list of global UIDs already created
			"instances": []
		};
		for (i = 0, len = this.effect_types.length; i < len; i++)
		{
			et = this.effect_types[i];
			o["fx"].push({"name": et.name, "active": et.active, "params": this.effect_params[et.index] });
		}
		return o;
	};
	Layer.prototype.loadFromJSON = function (o)
	{
		var i, j, len, p, inst, fx;
		this.scale = o["s"];
		this.angle = o["a"];
		this.viewLeft = o["vl"];
		this.viewTop = o["vt"];
		this.viewRight = o["vr"];
		this.viewBottom = o["vb"];
		this.visible = o["v"];
		this.background_color = o["bc"];
		this.transparent = o["t"];
		this.parallaxX = o["px"];
		this.parallaxY = o["py"];
		this.opacity = o["o"];
		this.zoomRate = o["zr"];
		this.created_globals = o["cg"] || [];		// added r197
		cr.shallowAssignArray(this.initial_instances, this.startup_initial_instances);
		var temp_set = new cr.ObjectSet();
		for (i = 0, len = this.created_globals.length; i < len; ++i)
			temp_set.add(this.created_globals[i]);
		for (i = 0, j = 0, len = this.initial_instances.length; i < len; ++i)
		{
			if (!temp_set.contains(this.initial_instances[i][2]))		// UID in element 2
			{
				this.initial_instances[j] = this.initial_instances[i];
				++j;
			}
		}
		cr.truncateArray(this.initial_instances, j);
		var ofx = o["fx"];
		for (i = 0, len = ofx.length; i < len; i++)
		{
			fx = this.getEffectByName(ofx[i]["name"]);
			if (!fx)
				continue;		// must've gone missing
			fx.active = ofx[i]["active"];
			this.effect_params[fx.index] = ofx[i]["params"];
		}
		this.updateActiveEffects();
		this.instances.sort(sort_by_zindex);
		this.zindices_stale = true;
	};
	cr.layer = Layer;
}());
;
(function()
{
	var allUniqueSolModifiers = [];
	function testSolsMatch(arr1, arr2)
	{
		var i, len = arr1.length;
		switch (len) {
		case 0:
			return true;
		case 1:
			return arr1[0] === arr2[0];
		case 2:
			return arr1[0] === arr2[0] && arr1[1] === arr2[1];
		default:
			for (i = 0; i < len; i++)
			{
				if (arr1[i] !== arr2[i])
					return false;
			}
			return true;
		}
	};
	function solArraySorter(t1, t2)
	{
		return t1.index - t2.index;
	};
	function findMatchingSolModifier(arr)
	{
		var i, len, u, temp, subarr;
		if (arr.length === 2)
		{
			if (arr[0].index > arr[1].index)
			{
				temp = arr[0];
				arr[0] = arr[1];
				arr[1] = temp;
			}
		}
		else if (arr.length > 2)
			arr.sort(solArraySorter);		// so testSolsMatch compares in same order
		if (arr.length >= allUniqueSolModifiers.length)
			allUniqueSolModifiers.length = arr.length + 1;
		if (!allUniqueSolModifiers[arr.length])
			allUniqueSolModifiers[arr.length] = [];
		subarr = allUniqueSolModifiers[arr.length];
		for (i = 0, len = subarr.length; i < len; i++)
		{
			u = subarr[i];
			if (testSolsMatch(arr, u))
				return u;
		}
		subarr.push(arr);
		return arr;
	};
	function EventSheet(runtime, m)
	{
		this.runtime = runtime;
		this.triggers = {};
		this.fasttriggers = {};
        this.hasRun = false;
        this.includes = new cr.ObjectSet(); 	// all event sheets included by this sheet, at first-level indirection only
		this.deep_includes = [];				// all includes from this sheet recursively, in trigger order
		this.already_included_sheets = [];		// used while building deep_includes
		this.name = m[0];
		var em = m[1];		// events model
		this.events = [];       // triggers won't make it to this array
		var i, len;
		for (i = 0, len = em.length; i < len; i++)
			this.init_event(em[i], null, this.events);
	};
    EventSheet.prototype.toString = function ()
    {
        return this.name;
    };
	EventSheet.prototype.init_event = function (m, parent, nontriggers)
	{
		switch (m[0]) {
		case 0:	// event block
		{
			var block = new cr.eventblock(this, parent, m);
			cr.seal(block);
			if (block.orblock)
			{
				nontriggers.push(block);
				var i, len;
				for (i = 0, len = block.conditions.length; i < len; i++)
				{
					if (block.conditions[i].trigger)
						this.init_trigger(block, i);
				}
			}
			else
			{
				if (block.is_trigger())
					this.init_trigger(block, 0);
				else
					nontriggers.push(block);
			}
			break;
		}
		case 1: // variable
		{
			var v = new cr.eventvariable(this, parent, m);
			cr.seal(v);
			nontriggers.push(v);
			break;
		}
        case 2:	// include
        {
            var inc = new cr.eventinclude(this, parent, m);
			cr.seal(inc);
            nontriggers.push(inc);
			break;
        }
		default:
;
		}
	};
	EventSheet.prototype.postInit = function ()
	{
		var i, len;
		for (i = 0, len = this.events.length; i < len; i++)
		{
			this.events[i].postInit(i < len - 1 && this.events[i + 1].is_else_block);
		}
	};
	EventSheet.prototype.updateDeepIncludes = function ()
	{
		cr.clearArray(this.deep_includes);
		cr.clearArray(this.already_included_sheets);
		this.addDeepIncludes(this);
		cr.clearArray(this.already_included_sheets);
	};
	EventSheet.prototype.addDeepIncludes = function (root_sheet)
	{
		var i, len, inc, sheet;
		var deep_includes = root_sheet.deep_includes;
		var already_included_sheets = root_sheet.already_included_sheets;
		var arr = this.includes.valuesRef();
		for (i = 0, len = arr.length; i < len; ++i)
		{
			inc = arr[i];
			sheet = inc.include_sheet;
			if (!inc.isActive() || root_sheet === sheet || already_included_sheets.indexOf(sheet) > -1)
				continue;
			already_included_sheets.push(sheet);
			sheet.addDeepIncludes(root_sheet);
			deep_includes.push(sheet);
		}
	};
	EventSheet.prototype.run = function (from_include)
	{
		if (!this.runtime.resuming_breakpoint)
		{
			this.hasRun = true;
			if (!from_include)
				this.runtime.isRunningEvents = true;
		}
		var i, len;
		for (i = 0, len = this.events.length; i < len; i++)
		{
			var ev = this.events[i];
			ev.run();
				this.runtime.clearSol(ev.solModifiers);
				if (this.runtime.hasPendingInstances)
					this.runtime.ClearDeathRow();
		}
			if (!from_include)
				this.runtime.isRunningEvents = false;
	};
	function isPerformanceSensitiveTrigger(method)
	{
		if (cr.plugins_.Sprite && method === cr.plugins_.Sprite.prototype.cnds.OnFrameChanged)
		{
			return true;
		}
		return false;
	};
	EventSheet.prototype.init_trigger = function (trig, index)
	{
		if (!trig.orblock)
			this.runtime.triggers_to_postinit.push(trig);	// needs to be postInit'd later
		var i, len;
		var cnd = trig.conditions[index];
		var type_name;
		if (cnd.type)
			type_name = cnd.type.name;
		else
			type_name = "system";
		var fasttrigger = cnd.fasttrigger;
		var triggers = (fasttrigger ? this.fasttriggers : this.triggers);
		if (!triggers[type_name])
			triggers[type_name] = [];
		var obj_entry = triggers[type_name];
		var method = cnd.func;
		if (fasttrigger)
		{
			if (!cnd.parameters.length)				// no parameters
				return;
			var firstparam = cnd.parameters[0];
			if (firstparam.type !== 1 ||			// not a string param
				firstparam.expression.type !== 2)	// not a string literal node
			{
				return;
			}
			var fastevs;
			var firstvalue = firstparam.expression.value.toLowerCase();
			var i, len;
			for (i = 0, len = obj_entry.length; i < len; i++)
			{
				if (obj_entry[i].method == method)
				{
					fastevs = obj_entry[i].evs;
					if (!fastevs[firstvalue])
						fastevs[firstvalue] = [[trig, index]];
					else
						fastevs[firstvalue].push([trig, index]);
					return;
				}
			}
			fastevs = {};
			fastevs[firstvalue] = [[trig, index]];
			obj_entry.push({ method: method, evs: fastevs });
		}
		else
		{
			for (i = 0, len = obj_entry.length; i < len; i++)
			{
				if (obj_entry[i].method == method)
				{
					obj_entry[i].evs.push([trig, index]);
					return;
				}
			}
			if (isPerformanceSensitiveTrigger(method))
				obj_entry.unshift({ method: method, evs: [[trig, index]]});
			else
				obj_entry.push({ method: method, evs: [[trig, index]]});
		}
	};
	cr.eventsheet = EventSheet;
	function Selection(type)
	{
		this.type = type;
		this.instances = [];        // subset of picked instances
		this.else_instances = [];	// subset of unpicked instances
		this.select_all = true;
	};
	Selection.prototype.hasObjects = function ()
	{
		if (this.select_all)
			return this.type.instances.length;
		else
			return this.instances.length;
	};
	Selection.prototype.getObjects = function ()
	{
		if (this.select_all)
			return this.type.instances;
		else
			return this.instances;
	};
	/*
	Selection.prototype.ensure_picked = function (inst, skip_siblings)
	{
		var i, len;
		var orblock = inst.runtime.getCurrentEventStack().current_event.orblock;
		if (this.select_all)
		{
			this.select_all = false;
			if (orblock)
			{
				cr.shallowAssignArray(this.else_instances, inst.type.instances);
				cr.arrayFindRemove(this.else_instances, inst);
			}
			this.instances.length = 1;
			this.instances[0] = inst;
		}
		else
		{
			if (orblock)
			{
				i = this.else_instances.indexOf(inst);
				if (i !== -1)
				{
					this.instances.push(this.else_instances[i]);
					this.else_instances.splice(i, 1);
				}
			}
			else
			{
				if (this.instances.indexOf(inst) === -1)
					this.instances.push(inst);
			}
		}
		if (!skip_siblings)
		{
		}
	};
	*/
	Selection.prototype.pick_one = function (inst)
	{
		if (!inst)
			return;
		if (inst.runtime.getCurrentEventStack().current_event.orblock)
		{
			if (this.select_all)
			{
				cr.clearArray(this.instances);
				cr.shallowAssignArray(this.else_instances, inst.type.instances);
				this.select_all = false;
			}
			var i = this.else_instances.indexOf(inst);
			if (i !== -1)
			{
				this.instances.push(this.else_instances[i]);
				this.else_instances.splice(i, 1);
			}
		}
		else
		{
			this.select_all = false;
			cr.clearArray(this.instances);
			this.instances[0] = inst;
		}
	};
	cr.selection = Selection;
	function EventBlock(sheet, parent, m)
	{
		this.sheet = sheet;
		this.parent = parent;
		this.runtime = sheet.runtime;
		this.solModifiers = [];
		this.solModifiersIncludingParents = [];
		this.solWriterAfterCnds = false;	// block does not change SOL after running its conditions
		this.group = false;					// is group of events
		this.initially_activated = false;	// if a group, is active on startup
		this.toplevelevent = false;			// is an event block parented only by a top-level group
		this.toplevelgroup = false;			// is parented only by other groups or is top-level (i.e. not in a subevent)
		this.has_else_block = false;		// is followed by else
;
		this.conditions = [];
		this.actions = [];
		this.subevents = [];
		this.group_name = "";
		this.group = false;
		this.initially_activated = false;
		this.group_active = false;
		this.contained_includes = null;
        if (m[1])
        {
			this.group_name = m[1][1].toLowerCase();
			this.group = true;
			this.initially_activated = !!m[1][0];
			this.contained_includes = [];
			this.group_active = this.initially_activated;
			this.runtime.allGroups.push(this);
            this.runtime.groups_by_name[this.group_name] = this;
        }
		this.orblock = m[2];
		this.sid = m[4];
		if (!this.group)
			this.runtime.blocksBySid[this.sid.toString()] = this;
		var i, len;
		var cm = m[5];
		for (i = 0, len = cm.length; i < len; i++)
		{
			var cnd = new cr.condition(this, cm[i]);
			cnd.index = i;
			cr.seal(cnd);
			this.conditions.push(cnd);
			/*
			if (cnd.is_logical())
				this.is_logical = true;
			if (cnd.type && !cnd.type.plugin.singleglobal && this.cndReferences.indexOf(cnd.type) === -1)
				this.cndReferences.push(cnd.type);
			*/
			this.addSolModifier(cnd.type);
		}
		var am = m[6];
		for (i = 0, len = am.length; i < len; i++)
		{
			var act = new cr.action(this, am[i]);
			act.index = i;
			cr.seal(act);
			this.actions.push(act);
		}
		if (m.length === 8)
		{
			var em = m[7];
			for (i = 0, len = em.length; i < len; i++)
				this.sheet.init_event(em[i], this, this.subevents);
		}
		this.is_else_block = false;
		if (this.conditions.length)
		{
			this.is_else_block = (this.conditions[0].type == null && this.conditions[0].func == cr.system_object.prototype.cnds.Else);
		}
	};
	window["_c2hh_"] = "AFD9024689912DAA7C47F1633DDEEDC463DB26DF";
	EventBlock.prototype.postInit = function (hasElse/*, prevBlock_*/)
	{
		var i, len;
		var p = this.parent;
		if (this.group)
		{
			this.toplevelgroup = true;
			while (p)
			{
				if (!p.group)
				{
					this.toplevelgroup = false;
					break;
				}
				p = p.parent;
			}
		}
		this.toplevelevent = !this.is_trigger() && (!this.parent || (this.parent.group && this.parent.toplevelgroup));
		this.has_else_block = !!hasElse;
		this.solModifiersIncludingParents = this.solModifiers.slice(0);
		p = this.parent;
		while (p)
		{
			for (i = 0, len = p.solModifiers.length; i < len; i++)
				this.addParentSolModifier(p.solModifiers[i]);
			p = p.parent;
		}
		this.solModifiers = findMatchingSolModifier(this.solModifiers);
		this.solModifiersIncludingParents = findMatchingSolModifier(this.solModifiersIncludingParents);
		var i, len/*, s*/;
		for (i = 0, len = this.conditions.length; i < len; i++)
			this.conditions[i].postInit();
		for (i = 0, len = this.actions.length; i < len; i++)
			this.actions[i].postInit();
		for (i = 0, len = this.subevents.length; i < len; i++)
		{
			this.subevents[i].postInit(i < len - 1 && this.subevents[i + 1].is_else_block);
		}
		/*
		if (this.is_else_block && this.prev_block)
		{
			for (i = 0, len = this.prev_block.solModifiers.length; i < len; i++)
			{
				s = this.prev_block.solModifiers[i];
				if (this.solModifiers.indexOf(s) === -1)
					this.solModifiers.push(s);
			}
		}
		*/
	};
	EventBlock.prototype.setGroupActive = function (a)
	{
		if (this.group_active === !!a)
			return;		// same state
		this.group_active = !!a;
		var i, len;
		for (i = 0, len = this.contained_includes.length; i < len; ++i)
		{
			this.contained_includes[i].updateActive();
		}
		if (len > 0 && this.runtime.running_layout.event_sheet)
			this.runtime.running_layout.event_sheet.updateDeepIncludes();
	};
	function addSolModifierToList(type, arr)
	{
		var i, len, t;
		if (!type)
			return;
		if (arr.indexOf(type) === -1)
			arr.push(type);
		if (type.is_contained)
		{
			for (i = 0, len = type.container.length; i < len; i++)
			{
				t = type.container[i];
				if (type === t)
					continue;		// already handled
				if (arr.indexOf(t) === -1)
					arr.push(t);
			}
		}
	};
	EventBlock.prototype.addSolModifier = function (type)
	{
		addSolModifierToList(type, this.solModifiers);
	};
	EventBlock.prototype.addParentSolModifier = function (type)
	{
		addSolModifierToList(type, this.solModifiersIncludingParents);
	};
	EventBlock.prototype.setSolWriterAfterCnds = function ()
	{
		this.solWriterAfterCnds = true;
		if (this.parent)
			this.parent.setSolWriterAfterCnds();
	};
	EventBlock.prototype.is_trigger = function ()
	{
		if (!this.conditions.length)    // no conditions
			return false;
		else
			return this.conditions[0].trigger;
	};
	EventBlock.prototype.run = function ()
	{
		var i, len, c, any_true = false, cnd_result;
		var runtime = this.runtime;
		var evinfo = this.runtime.getCurrentEventStack();
		evinfo.current_event = this;
		var conditions = this.conditions;
			if (!this.is_else_block)
				evinfo.else_branch_ran = false;
		if (this.orblock)
		{
			if (conditions.length === 0)
				any_true = true;		// be sure to run if empty block
				evinfo.cndindex = 0
			for (len = conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
			{
				c = conditions[evinfo.cndindex];
				if (c.trigger)		// skip triggers when running OR block
					continue;
				cnd_result = c.run();
				if (cnd_result)			// make sure all conditions run and run if any were true
					any_true = true;
			}
			evinfo.last_event_true = any_true;
			if (any_true)
				this.run_actions_and_subevents();
		}
		else
		{
				evinfo.cndindex = 0
			for (len = conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
			{
				cnd_result = conditions[evinfo.cndindex].run();
				if (!cnd_result)    // condition failed
				{
					evinfo.last_event_true = false;
					if (this.toplevelevent && runtime.hasPendingInstances)
						runtime.ClearDeathRow();
					return;		// bail out now
				}
			}
			evinfo.last_event_true = true;
			this.run_actions_and_subevents();
		}
		this.end_run(evinfo);
	};
	EventBlock.prototype.end_run = function (evinfo)
	{
		if (evinfo.last_event_true && this.has_else_block)
			evinfo.else_branch_ran = true;
		if (this.toplevelevent && this.runtime.hasPendingInstances)
			this.runtime.ClearDeathRow();
	};
	EventBlock.prototype.run_orblocktrigger = function (index)
	{
		var evinfo = this.runtime.getCurrentEventStack();
		evinfo.current_event = this;
		if (this.conditions[index].run())
		{
			this.run_actions_and_subevents();
			this.runtime.getCurrentEventStack().last_event_true = true;
		}
	};
	EventBlock.prototype.run_actions_and_subevents = function ()
	{
		var evinfo = this.runtime.getCurrentEventStack();
		var len;
		for (evinfo.actindex = 0, len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
		{
			if (this.actions[evinfo.actindex].run())
				return;
		}
		this.run_subevents();
	};
	EventBlock.prototype.resume_actions_and_subevents = function ()
	{
		var evinfo = this.runtime.getCurrentEventStack();
		var len;
		for (len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
		{
			if (this.actions[evinfo.actindex].run())
				return;
		}
		this.run_subevents();
	};
	EventBlock.prototype.run_subevents = function ()
	{
		if (!this.subevents.length)
			return;
		var i, len, subev, pushpop/*, skipped_pop = false, pop_modifiers = null*/;
		var last = this.subevents.length - 1;
			this.runtime.pushEventStack(this);
		if (this.solWriterAfterCnds)
		{
			for (i = 0, len = this.subevents.length; i < len; i++)
			{
				subev = this.subevents[i];
					pushpop = (!this.toplevelgroup || (!this.group && i < last));
					if (pushpop)
						this.runtime.pushCopySol(subev.solModifiers);
				subev.run();
					if (pushpop)
						this.runtime.popSol(subev.solModifiers);
					else
						this.runtime.clearSol(subev.solModifiers);
			}
		}
		else
		{
			for (i = 0, len = this.subevents.length; i < len; i++)
			{
				this.subevents[i].run();
			}
		}
			this.runtime.popEventStack();
	};
	EventBlock.prototype.run_pretrigger = function ()
	{
		var evinfo = this.runtime.getCurrentEventStack();
		evinfo.current_event = this;
		var any_true = false;
		var i, len;
		for (evinfo.cndindex = 0, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
		{
;
			if (this.conditions[evinfo.cndindex].run())
				any_true = true;
			else if (!this.orblock)			// condition failed (let OR blocks run all conditions anyway)
				return false;               // bail out
		}
		return this.orblock ? any_true : true;
	};
	EventBlock.prototype.retrigger = function ()
	{
		this.runtime.execcount++;
		var prevcndindex = this.runtime.getCurrentEventStack().cndindex;
		var len;
		var evinfo = this.runtime.pushEventStack(this);
		if (!this.orblock)
		{
			for (evinfo.cndindex = prevcndindex + 1, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
			{
				if (!this.conditions[evinfo.cndindex].run())    // condition failed
				{
					this.runtime.popEventStack();               // moving up level of recursion
					return false;                               // bail out
				}
			}
		}
		this.run_actions_and_subevents();
		this.runtime.popEventStack();
		return true;		// ran an iteration
	};
	EventBlock.prototype.isFirstConditionOfType = function (cnd)
	{
		var cndindex = cnd.index;
		if (cndindex === 0)
			return true;
		--cndindex;
		for ( ; cndindex >= 0; --cndindex)
		{
			if (this.conditions[cndindex].type === cnd.type)
				return false;
		}
		return true;
	};
	cr.eventblock = EventBlock;
	function Condition(block, m)
	{
		this.block = block;
		this.sheet = block.sheet;
		this.runtime = block.runtime;
		this.parameters = [];
		this.results = [];
		this.extra = {};		// for plugins to stow away some custom info
		this.index = -1;
		this.anyParamVariesPerInstance = false;
		this.func = this.runtime.GetObjectReference(m[1]);
;
		this.trigger = (m[3] > 0);
		this.fasttrigger = (m[3] === 2);
		this.looping = m[4];
		this.inverted = m[5];
		this.isstatic = m[6];
		this.sid = m[7];
		this.runtime.cndsBySid[this.sid.toString()] = this;
		if (m[0] === -1)		// system object
		{
			this.type = null;
			this.run = this.run_system;
			this.behaviortype = null;
			this.beh_index = -1;
		}
		else
		{
			this.type = this.runtime.types_by_index[m[0]];
;
			if (this.isstatic)
				this.run = this.run_static;
			else
				this.run = this.run_object;
			if (m[2])
			{
				this.behaviortype = this.type.getBehaviorByName(m[2]);
;
				this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
			}
			else
			{
				this.behaviortype = null;
				this.beh_index = -1;
			}
			if (this.block.parent)
				this.block.parent.setSolWriterAfterCnds();
		}
		if (this.fasttrigger)
			this.run = this.run_true;
		if (m.length === 10)
		{
			var i, len;
			var em = m[9];
			for (i = 0, len = em.length; i < len; i++)
			{
				var param = new cr.parameter(this, em[i]);
				cr.seal(param);
				this.parameters.push(param);
			}
			this.results.length = em.length;
		}
	};
	Condition.prototype.postInit = function ()
	{
		var i, len, p;
		for (i = 0, len = this.parameters.length; i < len; i++)
		{
			p = this.parameters[i];
			p.postInit();
			if (p.variesPerInstance)
				this.anyParamVariesPerInstance = true;
		}
	};
	/*
	Condition.prototype.is_logical = function ()
	{
		return !this.type || this.type.plugin.singleglobal;
	};
	*/
	Condition.prototype.run_true = function ()
	{
		return true;
	};
	Condition.prototype.run_system = function ()
	{
		var i, len;
		for (i = 0, len = this.parameters.length; i < len; i++)
			this.results[i] = this.parameters[i].get();
		return cr.xor(this.func.apply(this.runtime.system, this.results), this.inverted);
	};
	Condition.prototype.run_static = function ()
	{
		var i, len;
		for (i = 0, len = this.parameters.length; i < len; i++)
			this.results[i] = this.parameters[i].get();
		var ret = this.func.apply(this.behaviortype ? this.behaviortype : this.type, this.results);
		this.type.applySolToContainer();
		return ret;
	};
	Condition.prototype.run_object = function ()
	{
		var i, j, k, leni, lenj, p, ret, met, inst, s, sol2;
		var type = this.type;
		var sol = type.getCurrentSol();
		var is_orblock = this.block.orblock && !this.trigger;		// triggers in OR blocks need to work normally
		var offset = 0;
		var is_contained = type.is_contained;
		var is_family = type.is_family;
		var family_index = type.family_index;
		var beh_index = this.beh_index;
		var is_beh = (beh_index > -1);
		var params_vary = this.anyParamVariesPerInstance;
		var parameters = this.parameters;
		var results = this.results;
		var inverted = this.inverted;
		var func = this.func;
		var arr, container;
		if (params_vary)
		{
			for (j = 0, lenj = parameters.length; j < lenj; ++j)
			{
				p = parameters[j];
				if (!p.variesPerInstance)
					results[j] = p.get(0);
			}
		}
		else
		{
			for (j = 0, lenj = parameters.length; j < lenj; ++j)
				results[j] = parameters[j].get(0);
		}
		if (sol.select_all) {
			cr.clearArray(sol.instances);       // clear contents
			cr.clearArray(sol.else_instances);
			arr = type.instances;
			for (i = 0, leni = arr.length; i < leni; ++i)
			{
				inst = arr[i];
;
				if (params_vary)
				{
					for (j = 0, lenj = parameters.length; j < lenj; ++j)
					{
						p = parameters[j];
						if (p.variesPerInstance)
							results[j] = p.get(i);        // default SOL index is current object
					}
				}
				if (is_beh)
				{
					offset = 0;
					if (is_family)
					{
						offset = inst.type.family_beh_map[family_index];
					}
					ret = func.apply(inst.behavior_insts[beh_index + offset], results);
				}
				else
					ret = func.apply(inst, results);
				met = cr.xor(ret, inverted);
				if (met)
					sol.instances.push(inst);
				else if (is_orblock)					// in OR blocks, keep the instances not meeting the condition for subsequent testing
					sol.else_instances.push(inst);
			}
			if (type.finish)
				type.finish(true);
			sol.select_all = false;
			type.applySolToContainer();
			return sol.hasObjects();
		}
		else {
			k = 0;
			var using_else_instances = (is_orblock && !this.block.isFirstConditionOfType(this));
			arr = (using_else_instances ? sol.else_instances : sol.instances);
			var any_true = false;
			for (i = 0, leni = arr.length; i < leni; ++i)
			{
				inst = arr[i];
;
				if (params_vary)
				{
					for (j = 0, lenj = parameters.length; j < lenj; ++j)
					{
						p = parameters[j];
						if (p.variesPerInstance)
							results[j] = p.get(i);        // default SOL index is current object
					}
				}
				if (is_beh)
				{
					offset = 0;
					if (is_family)
					{
						offset = inst.type.family_beh_map[family_index];
					}
					ret = func.apply(inst.behavior_insts[beh_index + offset], results);
				}
				else
					ret = func.apply(inst, results);
				if (cr.xor(ret, inverted))
				{
					any_true = true;
					if (using_else_instances)
					{
						sol.instances.push(inst);
						if (is_contained)
						{
							for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
							{
								s = inst.siblings[j];
								s.type.getCurrentSol().instances.push(s);
							}
						}
					}
					else
					{
						arr[k] = inst;
						if (is_contained)
						{
							for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
							{
								s = inst.siblings[j];
								s.type.getCurrentSol().instances[k] = s;
							}
						}
						k++;
					}
				}
				else
				{
					if (using_else_instances)
					{
						arr[k] = inst;
						if (is_contained)
						{
							for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
							{
								s = inst.siblings[j];
								s.type.getCurrentSol().else_instances[k] = s;
							}
						}
						k++;
					}
					else if (is_orblock)
					{
						sol.else_instances.push(inst);
						if (is_contained)
						{
							for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
							{
								s = inst.siblings[j];
								s.type.getCurrentSol().else_instances.push(s);
							}
						}
					}
				}
			}
			cr.truncateArray(arr, k);
			if (is_contained)
			{
				container = type.container;
				for (i = 0, leni = container.length; i < leni; i++)
				{
					sol2 = container[i].getCurrentSol();
					if (using_else_instances)
						cr.truncateArray(sol2.else_instances, k);
					else
						cr.truncateArray(sol2.instances, k);
				}
			}
			var pick_in_finish = any_true;		// don't pick in finish() if we're only doing the logic test below
			if (using_else_instances && !any_true)
			{
				for (i = 0, leni = sol.instances.length; i < leni; i++)
				{
					inst = sol.instances[i];
					if (params_vary)
					{
						for (j = 0, lenj = parameters.length; j < lenj; j++)
						{
							p = parameters[j];
							if (p.variesPerInstance)
								results[j] = p.get(i);
						}
					}
					if (is_beh)
						ret = func.apply(inst.behavior_insts[beh_index], results);
					else
						ret = func.apply(inst, results);
					if (cr.xor(ret, inverted))
					{
						any_true = true;
						break;		// got our flag, don't need to test any more
					}
				}
			}
			if (type.finish)
				type.finish(pick_in_finish || is_orblock);
			return is_orblock ? any_true : sol.hasObjects();
		}
	};
	cr.condition = Condition;
	function Action(block, m)
	{
		this.block = block;
		this.sheet = block.sheet;
		this.runtime = block.runtime;
		this.parameters = [];
		this.results = [];
		this.extra = {};		// for plugins to stow away some custom info
		this.index = -1;
		this.anyParamVariesPerInstance = false;
		this.func = this.runtime.GetObjectReference(m[1]);
;
		if (m[0] === -1)	// system
		{
			this.type = null;
			this.run = this.run_system;
			this.behaviortype = null;
			this.beh_index = -1;
		}
		else
		{
			this.type = this.runtime.types_by_index[m[0]];
;
			this.run = this.run_object;
			if (m[2])
			{
				this.behaviortype = this.type.getBehaviorByName(m[2]);
;
				this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
			}
			else
			{
				this.behaviortype = null;
				this.beh_index = -1;
			}
		}
		this.sid = m[3];
		this.runtime.actsBySid[this.sid.toString()] = this;
		if (m.length === 6)
		{
			var i, len;
			var em = m[5];
			for (i = 0, len = em.length; i < len; i++)
			{
				var param = new cr.parameter(this, em[i]);
				cr.seal(param);
				this.parameters.push(param);
			}
			this.results.length = em.length;
		}
	};
	Action.prototype.postInit = function ()
	{
		var i, len, p;
		for (i = 0, len = this.parameters.length; i < len; i++)
		{
			p = this.parameters[i];
			p.postInit();
			if (p.variesPerInstance)
				this.anyParamVariesPerInstance = true;
		}
	};
	Action.prototype.run_system = function ()
	{
		var runtime = this.runtime;
		var i, len;
		var parameters = this.parameters;
		var results = this.results;
		for (i = 0, len = parameters.length; i < len; ++i)
			results[i] = parameters[i].get();
		return this.func.apply(runtime.system, results);
	};
	Action.prototype.run_object = function ()
	{
		var type = this.type;
		var beh_index = this.beh_index;
		var family_index = type.family_index;
		var params_vary = this.anyParamVariesPerInstance;
		var parameters = this.parameters;
		var results = this.results;
		var func = this.func;
		var instances = type.getCurrentSol().getObjects();
		var is_family = type.is_family;
		var is_beh = (beh_index > -1);
		var i, j, leni, lenj, p, inst, offset;
		if (params_vary)
		{
			for (j = 0, lenj = parameters.length; j < lenj; ++j)
			{
				p = parameters[j];
				if (!p.variesPerInstance)
					results[j] = p.get(0);
			}
		}
		else
		{
			for (j = 0, lenj = parameters.length; j < lenj; ++j)
				results[j] = parameters[j].get(0);
		}
		for (i = 0, leni = instances.length; i < leni; ++i)
		{
			inst = instances[i];
			if (params_vary)
			{
				for (j = 0, lenj = parameters.length; j < lenj; ++j)
				{
					p = parameters[j];
					if (p.variesPerInstance)
						results[j] = p.get(i);    // pass i to use as default SOL index
				}
			}
			if (is_beh)
			{
				offset = 0;
				if (is_family)
				{
					offset = inst.type.family_beh_map[family_index];
				}
				func.apply(inst.behavior_insts[beh_index + offset], results);
			}
			else
				func.apply(inst, results);
		}
		return false;
	};
	cr.action = Action;
	var tempValues = [];
	var tempValuesPtr = -1;
	function pushTempValue()
	{
		tempValuesPtr++;
		if (tempValues.length === tempValuesPtr)
			tempValues.push(new cr.expvalue());
		return tempValues[tempValuesPtr];
	};
	function popTempValue()
	{
		tempValuesPtr--;
	};
	function Parameter(owner, m)
	{
		this.owner = owner;
		this.block = owner.block;
		this.sheet = owner.sheet;
		this.runtime = owner.runtime;
		this.type = m[0];
		this.expression = null;
		this.solindex = 0;
		this.get = null;
		this.combosel = 0;
		this.layout = null;
		this.key = 0;
		this.object = null;
		this.index = 0;
		this.varname = null;
		this.eventvar = null;
		this.fileinfo = null;
		this.subparams = null;
		this.variadicret = null;
		this.subparams = null;
		this.variadicret = null;
		this.variesPerInstance = false;
		var i, len, param;
		switch (m[0])
		{
			case 0:		// number
			case 7:		// any
				this.expression = new cr.expNode(this, m[1]);
				this.solindex = 0;
				this.get = this.get_exp;
				break;
			case 1:		// string
				this.expression = new cr.expNode(this, m[1]);
				this.solindex = 0;
				this.get = this.get_exp_str;
				break;
			case 5:		// layer
				this.expression = new cr.expNode(this, m[1]);
				this.solindex = 0;
				this.get = this.get_layer;
				break;
			case 3:		// combo
			case 8:		// cmp
				this.combosel = m[1];
				this.get = this.get_combosel;
				break;
			case 6:		// layout
				this.layout = this.runtime.layouts[m[1]];
;
				this.get = this.get_layout;
				break;
			case 9:		// keyb
				this.key = m[1];
				this.get = this.get_key;
				break;
			case 4:		// object
				this.object = this.runtime.types_by_index[m[1]];
;
				this.get = this.get_object;
				this.block.addSolModifier(this.object);
				if (this.owner instanceof cr.action)
					this.block.setSolWriterAfterCnds();
				else if (this.block.parent)
					this.block.parent.setSolWriterAfterCnds();
				break;
			case 10:	// instvar
				this.index = m[1];
				if (owner.type && owner.type.is_family)
				{
					this.get = this.get_familyvar;
					this.variesPerInstance = true;
				}
				else
					this.get = this.get_instvar;
				break;
			case 11:	// eventvar
				this.varname = m[1];
				this.eventvar = null;
				this.get = this.get_eventvar;
				break;
			case 2:		// audiofile	["name", ismusic]
			case 12:	// fileinfo		"name"
				this.fileinfo = m[1];
				this.get = this.get_audiofile;
				break;
			case 13:	// variadic
				this.get = this.get_variadic;
				this.subparams = [];
				this.variadicret = [];
				for (i = 1, len = m.length; i < len; i++)
				{
					param = new cr.parameter(this.owner, m[i]);
					cr.seal(param);
					this.subparams.push(param);
					this.variadicret.push(0);
				}
				break;
			default:
;
		}
	};
	Parameter.prototype.postInit = function ()
	{
		var i, len;
		if (this.type === 11)		// eventvar
		{
			this.eventvar = this.runtime.getEventVariableByName(this.varname, this.block.parent);
;
		}
		else if (this.type === 13)	// variadic, postInit all sub-params
		{
			for (i = 0, len = this.subparams.length; i < len; i++)
				this.subparams[i].postInit();
		}
		if (this.expression)
			this.expression.postInit();
	};
	Parameter.prototype.maybeVaryForType = function (t)
	{
		if (this.variesPerInstance)
			return;				// already varies per instance, no need to check again
		if (!t)
			return;				// never vary for system type
		if (!t.plugin.singleglobal)
		{
			this.variesPerInstance = true;
			return;
		}
	};
	Parameter.prototype.setVaries = function ()
	{
		this.variesPerInstance = true;
	};
	Parameter.prototype.get_exp = function (solindex)
	{
		this.solindex = solindex || 0;   // default SOL index to use
		var temp = pushTempValue();
		this.expression.get(temp);
		popTempValue();
		return temp.data;      			// return actual JS value, not expvalue
	};
	Parameter.prototype.get_exp_str = function (solindex)
	{
		this.solindex = solindex || 0;   // default SOL index to use
		var temp = pushTempValue();
		this.expression.get(temp);
		popTempValue();
		if (cr.is_string(temp.data))
			return temp.data;
		else
			return "";
	};
	Parameter.prototype.get_object = function ()
	{
		return this.object;
	};
	Parameter.prototype.get_combosel = function ()
	{
		return this.combosel;
	};
	Parameter.prototype.get_layer = function (solindex)
	{
		this.solindex = solindex || 0;   // default SOL index to use
		var temp = pushTempValue();
		this.expression.get(temp);
		popTempValue();
		if (temp.is_number())
			return this.runtime.getLayerByNumber(temp.data);
		else
			return this.runtime.getLayerByName(temp.data);
	}
	Parameter.prototype.get_layout = function ()
	{
		return this.layout;
	};
	Parameter.prototype.get_key = function ()
	{
		return this.key;
	};
	Parameter.prototype.get_instvar = function ()
	{
		return this.index;
	};
	Parameter.prototype.get_familyvar = function (solindex_)
	{
		var solindex = solindex_ || 0;
		var familytype = this.owner.type;
		var realtype = null;
		var sol = familytype.getCurrentSol();
		var objs = sol.getObjects();
		if (objs.length)
			realtype = objs[solindex % objs.length].type;
		else if (sol.else_instances.length)
			realtype = sol.else_instances[solindex % sol.else_instances.length].type;
		else if (familytype.instances.length)
			realtype = familytype.instances[solindex % familytype.instances.length].type;
		else
			return 0;
		return this.index + realtype.family_var_map[familytype.family_index];
	};
	Parameter.prototype.get_eventvar = function ()
	{
		return this.eventvar;
	};
	Parameter.prototype.get_audiofile = function ()
	{
		return this.fileinfo;
	};
	Parameter.prototype.get_variadic = function ()
	{
		var i, len;
		for (i = 0, len = this.subparams.length; i < len; i++)
		{
			this.variadicret[i] = this.subparams[i].get();
		}
		return this.variadicret;
	};
	cr.parameter = Parameter;
	function EventVariable(sheet, parent, m)
	{
		this.sheet = sheet;
		this.parent = parent;
		this.runtime = sheet.runtime;
		this.solModifiers = [];
		this.name = m[1];
		this.vartype = m[2];
		this.initial = m[3];
		this.is_static = !!m[4];
		this.is_constant = !!m[5];
		this.sid = m[6];
		this.runtime.varsBySid[this.sid.toString()] = this;
		this.data = this.initial;	// note: also stored in event stack frame for local nonstatic nonconst vars
		if (this.parent)			// local var
		{
			if (this.is_static || this.is_constant)
				this.localIndex = -1;
			else
				this.localIndex = this.runtime.stackLocalCount++;
			this.runtime.all_local_vars.push(this);
		}
		else						// global var
		{
			this.localIndex = -1;
			this.runtime.all_global_vars.push(this);
		}
	};
	EventVariable.prototype.postInit = function ()
	{
		this.solModifiers = findMatchingSolModifier(this.solModifiers);
	};
	EventVariable.prototype.setValue = function (x)
	{
;
		var lvs = this.runtime.getCurrentLocalVarStack();
		if (!this.parent || this.is_static || !lvs)
			this.data = x;
		else	// local nonstatic variable: use event stack to keep value at this level of recursion
		{
			if (this.localIndex >= lvs.length)
				lvs.length = this.localIndex + 1;
			lvs[this.localIndex] = x;
		}
	};
	EventVariable.prototype.getValue = function ()
	{
		var lvs = this.runtime.getCurrentLocalVarStack();
		if (!this.parent || this.is_static || !lvs || this.is_constant)
			return this.data;
		else	// local nonstatic variable
		{
			if (this.localIndex >= lvs.length)
			{
				return this.initial;
			}
			if (typeof lvs[this.localIndex] === "undefined")
			{
				return this.initial;
			}
			return lvs[this.localIndex];
		}
	};
	EventVariable.prototype.run = function ()
	{
			if (this.parent && !this.is_static && !this.is_constant)
				this.setValue(this.initial);
	};
	cr.eventvariable = EventVariable;
	function EventInclude(sheet, parent, m)
	{
		this.sheet = sheet;
		this.parent = parent;
		this.runtime = sheet.runtime;
		this.solModifiers = [];
		this.include_sheet = null;		// determined in postInit
		this.include_sheet_name = m[1];
		this.active = true;
	};
	EventInclude.prototype.toString = function ()
	{
		return "include:" + this.include_sheet.toString();
	};
	EventInclude.prototype.postInit = function ()
	{
        this.include_sheet = this.runtime.eventsheets[this.include_sheet_name];
;
;
        this.sheet.includes.add(this);
		this.solModifiers = findMatchingSolModifier(this.solModifiers);
		var p = this.parent;
		while (p)
		{
			if (p.group)
				p.contained_includes.push(this);
			p = p.parent;
		}
		this.updateActive();
	};
	EventInclude.prototype.run = function ()
	{
			if (this.parent)
				this.runtime.pushCleanSol(this.runtime.types_by_index);
        if (!this.include_sheet.hasRun)
            this.include_sheet.run(true);			// from include
			if (this.parent)
				this.runtime.popSol(this.runtime.types_by_index);
	};
	EventInclude.prototype.updateActive = function ()
	{
		var p = this.parent;
		while (p)
		{
			if (p.group && !p.group_active)
			{
				this.active = false;
				return;
			}
			p = p.parent;
		}
		this.active = true;
	};
	EventInclude.prototype.isActive = function ()
	{
		return this.active;
	};
	cr.eventinclude = EventInclude;
	function EventStackFrame()
	{
		this.temp_parents_arr = [];
		this.reset(null);
		cr.seal(this);
	};
	EventStackFrame.prototype.reset = function (cur_event)
	{
		this.current_event = cur_event;
		this.cndindex = 0;
		this.actindex = 0;
		cr.clearArray(this.temp_parents_arr);
		this.last_event_true = false;
		this.else_branch_ran = false;
		this.any_true_state = false;
	};
	EventStackFrame.prototype.isModifierAfterCnds = function ()
	{
		if (this.current_event.solWriterAfterCnds)
			return true;
		if (this.cndindex < this.current_event.conditions.length - 1)
			return !!this.current_event.solModifiers.length;
		return false;
	};
	cr.eventStackFrame = EventStackFrame;
}());
(function()
{
	function ExpNode(owner_, m)
	{
		this.owner = owner_;
		this.runtime = owner_.runtime;
		this.type = m[0];
;
		this.get = [this.eval_int,
					this.eval_float,
					this.eval_string,
					this.eval_unaryminus,
					this.eval_add,
					this.eval_subtract,
					this.eval_multiply,
					this.eval_divide,
					this.eval_mod,
					this.eval_power,
					this.eval_and,
					this.eval_or,
					this.eval_equal,
					this.eval_notequal,
					this.eval_less,
					this.eval_lessequal,
					this.eval_greater,
					this.eval_greaterequal,
					this.eval_conditional,
					this.eval_system_exp,
					this.eval_object_exp,
					this.eval_instvar_exp,
					this.eval_behavior_exp,
					this.eval_eventvar_exp][this.type];
		var paramsModel = null;
		this.value = null;
		this.first = null;
		this.second = null;
		this.third = null;
		this.func = null;
		this.results = null;
		this.parameters = null;
		this.object_type = null;
		this.beh_index = -1;
		this.instance_expr = null;
		this.varindex = -1;
		this.behavior_type = null;
		this.varname = null;
		this.eventvar = null;
		this.return_string = false;
		switch (this.type) {
		case 0:		// int
		case 1:		// float
		case 2:		// string
			this.value = m[1];
			break;
		case 3:		// unaryminus
			this.first = new cr.expNode(owner_, m[1]);
			break;
		case 18:	// conditional
			this.first = new cr.expNode(owner_, m[1]);
			this.second = new cr.expNode(owner_, m[2]);
			this.third = new cr.expNode(owner_, m[3]);
			break;
		case 19:	// system_exp
			this.func = this.runtime.GetObjectReference(m[1]);
;
			if (this.func === cr.system_object.prototype.exps.random
			 || this.func === cr.system_object.prototype.exps.choose)
			{
				this.owner.setVaries();
			}
			this.results = [];
			this.parameters = [];
			if (m.length === 3)
			{
				paramsModel = m[2];
				this.results.length = paramsModel.length + 1;	// must also fit 'ret'
			}
			else
				this.results.length = 1;      // to fit 'ret'
			break;
		case 20:	// object_exp
			this.object_type = this.runtime.types_by_index[m[1]];
;
			this.beh_index = -1;
			this.func = this.runtime.GetObjectReference(m[2]);
			this.return_string = m[3];
			if (cr.plugins_.Function && this.func === cr.plugins_.Function.prototype.exps.Call)
			{
				this.owner.setVaries();
			}
			if (m[4])
				this.instance_expr = new cr.expNode(owner_, m[4]);
			else
				this.instance_expr = null;
			this.results = [];
			this.parameters = [];
			if (m.length === 6)
			{
				paramsModel = m[5];
				this.results.length = paramsModel.length + 1;
			}
			else
				this.results.length = 1;	// to fit 'ret'
			break;
		case 21:		// instvar_exp
			this.object_type = this.runtime.types_by_index[m[1]];
;
			this.return_string = m[2];
			if (m[3])
				this.instance_expr = new cr.expNode(owner_, m[3]);
			else
				this.instance_expr = null;
			this.varindex = m[4];
			break;
		case 22:		// behavior_exp
			this.object_type = this.runtime.types_by_index[m[1]];
;
			this.behavior_type = this.object_type.getBehaviorByName(m[2]);
;
			this.beh_index = this.object_type.getBehaviorIndexByName(m[2]);
			this.func = this.runtime.GetObjectReference(m[3]);
			this.return_string = m[4];
			if (m[5])
				this.instance_expr = new cr.expNode(owner_, m[5]);
			else
				this.instance_expr = null;
			this.results = [];
			this.parameters = [];
			if (m.length === 7)
			{
				paramsModel = m[6];
				this.results.length = paramsModel.length + 1;
			}
			else
				this.results.length = 1;	// to fit 'ret'
			break;
		case 23:		// eventvar_exp
			this.varname = m[1];
			this.eventvar = null;	// assigned in postInit
			break;
		}
		this.owner.maybeVaryForType(this.object_type);
		if (this.type >= 4 && this.type <= 17)
		{
			this.first = new cr.expNode(owner_, m[1]);
			this.second = new cr.expNode(owner_, m[2]);
		}
		if (paramsModel)
		{
			var i, len;
			for (i = 0, len = paramsModel.length; i < len; i++)
				this.parameters.push(new cr.expNode(owner_, paramsModel[i]));
		}
		cr.seal(this);
	};
	ExpNode.prototype.postInit = function ()
	{
		if (this.type === 23)	// eventvar_exp
		{
			this.eventvar = this.owner.runtime.getEventVariableByName(this.varname, this.owner.block.parent);
;
		}
		if (this.first)
			this.first.postInit();
		if (this.second)
			this.second.postInit();
		if (this.third)
			this.third.postInit();
		if (this.instance_expr)
			this.instance_expr.postInit();
		if (this.parameters)
		{
			var i, len;
			for (i = 0, len = this.parameters.length; i < len; i++)
				this.parameters[i].postInit();
		}
	};
	var tempValues = [];
	var tempValuesPtr = -1;
	function pushTempValue()
	{
		++tempValuesPtr;
		if (tempValues.length === tempValuesPtr)
			tempValues.push(new cr.expvalue());
		return tempValues[tempValuesPtr];
	};
	function popTempValue()
	{
		--tempValuesPtr;
	};
	function eval_params(parameters, results, temp)
	{
		var i, len;
		for (i = 0, len = parameters.length; i < len; ++i)
		{
			parameters[i].get(temp);
			results[i + 1] = temp.data;   // passing actual javascript value as argument instead of expvalue
		}
	}
	ExpNode.prototype.eval_system_exp = function (ret)
	{
		var parameters = this.parameters;
		var results = this.results;
		results[0] = ret;
		var temp = pushTempValue();
		eval_params(parameters, results, temp);
		popTempValue();
		this.func.apply(this.runtime.system, results);
	};
	ExpNode.prototype.eval_object_exp = function (ret)
	{
		var object_type = this.object_type;
		var results = this.results;
		var parameters = this.parameters;
		var instance_expr = this.instance_expr;
		var func = this.func;
		var index = this.owner.solindex;			// default to parameter's intended SOL index
		var sol = object_type.getCurrentSol();
		var instances = sol.getObjects();
		if (!instances.length)
		{
			if (sol.else_instances.length)
				instances = sol.else_instances;
			else
			{
				if (this.return_string)
					ret.set_string("");
				else
					ret.set_int(0);
				return;
			}
		}
		results[0] = ret;
		ret.object_class = object_type;		// so expression can access family type if need be
		var temp = pushTempValue();
		eval_params(parameters, results, temp);
		if (instance_expr) {
			instance_expr.get(temp);
			if (temp.is_number()) {
				index = temp.data;
				instances = object_type.instances;    // pick from all instances, not SOL
			}
		}
		popTempValue();
		var len = instances.length;
		if (index >= len || index <= -len)
			index %= len;      // wraparound
		if (index < 0)
			index += len;
		var returned_val = func.apply(instances[index], results);
;
	};
	ExpNode.prototype.eval_behavior_exp = function (ret)
	{
		var object_type = this.object_type;
		var results = this.results;
		var parameters = this.parameters;
		var instance_expr = this.instance_expr;
		var beh_index = this.beh_index;
		var func = this.func;
		var index = this.owner.solindex;			// default to parameter's intended SOL index
		var sol = object_type.getCurrentSol();
		var instances = sol.getObjects();
		if (!instances.length)
		{
			if (sol.else_instances.length)
				instances = sol.else_instances;
			else
			{
				if (this.return_string)
					ret.set_string("");
				else
					ret.set_int(0);
				return;
			}
		}
		results[0] = ret;
		ret.object_class = object_type;		// so expression can access family type if need be
		var temp = pushTempValue();
		eval_params(parameters, results, temp);
		if (instance_expr) {
			instance_expr.get(temp);
			if (temp.is_number()) {
				index = temp.data;
				instances = object_type.instances;    // pick from all instances, not SOL
			}
		}
		popTempValue();
		var len = instances.length;
		if (index >= len || index <= -len)
			index %= len;      // wraparound
		if (index < 0)
			index += len;
		var inst = instances[index];
		var offset = 0;
		if (object_type.is_family)
		{
			offset = inst.type.family_beh_map[object_type.family_index];
		}
		var returned_val = func.apply(inst.behavior_insts[beh_index + offset], results);
;
	};
	ExpNode.prototype.eval_instvar_exp = function (ret)
	{
		var instance_expr = this.instance_expr;
		var object_type = this.object_type;
		var varindex = this.varindex;
		var index = this.owner.solindex;		// default to parameter's intended SOL index
		var sol = object_type.getCurrentSol();
		var instances = sol.getObjects();
		var inst;
		if (!instances.length)
		{
			if (sol.else_instances.length)
				instances = sol.else_instances;
			else
			{
				if (this.return_string)
					ret.set_string("");
				else
					ret.set_int(0);
				return;
			}
		}
		if (instance_expr)
		{
			var temp = pushTempValue();
			instance_expr.get(temp);
			if (temp.is_number())
			{
				index = temp.data;
				var type_instances = object_type.instances;
				if (type_instances.length !== 0)		// avoid NaN result with %
				{
					index %= type_instances.length;     // wraparound
					if (index < 0)                      // offset
						index += type_instances.length;
				}
				inst = object_type.getInstanceByIID(index);
				var to_ret = inst.instance_vars[varindex];
				if (cr.is_string(to_ret))
					ret.set_string(to_ret);
				else
					ret.set_float(to_ret);
				popTempValue();
				return;         // done
			}
			popTempValue();
		}
		var len = instances.length;
		if (index >= len || index <= -len)
			index %= len;		// wraparound
		if (index < 0)
			index += len;
		inst = instances[index];
		var offset = 0;
		if (object_type.is_family)
		{
			offset = inst.type.family_var_map[object_type.family_index];
		}
		var to_ret = inst.instance_vars[varindex + offset];
		if (cr.is_string(to_ret))
			ret.set_string(to_ret);
		else
			ret.set_float(to_ret);
	};
	ExpNode.prototype.eval_int = function (ret)
	{
		ret.type = cr.exptype.Integer;
		ret.data = this.value;
	};
	ExpNode.prototype.eval_float = function (ret)
	{
		ret.type = cr.exptype.Float;
		ret.data = this.value;
	};
	ExpNode.prototype.eval_string = function (ret)
	{
		ret.type = cr.exptype.String;
		ret.data = this.value;
	};
	ExpNode.prototype.eval_unaryminus = function (ret)
	{
		this.first.get(ret);                // retrieve operand
		if (ret.is_number())
			ret.data = -ret.data;
	};
	ExpNode.prototype.eval_add = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (ret.is_number() && temp.is_number())
		{
			ret.data += temp.data;          // both operands numbers: add
			if (temp.is_float())
				ret.make_float();
		}
		popTempValue();
	};
	ExpNode.prototype.eval_subtract = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (ret.is_number() && temp.is_number())
		{
			ret.data -= temp.data;          // both operands numbers: subtract
			if (temp.is_float())
				ret.make_float();
		}
		popTempValue();
	};
	ExpNode.prototype.eval_multiply = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (ret.is_number() && temp.is_number())
		{
			ret.data *= temp.data;          // both operands numbers: multiply
			if (temp.is_float())
				ret.make_float();
		}
		popTempValue();
	};
	ExpNode.prototype.eval_divide = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (ret.is_number() && temp.is_number())
		{
			ret.data /= temp.data;          // both operands numbers: divide
			ret.make_float();
		}
		popTempValue();
	};
	ExpNode.prototype.eval_mod = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (ret.is_number() && temp.is_number())
		{
			ret.data %= temp.data;          // both operands numbers: modulo
			if (temp.is_float())
				ret.make_float();
		}
		popTempValue();
	};
	ExpNode.prototype.eval_power = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (ret.is_number() && temp.is_number())
		{
			ret.data = Math.pow(ret.data, temp.data);   // both operands numbers: raise to power
			if (temp.is_float())
				ret.make_float();
		}
		popTempValue();
	};
	ExpNode.prototype.eval_and = function (ret)
	{
		this.first.get(ret);			// left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (temp.is_string() || ret.is_string())
			this.eval_and_stringconcat(ret, temp);
		else
			this.eval_and_logical(ret, temp);
		popTempValue();
	};
	ExpNode.prototype.eval_and_stringconcat = function (ret, temp)
	{
		if (ret.is_string() && temp.is_string())
			this.eval_and_stringconcat_str_str(ret, temp);
		else
			this.eval_and_stringconcat_num(ret, temp);
	};
	ExpNode.prototype.eval_and_stringconcat_str_str = function (ret, temp)
	{
		ret.data += temp.data;
	};
	ExpNode.prototype.eval_and_stringconcat_num = function (ret, temp)
	{
		if (ret.is_string())
		{
			ret.data += (Math.round(temp.data * 1e10) / 1e10).toString();
		}
		else
		{
			ret.set_string(ret.data.toString() + temp.data);
		}
	};
	ExpNode.prototype.eval_and_logical = function (ret, temp)
	{
		ret.set_int(ret.data && temp.data ? 1 : 0);
	};
	ExpNode.prototype.eval_or = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		if (ret.is_number() && temp.is_number())
		{
			if (ret.data || temp.data)
				ret.set_int(1);
			else
				ret.set_int(0);
		}
		popTempValue();
	};
	ExpNode.prototype.eval_conditional = function (ret)
	{
		this.first.get(ret);                // condition operand
		if (ret.data)                       // is true
			this.second.get(ret);           // evaluate second operand to ret
		else
			this.third.get(ret);            // evaluate third operand to ret
	};
	ExpNode.prototype.eval_equal = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		ret.set_int(ret.data === temp.data ? 1 : 0);
		popTempValue();
	};
	ExpNode.prototype.eval_notequal = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		ret.set_int(ret.data !== temp.data ? 1 : 0);
		popTempValue();
	};
	ExpNode.prototype.eval_less = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		ret.set_int(ret.data < temp.data ? 1 : 0);
		popTempValue();
	};
	ExpNode.prototype.eval_lessequal = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		ret.set_int(ret.data <= temp.data ? 1 : 0);
		popTempValue();
	};
	ExpNode.prototype.eval_greater = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		ret.set_int(ret.data > temp.data ? 1 : 0);
		popTempValue();
	};
	ExpNode.prototype.eval_greaterequal = function (ret)
	{
		this.first.get(ret);                // left operand
		var temp = pushTempValue();
		this.second.get(temp);			// right operand
		ret.set_int(ret.data >= temp.data ? 1 : 0);
		popTempValue();
	};
	ExpNode.prototype.eval_eventvar_exp = function (ret)
	{
		var val = this.eventvar.getValue();
		if (cr.is_number(val))
			ret.set_float(val);
		else
			ret.set_string(val);
	};
	cr.expNode = ExpNode;
	function ExpValue(type, data)
	{
		this.type = type || cr.exptype.Integer;
		this.data = data || 0;
		this.object_class = null;
;
;
;
		if (this.type == cr.exptype.Integer)
			this.data = Math.floor(this.data);
		cr.seal(this);
	};
	ExpValue.prototype.is_int = function ()
	{
		return this.type === cr.exptype.Integer;
	};
	ExpValue.prototype.is_float = function ()
	{
		return this.type === cr.exptype.Float;
	};
	ExpValue.prototype.is_number = function ()
	{
		return this.type === cr.exptype.Integer || this.type === cr.exptype.Float;
	};
	ExpValue.prototype.is_string = function ()
	{
		return this.type === cr.exptype.String;
	};
	ExpValue.prototype.make_int = function ()
	{
		if (!this.is_int())
		{
			if (this.is_float())
				this.data = Math.floor(this.data);      // truncate float
			else if (this.is_string())
				this.data = parseInt(this.data, 10);
			this.type = cr.exptype.Integer;
		}
	};
	ExpValue.prototype.make_float = function ()
	{
		if (!this.is_float())
		{
			if (this.is_string())
				this.data = parseFloat(this.data);
			this.type = cr.exptype.Float;
		}
	};
	ExpValue.prototype.make_string = function ()
	{
		if (!this.is_string())
		{
			this.data = this.data.toString();
			this.type = cr.exptype.String;
		}
	};
	ExpValue.prototype.set_int = function (val)
	{
;
		this.type = cr.exptype.Integer;
		this.data = Math.floor(val);
	};
	ExpValue.prototype.set_float = function (val)
	{
;
		this.type = cr.exptype.Float;
		this.data = val;
	};
	ExpValue.prototype.set_string = function (val)
	{
;
		this.type = cr.exptype.String;
		this.data = val;
	};
	ExpValue.prototype.set_any = function (val)
	{
		if (cr.is_number(val))
		{
			this.type = cr.exptype.Float;
			this.data = val;
		}
		else if (cr.is_string(val))
		{
			this.type = cr.exptype.String;
			this.data = val.toString();
		}
		else
		{
			this.type = cr.exptype.Integer;
			this.data = 0;
		}
	};
	cr.expvalue = ExpValue;
	cr.exptype = {
		Integer: 0,     // emulated; no native integer support in javascript
		Float: 1,
		String: 2
	};
}());
;
cr.system_object = function (runtime)
{
    this.runtime = runtime;
	this.waits = [];
};
cr.system_object.prototype.saveToJSON = function ()
{
	var o = {};
	var i, len, j, lenj, p, w, t, sobj;
	o["waits"] = [];
	var owaits = o["waits"];
	var waitobj;
	for (i = 0, len = this.waits.length; i < len; i++)
	{
		w = this.waits[i];
		waitobj = {
			"t": w.time,
			"st": w.signaltag,
			"s": w.signalled,
			"ev": w.ev.sid,
			"sm": [],
			"sols": {}
		};
		if (w.ev.actions[w.actindex])
			waitobj["act"] = w.ev.actions[w.actindex].sid;
		for (j = 0, lenj = w.solModifiers.length; j < lenj; j++)
			waitobj["sm"].push(w.solModifiers[j].sid);
		for (p in w.sols)
		{
			if (w.sols.hasOwnProperty(p))
			{
				t = this.runtime.types_by_index[parseInt(p, 10)];
;
				sobj = {
					"sa": w.sols[p].sa,
					"insts": []
				};
				for (j = 0, lenj = w.sols[p].insts.length; j < lenj; j++)
					sobj["insts"].push(w.sols[p].insts[j].uid);
				waitobj["sols"][t.sid.toString()] = sobj;
			}
		}
		owaits.push(waitobj);
	}
	return o;
};
cr.system_object.prototype.loadFromJSON = function (o)
{
	var owaits = o["waits"];
	var i, len, j, lenj, p, w, addWait, e, aindex, t, savedsol, nusol, inst;
	cr.clearArray(this.waits);
	for (i = 0, len = owaits.length; i < len; i++)
	{
		w = owaits[i];
		e = this.runtime.blocksBySid[w["ev"].toString()];
		if (!e)
			continue;	// event must've gone missing
		aindex = -1;
		for (j = 0, lenj = e.actions.length; j < lenj; j++)
		{
			if (e.actions[j].sid === w["act"])
			{
				aindex = j;
				break;
			}
		}
		if (aindex === -1)
			continue;	// action must've gone missing
		addWait = {};
		addWait.sols = {};
		addWait.solModifiers = [];
		addWait.deleteme = false;
		addWait.time = w["t"];
		addWait.signaltag = w["st"] || "";
		addWait.signalled = !!w["s"];
		addWait.ev = e;
		addWait.actindex = aindex;
		for (j = 0, lenj = w["sm"].length; j < lenj; j++)
		{
			t = this.runtime.getObjectTypeBySid(w["sm"][j]);
			if (t)
				addWait.solModifiers.push(t);
		}
		for (p in w["sols"])
		{
			if (w["sols"].hasOwnProperty(p))
			{
				t = this.runtime.getObjectTypeBySid(parseInt(p, 10));
				if (!t)
					continue;		// type must've been deleted
				savedsol = w["sols"][p];
				nusol = {
					sa: savedsol["sa"],
					insts: []
				};
				for (j = 0, lenj = savedsol["insts"].length; j < lenj; j++)
				{
					inst = this.runtime.getObjectByUID(savedsol["insts"][j]);
					if (inst)
						nusol.insts.push(inst);
				}
				addWait.sols[t.index.toString()] = nusol;
			}
		}
		this.waits.push(addWait);
	}
};
(function ()
{
	var sysProto = cr.system_object.prototype;
	function SysCnds() {};
    SysCnds.prototype.EveryTick = function()
    {
        return true;
    };
    SysCnds.prototype.OnLayoutStart = function()
    {
        return true;
    };
    SysCnds.prototype.OnLayoutEnd = function()
    {
        return true;
    };
    SysCnds.prototype.Compare = function(x, cmp, y)
    {
        return cr.do_cmp(x, cmp, y);
    };
    SysCnds.prototype.CompareTime = function (cmp, t)
    {
        var elapsed = this.runtime.kahanTime.sum;
        if (cmp === 0)
        {
            var cnd = this.runtime.getCurrentCondition();
            if (!cnd.extra["CompareTime_executed"])
            {
                if (elapsed >= t)
                {
                    cnd.extra["CompareTime_executed"] = true;
                    return true;
                }
            }
            return false;
        }
        return cr.do_cmp(elapsed, cmp, t);
    };
    SysCnds.prototype.LayerVisible = function (layer)
    {
        if (!layer)
            return false;
        else
            return layer.visible;
    };
	SysCnds.prototype.LayerEmpty = function (layer)
    {
        if (!layer)
            return false;
        else
            return !layer.instances.length;
    };
	SysCnds.prototype.LayerCmpOpacity = function (layer, cmp, opacity_)
	{
		if (!layer)
			return false;
		return cr.do_cmp(layer.opacity * 100, cmp, opacity_);
	};
    SysCnds.prototype.Repeat = function (count)
    {
		var current_frame = this.runtime.getCurrentEventStack();
        var current_event = current_frame.current_event;
		var solModifierAfterCnds = current_frame.isModifierAfterCnds();
        var current_loop = this.runtime.pushLoopStack();
        var i;
		if (solModifierAfterCnds)
		{
			for (i = 0; i < count && !current_loop.stopped; i++)
			{
				this.runtime.pushCopySol(current_event.solModifiers);
				current_loop.index = i;
				current_event.retrigger();
				this.runtime.popSol(current_event.solModifiers);
			}
		}
		else
		{
			for (i = 0; i < count && !current_loop.stopped; i++)
			{
				current_loop.index = i;
				current_event.retrigger();
			}
		}
        this.runtime.popLoopStack();
		return false;
    };
	SysCnds.prototype.While = function (count)
    {
		var current_frame = this.runtime.getCurrentEventStack();
        var current_event = current_frame.current_event;
		var solModifierAfterCnds = current_frame.isModifierAfterCnds();
        var current_loop = this.runtime.pushLoopStack();
        var i;
		if (solModifierAfterCnds)
		{
			for (i = 0; !current_loop.stopped; i++)
			{
				this.runtime.pushCopySol(current_event.solModifiers);
				current_loop.index = i;
				if (!current_event.retrigger())		// one of the other conditions returned false
					current_loop.stopped = true;	// break
				this.runtime.popSol(current_event.solModifiers);
			}
		}
		else
		{
			for (i = 0; !current_loop.stopped; i++)
			{
				current_loop.index = i;
				if (!current_event.retrigger())
					current_loop.stopped = true;
			}
		}
        this.runtime.popLoopStack();
		return false;
    };
    SysCnds.prototype.For = function (name, start, end)
    {
        var current_frame = this.runtime.getCurrentEventStack();
        var current_event = current_frame.current_event;
		var solModifierAfterCnds = current_frame.isModifierAfterCnds();
        var current_loop = this.runtime.pushLoopStack(name);
        var i;
		if (end < start)
		{
			if (solModifierAfterCnds)
			{
				for (i = start; i >= end && !current_loop.stopped; --i)  // inclusive to end
				{
					this.runtime.pushCopySol(current_event.solModifiers);
					current_loop.index = i;
					current_event.retrigger();
					this.runtime.popSol(current_event.solModifiers);
				}
			}
			else
			{
				for (i = start; i >= end && !current_loop.stopped; --i)  // inclusive to end
				{
					current_loop.index = i;
					current_event.retrigger();
				}
			}
		}
		else
		{
			if (solModifierAfterCnds)
			{
				for (i = start; i <= end && !current_loop.stopped; ++i)  // inclusive to end
				{
					this.runtime.pushCopySol(current_event.solModifiers);
					current_loop.index = i;
					current_event.retrigger();
					this.runtime.popSol(current_event.solModifiers);
				}
			}
			else
			{
				for (i = start; i <= end && !current_loop.stopped; ++i)  // inclusive to end
				{
					current_loop.index = i;
					current_event.retrigger();
				}
			}
		}
        this.runtime.popLoopStack();
		return false;
    };
	var foreach_instancestack = [];
	var foreach_instanceptr = -1;
    SysCnds.prototype.ForEach = function (obj)
    {
        var sol = obj.getCurrentSol();
		foreach_instanceptr++;
		if (foreach_instancestack.length === foreach_instanceptr)
			foreach_instancestack.push([]);
		var instances = foreach_instancestack[foreach_instanceptr];
		cr.shallowAssignArray(instances, sol.getObjects());
        var current_frame = this.runtime.getCurrentEventStack();
        var current_event = current_frame.current_event;
		var solModifierAfterCnds = current_frame.isModifierAfterCnds();
        var current_loop = this.runtime.pushLoopStack();
        var i, len, j, lenj, inst, s, sol2;
		var is_contained = obj.is_contained;
		if (solModifierAfterCnds)
		{
			for (i = 0, len = instances.length; i < len && !current_loop.stopped; i++)
			{
				this.runtime.pushCopySol(current_event.solModifiers);
				inst = instances[i];
				sol = obj.getCurrentSol();
				sol.select_all = false;
				cr.clearArray(sol.instances);
				sol.instances[0] = inst;
				if (is_contained)
				{
					for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
					{
						s = inst.siblings[j];
						sol2 = s.type.getCurrentSol();
						sol2.select_all = false;
						cr.clearArray(sol2.instances);
						sol2.instances[0] = s;
					}
				}
				current_loop.index = i;
				current_event.retrigger();
				this.runtime.popSol(current_event.solModifiers);
			}
		}
		else
		{
			sol.select_all = false;
			cr.clearArray(sol.instances);
			for (i = 0, len = instances.length; i < len && !current_loop.stopped; i++)
			{
				inst = instances[i];
				sol.instances[0] = inst;
				if (is_contained)
				{
					for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
					{
						s = inst.siblings[j];
						sol2 = s.type.getCurrentSol();
						sol2.select_all = false;
						cr.clearArray(sol2.instances);
						sol2.instances[0] = s;
					}
				}
				current_loop.index = i;
				current_event.retrigger();
			}
		}
		cr.clearArray(instances);
        this.runtime.popLoopStack();
		foreach_instanceptr--;
		return false;
    };
	function foreach_sortinstances(a, b)
	{
		var va = a.extra["c2_feo_val"];
		var vb = b.extra["c2_feo_val"];
		if (cr.is_number(va) && cr.is_number(vb))
			return va - vb;
		else
		{
			va = "" + va;
			vb = "" + vb;
			if (va < vb)
				return -1;
			else if (va > vb)
				return 1;
			else
				return 0;
		}
	};
	SysCnds.prototype.ForEachOrdered = function (obj, exp, order)
    {
        var sol = obj.getCurrentSol();
		foreach_instanceptr++;
		if (foreach_instancestack.length === foreach_instanceptr)
			foreach_instancestack.push([]);
		var instances = foreach_instancestack[foreach_instanceptr];
		cr.shallowAssignArray(instances, sol.getObjects());
        var current_frame = this.runtime.getCurrentEventStack();
        var current_event = current_frame.current_event;
		var current_condition = this.runtime.getCurrentCondition();
		var solModifierAfterCnds = current_frame.isModifierAfterCnds();
        var current_loop = this.runtime.pushLoopStack();
		var i, len, j, lenj, inst, s, sol2;
		for (i = 0, len = instances.length; i < len; i++)
		{
			instances[i].extra["c2_feo_val"] = current_condition.parameters[1].get(i);
		}
		instances.sort(foreach_sortinstances);
		if (order === 1)
			instances.reverse();
		var is_contained = obj.is_contained;
		if (solModifierAfterCnds)
		{
			for (i = 0, len = instances.length; i < len && !current_loop.stopped; i++)
			{
				this.runtime.pushCopySol(current_event.solModifiers);
				inst = instances[i];
				sol = obj.getCurrentSol();
				sol.select_all = false;
				cr.clearArray(sol.instances);
				sol.instances[0] = inst;
				if (is_contained)
				{
					for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
					{
						s = inst.siblings[j];
						sol2 = s.type.getCurrentSol();
						sol2.select_all = false;
						cr.clearArray(sol2.instances);
						sol2.instances[0] = s;
					}
				}
				current_loop.index = i;
				current_event.retrigger();
				this.runtime.popSol(current_event.solModifiers);
			}
		}
		else
		{
			sol.select_all = false;
			cr.clearArray(sol.instances);
			for (i = 0, len = instances.length; i < len && !current_loop.stopped; i++)
			{
				inst = instances[i];
				sol.instances[0] = inst;
				if (is_contained)
				{
					for (j = 0, lenj = inst.siblings.length; j < lenj; j++)
					{
						s = inst.siblings[j];
						sol2 = s.type.getCurrentSol();
						sol2.select_all = false;
						cr.clearArray(sol2.instances);
						sol2.instances[0] = s;
					}
				}
				current_loop.index = i;
				current_event.retrigger();
			}
		}
		cr.clearArray(instances);
        this.runtime.popLoopStack();
		foreach_instanceptr--;
		return false;
    };
	SysCnds.prototype.PickByComparison = function (obj_, exp_, cmp_, val_)
	{
		var i, len, k, inst;
		if (!obj_)
			return;
		foreach_instanceptr++;
		if (foreach_instancestack.length === foreach_instanceptr)
			foreach_instancestack.push([]);
		var tmp_instances = foreach_instancestack[foreach_instanceptr];
		var sol = obj_.getCurrentSol();
		cr.shallowAssignArray(tmp_instances, sol.getObjects());
		if (sol.select_all)
			cr.clearArray(sol.else_instances);
		var current_condition = this.runtime.getCurrentCondition();
		for (i = 0, k = 0, len = tmp_instances.length; i < len; i++)
		{
			inst = tmp_instances[i];
			tmp_instances[k] = inst;
			exp_ = current_condition.parameters[1].get(i);
			val_ = current_condition.parameters[3].get(i);
			if (cr.do_cmp(exp_, cmp_, val_))
			{
				k++;
			}
			else
			{
				sol.else_instances.push(inst);
			}
		}
		cr.truncateArray(tmp_instances, k);
		sol.select_all = false;
		cr.shallowAssignArray(sol.instances, tmp_instances);
		cr.clearArray(tmp_instances);
		foreach_instanceptr--;
		obj_.applySolToContainer();
		return !!sol.instances.length;
	};
	SysCnds.prototype.PickByEvaluate = function (obj_, exp_)
	{
		var i, len, k, inst;
		if (!obj_)
			return;
		foreach_instanceptr++;
		if (foreach_instancestack.length === foreach_instanceptr)
			foreach_instancestack.push([]);
		var tmp_instances = foreach_instancestack[foreach_instanceptr];
		var sol = obj_.getCurrentSol();
		cr.shallowAssignArray(tmp_instances, sol.getObjects());
		if (sol.select_all)
			cr.clearArray(sol.else_instances);
		var current_condition = this.runtime.getCurrentCondition();
		for (i = 0, k = 0, len = tmp_instances.length; i < len; i++)
		{
			inst = tmp_instances[i];
			tmp_instances[k] = inst;
			exp_ = current_condition.parameters[1].get(i);
			if (exp_)
			{
				k++;
			}
			else
			{
				sol.else_instances.push(inst);
			}
		}
		cr.truncateArray(tmp_instances, k);
		sol.select_all = false;
		cr.shallowAssignArray(sol.instances, tmp_instances);
		cr.clearArray(tmp_instances);
		foreach_instanceptr--;
		obj_.applySolToContainer();
		return !!sol.instances.length;
	};
    SysCnds.prototype.TriggerOnce = function ()
    {
        var cndextra = this.runtime.getCurrentCondition().extra;
		if (typeof cndextra["TriggerOnce_lastTick"] === "undefined")
			cndextra["TriggerOnce_lastTick"] = -1;
        var last_tick = cndextra["TriggerOnce_lastTick"];
        var cur_tick = this.runtime.tickcount;
        cndextra["TriggerOnce_lastTick"] = cur_tick;
        return this.runtime.layout_first_tick || last_tick !== cur_tick - 1;
    };
    SysCnds.prototype.Every = function (seconds)
    {
        var cnd = this.runtime.getCurrentCondition();
        var last_time = cnd.extra["Every_lastTime"] || 0;
        var cur_time = this.runtime.kahanTime.sum;
		if (typeof cnd.extra["Every_seconds"] === "undefined")
			cnd.extra["Every_seconds"] = seconds;
		var this_seconds = cnd.extra["Every_seconds"];
        if (cur_time >= last_time + this_seconds)
        {
            cnd.extra["Every_lastTime"] = last_time + this_seconds;
			if (cur_time >= cnd.extra["Every_lastTime"] + 0.04)
			{
				cnd.extra["Every_lastTime"] = cur_time;
			}
			cnd.extra["Every_seconds"] = seconds;
            return true;
        }
		else if (cur_time < last_time - 0.1)
		{
			cnd.extra["Every_lastTime"] = cur_time;
		}
		return false;
    };
    SysCnds.prototype.PickNth = function (obj, index)
    {
        if (!obj)
            return false;
        var sol = obj.getCurrentSol();
        var instances = sol.getObjects();
		index = cr.floor(index);
        if (index < 0 || index >= instances.length)
            return false;
		var inst = instances[index];
        sol.pick_one(inst);
		obj.applySolToContainer();
        return true;
    };
	SysCnds.prototype.PickRandom = function (obj)
    {
        if (!obj)
            return false;
        var sol = obj.getCurrentSol();
        var instances = sol.getObjects();
		var index = cr.floor(Math.random() * instances.length);
        if (index >= instances.length)
            return false;
		var inst = instances[index];
        sol.pick_one(inst);
		obj.applySolToContainer();
        return true;
    };
	SysCnds.prototype.CompareVar = function (v, cmp, val)
    {
        return cr.do_cmp(v.getValue(), cmp, val);
    };
    SysCnds.prototype.IsGroupActive = function (group)
    {
		var g = this.runtime.groups_by_name[group.toLowerCase()];
        return g && g.group_active;
    };
	SysCnds.prototype.IsPreview = function ()
	{
		return typeof cr_is_preview !== "undefined";
	};
	SysCnds.prototype.PickAll = function (obj)
    {
        if (!obj)
            return false;
		if (!obj.instances.length)
			return false;
        var sol = obj.getCurrentSol();
        sol.select_all = true;
		obj.applySolToContainer();
        return true;
    };
	SysCnds.prototype.IsMobile = function ()
	{
		return this.runtime.isMobile;
	};
	SysCnds.prototype.CompareBetween = function (x, a, b)
	{
		return x >= a && x <= b;
	};
	SysCnds.prototype.Else = function ()
	{
		var current_frame = this.runtime.getCurrentEventStack();
		if (current_frame.else_branch_ran)
			return false;		// another event in this else-if chain has run
		else
			return !current_frame.last_event_true;
		/*
		var current_frame = this.runtime.getCurrentEventStack();
        var current_event = current_frame.current_event;
		var prev_event = current_event.prev_block;
		if (!prev_event)
			return false;
		if (prev_event.is_logical)
			return !this.runtime.last_event_true;
		var i, len, j, lenj, s, sol, temp, inst, any_picked = false;
		for (i = 0, len = prev_event.cndReferences.length; i < len; i++)
		{
			s = prev_event.cndReferences[i];
			sol = s.getCurrentSol();
			if (sol.select_all || sol.instances.length === s.instances.length)
			{
				sol.select_all = false;
				sol.instances.length = 0;
			}
			else
			{
				if (sol.instances.length === 1 && sol.else_instances.length === 0 && s.instances.length >= 2)
				{
					inst = sol.instances[0];
					sol.instances.length = 0;
					for (j = 0, lenj = s.instances.length; j < lenj; j++)
					{
						if (s.instances[j] != inst)
							sol.instances.push(s.instances[j]);
					}
					any_picked = true;
				}
				else
				{
					temp = sol.instances;
					sol.instances = sol.else_instances;
					sol.else_instances = temp;
					any_picked = true;
				}
			}
		}
		return any_picked;
		*/
	};
	SysCnds.prototype.OnLoadFinished = function ()
	{
		return true;
	};
	SysCnds.prototype.OnCanvasSnapshot = function ()
	{
		return true;
	};
	SysCnds.prototype.EffectsSupported = function ()
	{
		return !!this.runtime.glwrap;
	};
	SysCnds.prototype.OnSaveComplete = function ()
	{
		return true;
	};
	SysCnds.prototype.OnSaveFailed = function ()
	{
		return true;
	};
	SysCnds.prototype.OnLoadComplete = function ()
	{
		return true;
	};
	SysCnds.prototype.OnLoadFailed = function ()
	{
		return true;
	};
	SysCnds.prototype.ObjectUIDExists = function (u)
	{
		return !!this.runtime.getObjectByUID(u);
	};
	SysCnds.prototype.IsOnPlatform = function (p)
	{
		var rt = this.runtime;
		switch (p) {
		case 0:		// HTML5 website
			return !rt.isDomFree && !rt.isNodeWebkit && !rt.isCordova && !rt.isWinJS && !rt.isWindowsPhone8 && !rt.isBlackberry10 && !rt.isAmazonWebApp;
		case 1:		// iOS
			return rt.isiOS;
		case 2:		// Android
			return rt.isAndroid;
		case 3:		// Windows 8
			return rt.isWindows8App;
		case 4:		// Windows Phone 8
			return rt.isWindowsPhone8;
		case 5:		// Blackberry 10
			return rt.isBlackberry10;
		case 6:		// Tizen
			return rt.isTizen;
		case 7:		// CocoonJS
			return rt.isCocoonJs;
		case 8:		// Cordova
			return rt.isCordova;
		case 9:	// Scirra Arcade
			return rt.isArcade;
		case 10:	// node-webkit
			return rt.isNodeWebkit;
		case 11:	// crosswalk
			return rt.isCrosswalk;
		case 12:	// amazon webapp
			return rt.isAmazonWebApp;
		case 13:	// windows 10 app
			return rt.isWindows10;
		default:	// should not be possible
			return false;
		}
	};
	var cacheRegex = null;
	var lastRegex = "";
	var lastFlags = "";
	function getRegex(regex_, flags_)
	{
		if (!cacheRegex || regex_ !== lastRegex || flags_ !== lastFlags)
		{
			cacheRegex = new RegExp(regex_, flags_);
			lastRegex = regex_;
			lastFlags = flags_;
		}
		cacheRegex.lastIndex = 0;		// reset
		return cacheRegex;
	};
	SysCnds.prototype.RegexTest = function (str_, regex_, flags_)
	{
		var regex = getRegex(regex_, flags_);
		return regex.test(str_);
	};
	var tmp_arr = [];
	SysCnds.prototype.PickOverlappingPoint = function (obj_, x_, y_)
	{
		if (!obj_)
            return false;
        var sol = obj_.getCurrentSol();
        var instances = sol.getObjects();
		var current_event = this.runtime.getCurrentEventStack().current_event;
		var orblock = current_event.orblock;
		var cnd = this.runtime.getCurrentCondition();
		var i, len, inst, pick;
		if (sol.select_all)
		{
			cr.shallowAssignArray(tmp_arr, instances);
			cr.clearArray(sol.else_instances);
			sol.select_all = false;
			cr.clearArray(sol.instances);
		}
		else
		{
			if (orblock)
			{
				cr.shallowAssignArray(tmp_arr, sol.else_instances);
				cr.clearArray(sol.else_instances);
			}
			else
			{
				cr.shallowAssignArray(tmp_arr, instances);
				cr.clearArray(sol.instances);
			}
		}
		for (i = 0, len = tmp_arr.length; i < len; ++i)
		{
			inst = tmp_arr[i];
			inst.update_bbox();
			pick = cr.xor(inst.contains_pt(x_, y_), cnd.inverted);
			if (pick)
				sol.instances.push(inst);
			else
				sol.else_instances.push(inst);
		}
		obj_.applySolToContainer();
		return cr.xor(!!sol.instances.length, cnd.inverted);
	};
	SysCnds.prototype.IsNaN = function (n)
	{
		return !!isNaN(n);
	};
	SysCnds.prototype.AngleWithin = function (a1, within, a2)
	{
		return cr.angleDiff(cr.to_radians(a1), cr.to_radians(a2)) <= cr.to_radians(within);
	};
	SysCnds.prototype.IsClockwiseFrom = function (a1, a2)
	{
		return cr.angleClockwise(cr.to_radians(a1), cr.to_radians(a2));
	};
	SysCnds.prototype.IsBetweenAngles = function (a, la, ua)
	{
		var angle = cr.to_clamped_radians(a);
		var lower = cr.to_clamped_radians(la);
		var upper = cr.to_clamped_radians(ua);
		var obtuse = (!cr.angleClockwise(upper, lower));
		if (obtuse)
			return !(!cr.angleClockwise(angle, lower) && cr.angleClockwise(angle, upper));
		else
			return cr.angleClockwise(angle, lower) && !cr.angleClockwise(angle, upper);
	};
	SysCnds.prototype.IsValueType = function (x, t)
	{
		if (typeof x === "number")
			return t === 0;
		else		// string
			return t === 1;
	};
	sysProto.cnds = new SysCnds();
    function SysActs() {};
    SysActs.prototype.GoToLayout = function (to)
    {
		if (this.runtime.isloading)
			return;		// cannot change layout while loading on loader layout
		if (this.runtime.changelayout)
			return;		// already changing to a different layout
;
        this.runtime.changelayout = to;
    };
	SysActs.prototype.NextPrevLayout = function (prev)
    {
		if (this.runtime.isloading)
			return;		// cannot change layout while loading on loader layout
		if (this.runtime.changelayout)
			return;		// already changing to a different layout
		var index = this.runtime.layouts_by_index.indexOf(this.runtime.running_layout);
		if (prev && index === 0)
			return;		// cannot go to previous layout from first layout
		if (!prev && index === this.runtime.layouts_by_index.length - 1)
			return;		// cannot go to next layout from last layout
		var to = this.runtime.layouts_by_index[index + (prev ? -1 : 1)];
;
        this.runtime.changelayout = to;
    };
    SysActs.prototype.CreateObject = function (obj, layer, x, y)
    {
        if (!layer || !obj)
            return;
        var inst = this.runtime.createInstance(obj, layer, x, y);
		if (!inst)
			return;
		this.runtime.isInOnDestroy++;
		var i, len, s;
		this.runtime.trigger(Object.getPrototypeOf(obj.plugin).cnds.OnCreated, inst);
		if (inst.is_contained)
		{
			for (i = 0, len = inst.siblings.length; i < len; i++)
			{
				s = inst.siblings[i];
				this.runtime.trigger(Object.getPrototypeOf(s.type.plugin).cnds.OnCreated, s);
			}
		}
		this.runtime.isInOnDestroy--;
        var sol = obj.getCurrentSol();
        sol.select_all = false;
		cr.clearArray(sol.instances);
		sol.instances[0] = inst;
		if (inst.is_contained)
		{
			for (i = 0, len = inst.siblings.length; i < len; i++)
			{
				s = inst.siblings[i];
				sol = s.type.getCurrentSol();
				sol.select_all = false;
				cr.clearArray(sol.instances);
				sol.instances[0] = s;
			}
		}
    };
    SysActs.prototype.SetLayerVisible = function (layer, visible_)
    {
        if (!layer)
            return;
		if (layer.visible !== visible_)
		{
			layer.visible = visible_;
			this.runtime.redraw = true;
		}
    };
	SysActs.prototype.SetLayerOpacity = function (layer, opacity_)
	{
		if (!layer)
			return;
		opacity_ = cr.clamp(opacity_ / 100, 0, 1);
		if (layer.opacity !== opacity_)
		{
			layer.opacity = opacity_;
			this.runtime.redraw = true;
		}
	};
	SysActs.prototype.SetLayerScaleRate = function (layer, sr)
	{
		if (!layer)
			return;
		if (layer.zoomRate !== sr)
		{
			layer.zoomRate = sr;
			this.runtime.redraw = true;
		}
	};
	SysActs.prototype.SetLayerForceOwnTexture = function (layer, f)
	{
		if (!layer)
			return;
		f = !!f;
		if (layer.forceOwnTexture !== f)
		{
			layer.forceOwnTexture = f;
			this.runtime.redraw = true;
		}
	};
	SysActs.prototype.SetLayoutScale = function (s)
	{
		if (!this.runtime.running_layout)
			return;
		if (this.runtime.running_layout.scale !== s)
		{
			this.runtime.running_layout.scale = s;
			this.runtime.running_layout.boundScrolling();
			this.runtime.redraw = true;
		}
	};
    SysActs.prototype.ScrollX = function(x)
    {
        this.runtime.running_layout.scrollToX(x);
    };
    SysActs.prototype.ScrollY = function(y)
    {
        this.runtime.running_layout.scrollToY(y);
    };
    SysActs.prototype.Scroll = function(x, y)
    {
        this.runtime.running_layout.scrollToX(x);
        this.runtime.running_layout.scrollToY(y);
    };
    SysActs.prototype.ScrollToObject = function(obj)
    {
        var inst = obj.getFirstPicked();
        if (inst)
        {
            this.runtime.running_layout.scrollToX(inst.x);
            this.runtime.running_layout.scrollToY(inst.y);
        }
    };
	SysActs.prototype.SetVar = function(v, x)
	{
;
		if (v.vartype === 0)
		{
			if (cr.is_number(x))
				v.setValue(x);
			else
				v.setValue(parseFloat(x));
		}
		else if (v.vartype === 1)
			v.setValue(x.toString());
	};
	SysActs.prototype.AddVar = function(v, x)
	{
;
		if (v.vartype === 0)
		{
			if (cr.is_number(x))
				v.setValue(v.getValue() + x);
			else
				v.setValue(v.getValue() + parseFloat(x));
		}
		else if (v.vartype === 1)
			v.setValue(v.getValue() + x.toString());
	};
	SysActs.prototype.SubVar = function(v, x)
	{
;
		if (v.vartype === 0)
		{
			if (cr.is_number(x))
				v.setValue(v.getValue() - x);
			else
				v.setValue(v.getValue() - parseFloat(x));
		}
	};
    SysActs.prototype.SetGroupActive = function (group, active)
    {
		var g = this.runtime.groups_by_name[group.toLowerCase()];
		if (!g)
			return;
		switch (active) {
		case 0:
			g.setGroupActive(false);
			break;
		case 1:
			g.setGroupActive(true);
			break;
		case 2:
			g.setGroupActive(!g.group_active);
			break;
		}
    };
    SysActs.prototype.SetTimescale = function (ts_)
    {
        var ts = ts_;
        if (ts < 0)
            ts = 0;
        this.runtime.timescale = ts;
    };
    SysActs.prototype.SetObjectTimescale = function (obj, ts_)
    {
        var ts = ts_;
        if (ts < 0)
            ts = 0;
        if (!obj)
            return;
        var sol = obj.getCurrentSol();
        var instances = sol.getObjects();
        var i, len;
        for (i = 0, len = instances.length; i < len; i++)
        {
            instances[i].my_timescale = ts;
        }
    };
    SysActs.prototype.RestoreObjectTimescale = function (obj)
    {
        if (!obj)
            return false;
        var sol = obj.getCurrentSol();
        var instances = sol.getObjects();
        var i, len;
        for (i = 0, len = instances.length; i < len; i++)
        {
            instances[i].my_timescale = -1.0;
        }
    };
	var waitobjrecycle = [];
	function allocWaitObject()
	{
		var w;
		if (waitobjrecycle.length)
			w = waitobjrecycle.pop();
		else
		{
			w = {};
			w.sols = {};
			w.solModifiers = [];
		}
		w.deleteme = false;
		return w;
	};
	function freeWaitObject(w)
	{
		cr.wipe(w.sols);
		cr.clearArray(w.solModifiers);
		waitobjrecycle.push(w);
	};
	var solstateobjects = [];
	function allocSolStateObject()
	{
		var s;
		if (solstateobjects.length)
			s = solstateobjects.pop();
		else
		{
			s = {};
			s.insts = [];
		}
		s.sa = false;
		return s;
	};
	function freeSolStateObject(s)
	{
		cr.clearArray(s.insts);
		solstateobjects.push(s);
	};
	SysActs.prototype.Wait = function (seconds)
	{
		if (seconds < 0)
			return;
		var i, len, s, t, ss;
		var evinfo = this.runtime.getCurrentEventStack();
		var waitobj = allocWaitObject();
		waitobj.time = this.runtime.kahanTime.sum + seconds;
		waitobj.signaltag = "";
		waitobj.signalled = false;
		waitobj.ev = evinfo.current_event;
		waitobj.actindex = evinfo.actindex + 1;	// pointing at next action
		for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
		{
			t = this.runtime.types_by_index[i];
			s = t.getCurrentSol();
			if (s.select_all && evinfo.current_event.solModifiers.indexOf(t) === -1)
				continue;
			waitobj.solModifiers.push(t);
			ss = allocSolStateObject();
			ss.sa = s.select_all;
			cr.shallowAssignArray(ss.insts, s.instances);
			waitobj.sols[i.toString()] = ss;
		}
		this.waits.push(waitobj);
		return true;
	};
	SysActs.prototype.WaitForSignal = function (tag)
	{
		var i, len, s, t, ss;
		var evinfo = this.runtime.getCurrentEventStack();
		var waitobj = allocWaitObject();
		waitobj.time = -1;
		waitobj.signaltag = tag.toLowerCase();
		waitobj.signalled = false;
		waitobj.ev = evinfo.current_event;
		waitobj.actindex = evinfo.actindex + 1;	// pointing at next action
		for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
		{
			t = this.runtime.types_by_index[i];
			s = t.getCurrentSol();
			if (s.select_all && evinfo.current_event.solModifiers.indexOf(t) === -1)
				continue;
			waitobj.solModifiers.push(t);
			ss = allocSolStateObject();
			ss.sa = s.select_all;
			cr.shallowAssignArray(ss.insts, s.instances);
			waitobj.sols[i.toString()] = ss;
		}
		this.waits.push(waitobj);
		return true;
	};
	SysActs.prototype.Signal = function (tag)
	{
		var lowertag = tag.toLowerCase();
		var i, len, w;
		for (i = 0, len = this.waits.length; i < len; ++i)
		{
			w = this.waits[i];
			if (w.time !== -1)
				continue;					// timer wait, ignore
			if (w.signaltag === lowertag)	// waiting for this signal
				w.signalled = true;			// will run on next check
		}
	};
	SysActs.prototype.SetLayerScale = function (layer, scale)
    {
        if (!layer)
            return;
		if (layer.scale === scale)
			return;
        layer.scale = scale;
        this.runtime.redraw = true;
    };
	SysActs.prototype.ResetGlobals = function ()
	{
		var i, len, g;
		for (i = 0, len = this.runtime.all_global_vars.length; i < len; i++)
		{
			g = this.runtime.all_global_vars[i];
			g.data = g.initial;
		}
	};
	SysActs.prototype.SetLayoutAngle = function (a)
	{
		a = cr.to_radians(a);
		a = cr.clamp_angle(a);
		if (this.runtime.running_layout)
		{
			if (this.runtime.running_layout.angle !== a)
			{
				this.runtime.running_layout.angle = a;
				this.runtime.redraw = true;
			}
		}
	};
	SysActs.prototype.SetLayerAngle = function (layer, a)
    {
        if (!layer)
            return;
		a = cr.to_radians(a);
		a = cr.clamp_angle(a);
		if (layer.angle === a)
			return;
        layer.angle = a;
        this.runtime.redraw = true;
    };
	SysActs.prototype.SetLayerParallax = function (layer, px, py)
    {
        if (!layer)
            return;
		if (layer.parallaxX === px / 100 && layer.parallaxY === py / 100)
			return;
        layer.parallaxX = px / 100;
		layer.parallaxY = py / 100;
		if (layer.parallaxX !== 1 || layer.parallaxY !== 1)
		{
			var i, len, instances = layer.instances;
			for (i = 0, len = instances.length; i < len; ++i)
			{
				instances[i].type.any_instance_parallaxed = true;
			}
		}
        this.runtime.redraw = true;
    };
	SysActs.prototype.SetLayerBackground = function (layer, c)
    {
        if (!layer)
            return;
		var r = cr.GetRValue(c);
		var g = cr.GetGValue(c);
		var b = cr.GetBValue(c);
		if (layer.background_color[0] === r && layer.background_color[1] === g && layer.background_color[2] === b)
			return;
        layer.background_color[0] = r;
		layer.background_color[1] = g;
		layer.background_color[2] = b;
        this.runtime.redraw = true;
    };
	SysActs.prototype.SetLayerTransparent = function (layer, t)
    {
        if (!layer)
            return;
		if (!!t === !!layer.transparent)
			return;
		layer.transparent = !!t;
        this.runtime.redraw = true;
    };
	SysActs.prototype.SetLayerBlendMode = function (layer, bm)
    {
        if (!layer)
            return;
		if (layer.blend_mode === bm)
			return;
		layer.blend_mode = bm;
		layer.compositeOp = cr.effectToCompositeOp(layer.blend_mode);
		if (this.runtime.gl)
			cr.setGLBlend(layer, layer.blend_mode, this.runtime.gl);
        this.runtime.redraw = true;
    };
	SysActs.prototype.StopLoop = function ()
	{
		if (this.runtime.loop_stack_index < 0)
			return;		// no loop currently running
		this.runtime.getCurrentLoop().stopped = true;
	};
	SysActs.prototype.GoToLayoutByName = function (layoutname)
	{
		if (this.runtime.isloading)
			return;		// cannot change layout while loading on loader layout
		if (this.runtime.changelayout)
			return;		// already changing to different layout
;
		var l;
		for (l in this.runtime.layouts)
		{
			if (this.runtime.layouts.hasOwnProperty(l) && cr.equals_nocase(l, layoutname))
			{
				this.runtime.changelayout = this.runtime.layouts[l];
				return;
			}
		}
	};
	SysActs.prototype.RestartLayout = function (layoutname)
	{
		if (this.runtime.isloading)
			return;		// cannot restart loader layouts
		if (this.runtime.changelayout)
			return;		// already changing to a different layout
;
		if (!this.runtime.running_layout)
			return;
		this.runtime.changelayout = this.runtime.running_layout;
		var i, len, g;
		for (i = 0, len = this.runtime.allGroups.length; i < len; i++)
		{
			g = this.runtime.allGroups[i];
			g.setGroupActive(g.initially_activated);
		}
	};
	SysActs.prototype.SnapshotCanvas = function (format_, quality_)
	{
		this.runtime.doCanvasSnapshot(format_ === 0 ? "image/png" : "image/jpeg", quality_ / 100);
	};
	SysActs.prototype.SetCanvasSize = function (w, h)
	{
		if (w <= 0 || h <= 0)
			return;
		var mode = this.runtime.fullscreen_mode;
		var isfullscreen = (document["mozFullScreen"] || document["webkitIsFullScreen"] || !!document["msFullscreenElement"] || document["fullScreen"] || this.runtime.isNodeFullscreen);
		if (isfullscreen && this.runtime.fullscreen_scaling > 0)
			mode = this.runtime.fullscreen_scaling;
		if (mode === 0)
		{
			this.runtime["setSize"](w, h, true);
		}
		else
		{
			this.runtime.original_width = w;
			this.runtime.original_height = h;
			this.runtime["setSize"](this.runtime.lastWindowWidth, this.runtime.lastWindowHeight, true);
		}
	};
	SysActs.prototype.SetLayoutEffectEnabled = function (enable_, effectname_)
	{
		if (!this.runtime.running_layout || !this.runtime.glwrap)
			return;
		var et = this.runtime.running_layout.getEffectByName(effectname_);
		if (!et)
			return;		// effect name not found
		var enable = (enable_ === 1);
		if (et.active == enable)
			return;		// no change
		et.active = enable;
		this.runtime.running_layout.updateActiveEffects();
		this.runtime.redraw = true;
	};
	SysActs.prototype.SetLayerEffectEnabled = function (layer, enable_, effectname_)
	{
		if (!layer || !this.runtime.glwrap)
			return;
		var et = layer.getEffectByName(effectname_);
		if (!et)
			return;		// effect name not found
		var enable = (enable_ === 1);
		if (et.active == enable)
			return;		// no change
		et.active = enable;
		layer.updateActiveEffects();
		this.runtime.redraw = true;
	};
	SysActs.prototype.SetLayoutEffectParam = function (effectname_, index_, value_)
	{
		if (!this.runtime.running_layout || !this.runtime.glwrap)
			return;
		var et = this.runtime.running_layout.getEffectByName(effectname_);
		if (!et)
			return;		// effect name not found
		var params = this.runtime.running_layout.effect_params[et.index];
		index_ = Math.floor(index_);
		if (index_ < 0 || index_ >= params.length)
			return;		// effect index out of bounds
		if (this.runtime.glwrap.getProgramParameterType(et.shaderindex, index_) === 1)
			value_ /= 100.0;
		if (params[index_] === value_)
			return;		// no change
		params[index_] = value_;
		if (et.active)
			this.runtime.redraw = true;
	};
	SysActs.prototype.SetLayerEffectParam = function (layer, effectname_, index_, value_)
	{
		if (!layer || !this.runtime.glwrap)
			return;
		var et = layer.getEffectByName(effectname_);
		if (!et)
			return;		// effect name not found
		var params = layer.effect_params[et.index];
		index_ = Math.floor(index_);
		if (index_ < 0 || index_ >= params.length)
			return;		// effect index out of bounds
		if (this.runtime.glwrap.getProgramParameterType(et.shaderindex, index_) === 1)
			value_ /= 100.0;
		if (params[index_] === value_)
			return;		// no change
		params[index_] = value_;
		if (et.active)
			this.runtime.redraw = true;
	};
	SysActs.prototype.SaveState = function (slot_)
	{
		this.runtime.saveToSlot = slot_;
	};
	SysActs.prototype.LoadState = function (slot_)
	{
		this.runtime.loadFromSlot = slot_;
	};
	SysActs.prototype.LoadStateJSON = function (jsonstr_)
	{
		this.runtime.loadFromJson = jsonstr_;
	};
	SysActs.prototype.SetHalfFramerateMode = function (set_)
	{
		this.runtime.halfFramerateMode = (set_ !== 0);
	};
	SysActs.prototype.SetFullscreenQuality = function (q)
	{
		var isfullscreen = (document["mozFullScreen"] || document["webkitIsFullScreen"] || !!document["msFullscreenElement"] || document["fullScreen"] || this.isNodeFullscreen);
		if (!isfullscreen && this.runtime.fullscreen_mode === 0)
			return;
		this.runtime.wantFullscreenScalingQuality = (q !== 0);
		this.runtime["setSize"](this.runtime.lastWindowWidth, this.runtime.lastWindowHeight, true);
	};
	SysActs.prototype.ResetPersisted = function ()
	{
		var i, len;
		for (i = 0, len = this.runtime.layouts_by_index.length; i < len; ++i)
		{
			this.runtime.layouts_by_index[i].persist_data = {};
			this.runtime.layouts_by_index[i].first_visit = true;
		}
	};
	SysActs.prototype.RecreateInitialObjects = function (obj, x1, y1, x2, y2)
	{
		if (!obj)
			return;
		this.runtime.running_layout.recreateInitialObjects(obj, x1, y1, x2, y2);
	};
	SysActs.prototype.SetPixelRounding = function (m)
	{
		this.runtime.pixel_rounding = (m !== 0);
		this.runtime.redraw = true;
	};
	SysActs.prototype.SetMinimumFramerate = function (f)
	{
		if (f < 1)
			f = 1;
		if (f > 120)
			f = 120;
		this.runtime.minimumFramerate = f;
	};
	function SortZOrderList(a, b)
	{
		var layerA = a[0];
		var layerB = b[0];
		var diff = layerA - layerB;
		if (diff !== 0)
			return diff;
		var indexA = a[1];
		var indexB = b[1];
		return indexA - indexB;
	};
	function SortInstancesByValue(a, b)
	{
		return a[1] - b[1];
	};
	SysActs.prototype.SortZOrderByInstVar = function (obj, iv)
	{
		if (!obj)
			return;
		var i, len, inst, value, r, layer, toZ;
		var sol = obj.getCurrentSol();
		var pickedInstances = sol.getObjects();
		var zOrderList = [];
		var instValues = [];
		var layout = this.runtime.running_layout;
		var isFamily = obj.is_family;
		var familyIndex = obj.family_index;
		for (i = 0, len = pickedInstances.length; i < len; ++i)
		{
			inst = pickedInstances[i];
			if (!inst.layer)
				continue;		// not a world instance
			if (isFamily)
				value = inst.instance_vars[iv + inst.type.family_var_map[familyIndex]];
			else
				value = inst.instance_vars[iv];
			zOrderList.push([
				inst.layer.index,
				inst.get_zindex()
			]);
			instValues.push([
				inst,
				value
			]);
		}
		if (!zOrderList.length)
			return;				// no instances were world instances
		zOrderList.sort(SortZOrderList);
		instValues.sort(SortInstancesByValue);
		for (i = 0, len = zOrderList.length; i < len; ++i)
		{
			inst = instValues[i][0];					// instance in the order we want
			layer = layout.layers[zOrderList[i][0]];	// layer to put it on
			toZ = zOrderList[i][1];						// Z index on that layer to put it
			if (layer.instances[toZ] !== inst)			// not already got this instance there
			{
				layer.instances[toZ] = inst;			// update instance
				inst.layer = layer;						// update instance's layer reference (could have changed)
				layer.setZIndicesStaleFrom(toZ);		// mark Z indices stale from this point since they have changed
			}
		}
	};
	sysProto.acts = new SysActs();
    function SysExps() {};
    SysExps.prototype["int"] = function(ret, x)
    {
        if (cr.is_string(x))
        {
            ret.set_int(parseInt(x, 10));
            if (isNaN(ret.data))
                ret.data = 0;
        }
        else
            ret.set_int(x);
    };
    SysExps.prototype["float"] = function(ret, x)
    {
        if (cr.is_string(x))
        {
            ret.set_float(parseFloat(x));
            if (isNaN(ret.data))
                ret.data = 0;
        }
        else
            ret.set_float(x);
    };
    SysExps.prototype.str = function(ret, x)
    {
        if (cr.is_string(x))
            ret.set_string(x);
        else
            ret.set_string(x.toString());
    };
    SysExps.prototype.len = function(ret, x)
    {
        ret.set_int(x.length || 0);
    };
    SysExps.prototype.random = function (ret, a, b)
    {
        if (b === undefined)
        {
            ret.set_float(Math.random() * a);
        }
        else
        {
            ret.set_float(Math.random() * (b - a) + a);
        }
    };
    SysExps.prototype.sqrt = function(ret, x)
    {
        ret.set_float(Math.sqrt(x));
    };
    SysExps.prototype.abs = function(ret, x)
    {
        ret.set_float(Math.abs(x));
    };
    SysExps.prototype.round = function(ret, x)
    {
        ret.set_int(Math.round(x));
    };
    SysExps.prototype.floor = function(ret, x)
    {
        ret.set_int(Math.floor(x));
    };
    SysExps.prototype.ceil = function(ret, x)
    {
        ret.set_int(Math.ceil(x));
    };
    SysExps.prototype.sin = function(ret, x)
    {
        ret.set_float(Math.sin(cr.to_radians(x)));
    };
    SysExps.prototype.cos = function(ret, x)
    {
        ret.set_float(Math.cos(cr.to_radians(x)));
    };
    SysExps.prototype.tan = function(ret, x)
    {
        ret.set_float(Math.tan(cr.to_radians(x)));
    };
    SysExps.prototype.asin = function(ret, x)
    {
        ret.set_float(cr.to_degrees(Math.asin(x)));
    };
    SysExps.prototype.acos = function(ret, x)
    {
        ret.set_float(cr.to_degrees(Math.acos(x)));
    };
    SysExps.prototype.atan = function(ret, x)
    {
        ret.set_float(cr.to_degrees(Math.atan(x)));
    };
    SysExps.prototype.exp = function(ret, x)
    {
        ret.set_float(Math.exp(x));
    };
    SysExps.prototype.ln = function(ret, x)
    {
        ret.set_float(Math.log(x));
    };
    SysExps.prototype.log10 = function(ret, x)
    {
        ret.set_float(Math.log(x) / Math.LN10);
    };
    SysExps.prototype.max = function(ret)
    {
		var max_ = arguments[1];
		if (typeof max_ !== "number")
			max_ = 0;
		var i, len, a;
		for (i = 2, len = arguments.length; i < len; i++)
		{
			a = arguments[i];
			if (typeof a !== "number")
				continue;		// ignore non-numeric types
			if (max_ < a)
				max_ = a;
		}
		ret.set_float(max_);
    };
    SysExps.prototype.min = function(ret)
    {
        var min_ = arguments[1];
		if (typeof min_ !== "number")
			min_ = 0;
		var i, len, a;
		for (i = 2, len = arguments.length; i < len; i++)
		{
			a = arguments[i];
			if (typeof a !== "number")
				continue;		// ignore non-numeric types
			if (min_ > a)
				min_ = a;
		}
		ret.set_float(min_);
    };
    SysExps.prototype.dt = function(ret)
    {
        ret.set_float(this.runtime.dt);
    };
    SysExps.prototype.timescale = function(ret)
    {
        ret.set_float(this.runtime.timescale);
    };
    SysExps.prototype.wallclocktime = function(ret)
    {
        ret.set_float((Date.now() - this.runtime.start_time) / 1000.0);
    };
    SysExps.prototype.time = function(ret)
    {
        ret.set_float(this.runtime.kahanTime.sum);
    };
    SysExps.prototype.tickcount = function(ret)
    {
        ret.set_int(this.runtime.tickcount);
    };
    SysExps.prototype.objectcount = function(ret)
    {
        ret.set_int(this.runtime.objectcount);
    };
    SysExps.prototype.fps = function(ret)
    {
        ret.set_int(this.runtime.fps);
    };
    SysExps.prototype.loopindex = function(ret, name_)
    {
		var loop, i, len;
        if (!this.runtime.loop_stack.length)
        {
            ret.set_int(0);
            return;
        }
        if (name_)
        {
            for (i = this.runtime.loop_stack_index; i >= 0; --i)
            {
                loop = this.runtime.loop_stack[i];
                if (loop.name === name_)
                {
                    ret.set_int(loop.index);
                    return;
                }
            }
            ret.set_int(0);
        }
        else
        {
			loop = this.runtime.getCurrentLoop();
			ret.set_int(loop ? loop.index : -1);
        }
    };
    SysExps.prototype.distance = function(ret, x1, y1, x2, y2)
    {
        ret.set_float(cr.distanceTo(x1, y1, x2, y2));
    };
    SysExps.prototype.angle = function(ret, x1, y1, x2, y2)
    {
        ret.set_float(cr.to_degrees(cr.angleTo(x1, y1, x2, y2)));
    };
    SysExps.prototype.scrollx = function(ret)
    {
        ret.set_float(this.runtime.running_layout.scrollX);
    };
    SysExps.prototype.scrolly = function(ret)
    {
        ret.set_float(this.runtime.running_layout.scrollY);
    };
    SysExps.prototype.newline = function(ret)
    {
        ret.set_string("\n");
    };
    SysExps.prototype.lerp = function(ret, a, b, x)
    {
        ret.set_float(cr.lerp(a, b, x));
    };
	SysExps.prototype.qarp = function(ret, a, b, c, x)
    {
        ret.set_float(cr.qarp(a, b, c, x));
    };
	SysExps.prototype.cubic = function(ret, a, b, c, d, x)
    {
        ret.set_float(cr.cubic(a, b, c, d, x));
    };
	SysExps.prototype.cosp = function(ret, a, b, x)
    {
        ret.set_float(cr.cosp(a, b, x));
    };
    SysExps.prototype.windowwidth = function(ret)
    {
        ret.set_int(this.runtime.width);
    };
    SysExps.prototype.windowheight = function(ret)
    {
        ret.set_int(this.runtime.height);
    };
	SysExps.prototype.uppercase = function(ret, str)
	{
		ret.set_string(cr.is_string(str) ? str.toUpperCase() : "");
	};
	SysExps.prototype.lowercase = function(ret, str)
	{
		ret.set_string(cr.is_string(str) ? str.toLowerCase() : "");
	};
	SysExps.prototype.clamp = function(ret, x, l, u)
	{
		if (x < l)
			ret.set_float(l);
		else if (x > u)
			ret.set_float(u);
		else
			ret.set_float(x);
	};
	SysExps.prototype.layerscale = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		if (!layer)
			ret.set_float(0);
		else
			ret.set_float(layer.scale);
	};
	SysExps.prototype.layeropacity = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		if (!layer)
			ret.set_float(0);
		else
			ret.set_float(layer.opacity * 100);
	};
	SysExps.prototype.layerscalerate = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		if (!layer)
			ret.set_float(0);
		else
			ret.set_float(layer.zoomRate);
	};
	SysExps.prototype.layerparallaxx = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		if (!layer)
			ret.set_float(0);
		else
			ret.set_float(layer.parallaxX * 100);
	};
	SysExps.prototype.layerparallaxy = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		if (!layer)
			ret.set_float(0);
		else
			ret.set_float(layer.parallaxY * 100);
	};
	SysExps.prototype.layerindex = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		if (!layer)
			ret.set_int(-1);
		else
			ret.set_int(layer.index);
	};
	SysExps.prototype.layoutscale = function (ret)
	{
		if (this.runtime.running_layout)
			ret.set_float(this.runtime.running_layout.scale);
		else
			ret.set_float(0);
	};
	SysExps.prototype.layoutangle = function (ret)
	{
		ret.set_float(cr.to_degrees(this.runtime.running_layout.angle));
	};
	SysExps.prototype.layerangle = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		if (!layer)
			ret.set_float(0);
		else
			ret.set_float(cr.to_degrees(layer.angle));
	};
	SysExps.prototype.layoutwidth = function (ret)
	{
		ret.set_int(this.runtime.running_layout.width);
	};
	SysExps.prototype.layoutheight = function (ret)
	{
		ret.set_int(this.runtime.running_layout.height);
	};
	SysExps.prototype.find = function (ret, text, searchstr)
	{
		if (cr.is_string(text) && cr.is_string(searchstr))
			ret.set_int(text.search(new RegExp(cr.regexp_escape(searchstr), "i")));
		else
			ret.set_int(-1);
	};
	SysExps.prototype.findcase = function (ret, text, searchstr)
	{
		if (cr.is_string(text) && cr.is_string(searchstr))
			ret.set_int(text.search(new RegExp(cr.regexp_escape(searchstr), "")));
		else
			ret.set_int(-1);
	};
	SysExps.prototype.left = function (ret, text, n)
	{
		ret.set_string(cr.is_string(text) ? text.substr(0, n) : "");
	};
	SysExps.prototype.right = function (ret, text, n)
	{
		ret.set_string(cr.is_string(text) ? text.substr(text.length - n) : "");
	};
	SysExps.prototype.mid = function (ret, text, index_, length_)
	{
		ret.set_string(cr.is_string(text) ? text.substr(index_, length_) : "");
	};
	SysExps.prototype.tokenat = function (ret, text, index_, sep)
	{
		if (cr.is_string(text) && cr.is_string(sep))
		{
			var arr = text.split(sep);
			var i = cr.floor(index_);
			if (i < 0 || i >= arr.length)
				ret.set_string("");
			else
				ret.set_string(arr[i]);
		}
		else
			ret.set_string("");
	};
	SysExps.prototype.tokencount = function (ret, text, sep)
	{
		if (cr.is_string(text) && text.length)
			ret.set_int(text.split(sep).length);
		else
			ret.set_int(0);
	};
	SysExps.prototype.replace = function (ret, text, find_, replace_)
	{
		if (cr.is_string(text) && cr.is_string(find_) && cr.is_string(replace_))
			ret.set_string(text.replace(new RegExp(cr.regexp_escape(find_), "gi"), replace_));
		else
			ret.set_string(cr.is_string(text) ? text : "");
	};
	SysExps.prototype.trim = function (ret, text)
	{
		ret.set_string(cr.is_string(text) ? text.trim() : "");
	};
	SysExps.prototype.pi = function (ret)
	{
		ret.set_float(cr.PI);
	};
	SysExps.prototype.layoutname = function (ret)
	{
		if (this.runtime.running_layout)
			ret.set_string(this.runtime.running_layout.name);
		else
			ret.set_string("");
	};
	SysExps.prototype.renderer = function (ret)
	{
		ret.set_string(this.runtime.gl ? "webgl" : "canvas2d");
	};
	SysExps.prototype.rendererdetail = function (ret)
	{
		ret.set_string(this.runtime.glUnmaskedRenderer);
	};
	SysExps.prototype.anglediff = function (ret, a, b)
	{
		ret.set_float(cr.to_degrees(cr.angleDiff(cr.to_radians(a), cr.to_radians(b))));
	};
	SysExps.prototype.choose = function (ret)
	{
		var index = cr.floor(Math.random() * (arguments.length - 1));
		ret.set_any(arguments[index + 1]);
	};
	SysExps.prototype.rgb = function (ret, r, g, b)
	{
		ret.set_int(cr.RGB(r, g, b));
	};
	SysExps.prototype.projectversion = function (ret)
	{
		ret.set_string(this.runtime.versionstr);
	};
	SysExps.prototype.projectname = function (ret)
	{
		ret.set_string(this.runtime.projectName);
	};
	SysExps.prototype.anglelerp = function (ret, a, b, x)
	{
		a = cr.to_radians(a);
		b = cr.to_radians(b);
		var diff = cr.angleDiff(a, b);
		if (cr.angleClockwise(b, a))
		{
			ret.set_float(cr.to_clamped_degrees(a + diff * x));
		}
		else
		{
			ret.set_float(cr.to_clamped_degrees(a - diff * x));
		}
	};
	SysExps.prototype.anglerotate = function (ret, a, b, c)
	{
		a = cr.to_radians(a);
		b = cr.to_radians(b);
		c = cr.to_radians(c);
		ret.set_float(cr.to_clamped_degrees(cr.angleRotate(a, b, c)));
	};
	SysExps.prototype.zeropad = function (ret, n, d)
	{
		var s = (n < 0 ? "-" : "");
		if (n < 0) n = -n;
		var zeroes = d - n.toString().length;
		for (var i = 0; i < zeroes; i++)
			s += "0";
		ret.set_string(s + n.toString());
	};
	SysExps.prototype.cpuutilisation = function (ret)
	{
		ret.set_float(this.runtime.cpuutilisation / 1000);
	};
	SysExps.prototype.viewportleft = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.viewLeft : 0);
	};
	SysExps.prototype.viewporttop = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.viewTop : 0);
	};
	SysExps.prototype.viewportright = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.viewRight : 0);
	};
	SysExps.prototype.viewportbottom = function (ret, layerparam)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.viewBottom : 0);
	};
	SysExps.prototype.loadingprogress = function (ret)
	{
		ret.set_float(this.runtime.loadingprogress);
	};
	SysExps.prototype.unlerp = function(ret, a, b, y)
    {
        ret.set_float(cr.unlerp(a, b, y));
    };
	SysExps.prototype.canvassnapshot = function (ret)
	{
		ret.set_string(this.runtime.snapshotData);
	};
	SysExps.prototype.urlencode = function (ret, s)
	{
		ret.set_string(encodeURIComponent(s));
	};
	SysExps.prototype.urldecode = function (ret, s)
	{
		ret.set_string(decodeURIComponent(s));
	};
	SysExps.prototype.canvastolayerx = function (ret, layerparam, x, y)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.canvasToLayer(x, y, true) : 0);
	};
	SysExps.prototype.canvastolayery = function (ret, layerparam, x, y)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.canvasToLayer(x, y, false) : 0);
	};
	SysExps.prototype.layertocanvasx = function (ret, layerparam, x, y)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.layerToCanvas(x, y, true) : 0);
	};
	SysExps.prototype.layertocanvasy = function (ret, layerparam, x, y)
	{
		var layer = this.runtime.getLayer(layerparam);
		ret.set_float(layer ? layer.layerToCanvas(x, y, false) : 0);
	};
	SysExps.prototype.savestatejson = function (ret)
	{
		ret.set_string(this.runtime.lastSaveJson);
	};
	SysExps.prototype.imagememoryusage = function (ret)
	{
		if (this.runtime.glwrap)
			ret.set_float(Math.round(100 * this.runtime.glwrap.estimateVRAM() / (1024 * 1024)) / 100);
		else
			ret.set_float(0);
	};
	SysExps.prototype.regexsearch = function (ret, str_, regex_, flags_)
	{
		var regex = getRegex(regex_, flags_);
		ret.set_int(str_ ? str_.search(regex) : -1);
	};
	SysExps.prototype.regexreplace = function (ret, str_, regex_, flags_, replace_)
	{
		var regex = getRegex(regex_, flags_);
		ret.set_string(str_ ? str_.replace(regex, replace_) : "");
	};
	var regexMatches = [];
	var lastMatchesStr = "";
	var lastMatchesRegex = "";
	var lastMatchesFlags = "";
	function updateRegexMatches(str_, regex_, flags_)
	{
		if (str_ === lastMatchesStr && regex_ === lastMatchesRegex && flags_ === lastMatchesFlags)
			return;
		var regex = getRegex(regex_, flags_);
		regexMatches = str_.match(regex);
		lastMatchesStr = str_;
		lastMatchesRegex = regex_;
		lastMatchesFlags = flags_;
	};
	SysExps.prototype.regexmatchcount = function (ret, str_, regex_, flags_)
	{
		var regex = getRegex(regex_, flags_);
		updateRegexMatches(str_, regex_, flags_);
		ret.set_int(regexMatches ? regexMatches.length : 0);
	};
	SysExps.prototype.regexmatchat = function (ret, str_, regex_, flags_, index_)
	{
		index_ = Math.floor(index_);
		var regex = getRegex(regex_, flags_);
		updateRegexMatches(str_, regex_, flags_);
		if (!regexMatches || index_ < 0 || index_ >= regexMatches.length)
			ret.set_string("");
		else
			ret.set_string(regexMatches[index_]);
	};
	SysExps.prototype.infinity = function (ret)
	{
		ret.set_float(Infinity);
	};
	SysExps.prototype.setbit = function (ret, n, b, v)
	{
		n = n | 0;
		b = b | 0;
		v = (v !== 0 ? 1 : 0);
		ret.set_int((n & ~(1 << b)) | (v << b));
	};
	SysExps.prototype.togglebit = function (ret, n, b)
	{
		n = n | 0;
		b = b | 0;
		ret.set_int(n ^ (1 << b));
	};
	SysExps.prototype.getbit = function (ret, n, b)
	{
		n = n | 0;
		b = b | 0;
		ret.set_int((n & (1 << b)) ? 1 : 0);
	};
	SysExps.prototype.originalwindowwidth = function (ret)
	{
		ret.set_int(this.runtime.original_width);
	};
	SysExps.prototype.originalwindowheight = function (ret)
	{
		ret.set_int(this.runtime.original_height);
	};
	sysProto.exps = new SysExps();
	sysProto.runWaits = function ()
	{
		var i, j, len, w, k, s, ss;
		var evinfo = this.runtime.getCurrentEventStack();
		for (i = 0, len = this.waits.length; i < len; i++)
		{
			w = this.waits[i];
			if (w.time === -1)		// signalled wait
			{
				if (!w.signalled)
					continue;		// not yet signalled
			}
			else					// timer wait
			{
				if (w.time > this.runtime.kahanTime.sum)
					continue;		// timer not yet expired
			}
			evinfo.current_event = w.ev;
			evinfo.actindex = w.actindex;
			evinfo.cndindex = 0;
			for (k in w.sols)
			{
				if (w.sols.hasOwnProperty(k))
				{
					s = this.runtime.types_by_index[parseInt(k, 10)].getCurrentSol();
					ss = w.sols[k];
					s.select_all = ss.sa;
					cr.shallowAssignArray(s.instances, ss.insts);
					freeSolStateObject(ss);
				}
			}
			w.ev.resume_actions_and_subevents();
			this.runtime.clearSol(w.solModifiers);
			w.deleteme = true;
		}
		for (i = 0, j = 0, len = this.waits.length; i < len; i++)
		{
			w = this.waits[i];
			this.waits[j] = w;
			if (w.deleteme)
				freeWaitObject(w);
			else
				j++;
		}
		cr.truncateArray(this.waits, j);
	};
}());
;
(function () {
	cr.add_common_aces = function (m, pluginProto)
	{
		var singleglobal_ = m[1];
		var position_aces = m[3];
		var size_aces = m[4];
		var angle_aces = m[5];
		var appearance_aces = m[6];
		var zorder_aces = m[7];
		var effects_aces = m[8];
		if (!pluginProto.cnds)
			pluginProto.cnds = {};
		if (!pluginProto.acts)
			pluginProto.acts = {};
		if (!pluginProto.exps)
			pluginProto.exps = {};
		var cnds = pluginProto.cnds;
		var acts = pluginProto.acts;
		var exps = pluginProto.exps;
		if (position_aces)
		{
			cnds.CompareX = function (cmp, x)
			{
				return cr.do_cmp(this.x, cmp, x);
			};
			cnds.CompareY = function (cmp, y)
			{
				return cr.do_cmp(this.y, cmp, y);
			};
			cnds.IsOnScreen = function ()
			{
				var layer = this.layer;
				this.update_bbox();
				var bbox = this.bbox;
				return !(bbox.right < layer.viewLeft || bbox.bottom < layer.viewTop || bbox.left > layer.viewRight || bbox.top > layer.viewBottom);
			};
			cnds.IsOutsideLayout = function ()
			{
				this.update_bbox();
				var bbox = this.bbox;
				var layout = this.runtime.running_layout;
				return (bbox.right < 0 || bbox.bottom < 0 || bbox.left > layout.width || bbox.top > layout.height);
			};
			cnds.PickDistance = function (which, x, y)
			{
				var sol = this.getCurrentSol();
				var instances = sol.getObjects();
				if (!instances.length)
					return false;
				var inst = instances[0];
				var pickme = inst;
				var dist = cr.distanceTo(inst.x, inst.y, x, y);
				var i, len, d;
				for (i = 1, len = instances.length; i < len; i++)
				{
					inst = instances[i];
					d = cr.distanceTo(inst.x, inst.y, x, y);
					if ((which === 0 && d < dist) || (which === 1 && d > dist))
					{
						dist = d;
						pickme = inst;
					}
				}
				sol.pick_one(pickme);
				return true;
			};
			acts.SetX = function (x)
			{
				if (this.x !== x)
				{
					this.x = x;
					this.set_bbox_changed();
				}
			};
			acts.SetY = function (y)
			{
				if (this.y !== y)
				{
					this.y = y;
					this.set_bbox_changed();
				}
			};
			acts.SetPos = function (x, y)
			{
				if (this.x !== x || this.y !== y)
				{
					this.x = x;
					this.y = y;
					this.set_bbox_changed();
				}
			};
			acts.SetPosToObject = function (obj, imgpt)
			{
				var inst = obj.getPairedInstance(this);
				if (!inst)
					return;
				var newx, newy;
				if (inst.getImagePoint)
				{
					newx = inst.getImagePoint(imgpt, true);
					newy = inst.getImagePoint(imgpt, false);
				}
				else
				{
					newx = inst.x;
					newy = inst.y;
				}
				if (this.x !== newx || this.y !== newy)
				{
					this.x = newx;
					this.y = newy;
					this.set_bbox_changed();
				}
			};
			acts.MoveForward = function (dist)
			{
				if (dist !== 0)
				{
					this.x += Math.cos(this.angle) * dist;
					this.y += Math.sin(this.angle) * dist;
					this.set_bbox_changed();
				}
			};
			acts.MoveAtAngle = function (a, dist)
			{
				if (dist !== 0)
				{
					this.x += Math.cos(cr.to_radians(a)) * dist;
					this.y += Math.sin(cr.to_radians(a)) * dist;
					this.set_bbox_changed();
				}
			};
			exps.X = function (ret)
			{
				ret.set_float(this.x);
			};
			exps.Y = function (ret)
			{
				ret.set_float(this.y);
			};
			exps.dt = function (ret)
			{
				ret.set_float(this.runtime.getDt(this));
			};
		}
		if (size_aces)
		{
			cnds.CompareWidth = function (cmp, w)
			{
				return cr.do_cmp(this.width, cmp, w);
			};
			cnds.CompareHeight = function (cmp, h)
			{
				return cr.do_cmp(this.height, cmp, h);
			};
			acts.SetWidth = function (w)
			{
				if (this.width !== w)
				{
					this.width = w;
					this.set_bbox_changed();
				}
			};
			acts.SetHeight = function (h)
			{
				if (this.height !== h)
				{
					this.height = h;
					this.set_bbox_changed();
				}
			};
			acts.SetSize = function (w, h)
			{
				if (this.width !== w || this.height !== h)
				{
					this.width = w;
					this.height = h;
					this.set_bbox_changed();
				}
			};
			exps.Width = function (ret)
			{
				ret.set_float(this.width);
			};
			exps.Height = function (ret)
			{
				ret.set_float(this.height);
			};
			exps.BBoxLeft = function (ret)
			{
				this.update_bbox();
				ret.set_float(this.bbox.left);
			};
			exps.BBoxTop = function (ret)
			{
				this.update_bbox();
				ret.set_float(this.bbox.top);
			};
			exps.BBoxRight = function (ret)
			{
				this.update_bbox();
				ret.set_float(this.bbox.right);
			};
			exps.BBoxBottom = function (ret)
			{
				this.update_bbox();
				ret.set_float(this.bbox.bottom);
			};
		}
		if (angle_aces)
		{
			cnds.AngleWithin = function (within, a)
			{
				return cr.angleDiff(this.angle, cr.to_radians(a)) <= cr.to_radians(within);
			};
			cnds.IsClockwiseFrom = function (a)
			{
				return cr.angleClockwise(this.angle, cr.to_radians(a));
			};
			cnds.IsBetweenAngles = function (a, b)
			{
				var lower = cr.to_clamped_radians(a);
				var upper = cr.to_clamped_radians(b);
				var angle = cr.clamp_angle(this.angle);
				var obtuse = (!cr.angleClockwise(upper, lower));
				if (obtuse)
					return !(!cr.angleClockwise(angle, lower) && cr.angleClockwise(angle, upper));
				else
					return cr.angleClockwise(angle, lower) && !cr.angleClockwise(angle, upper);
			};
			acts.SetAngle = function (a)
			{
				var newangle = cr.to_radians(cr.clamp_angle_degrees(a));
				if (isNaN(newangle))
					return;
				if (this.angle !== newangle)
				{
					this.angle = newangle;
					this.set_bbox_changed();
				}
			};
			acts.RotateClockwise = function (a)
			{
				if (a !== 0 && !isNaN(a))
				{
					this.angle += cr.to_radians(a);
					this.angle = cr.clamp_angle(this.angle);
					this.set_bbox_changed();
				}
			};
			acts.RotateCounterclockwise = function (a)
			{
				if (a !== 0 && !isNaN(a))
				{
					this.angle -= cr.to_radians(a);
					this.angle = cr.clamp_angle(this.angle);
					this.set_bbox_changed();
				}
			};
			acts.RotateTowardAngle = function (amt, target)
			{
				var newangle = cr.angleRotate(this.angle, cr.to_radians(target), cr.to_radians(amt));
				if (isNaN(newangle))
					return;
				if (this.angle !== newangle)
				{
					this.angle = newangle;
					this.set_bbox_changed();
				}
			};
			acts.RotateTowardPosition = function (amt, x, y)
			{
				var dx = x - this.x;
				var dy = y - this.y;
				var target = Math.atan2(dy, dx);
				var newangle = cr.angleRotate(this.angle, target, cr.to_radians(amt));
				if (isNaN(newangle))
					return;
				if (this.angle !== newangle)
				{
					this.angle = newangle;
					this.set_bbox_changed();
				}
			};
			acts.SetTowardPosition = function (x, y)
			{
				var dx = x - this.x;
				var dy = y - this.y;
				var newangle = Math.atan2(dy, dx);
				if (isNaN(newangle))
					return;
				if (this.angle !== newangle)
				{
					this.angle = newangle;
					this.set_bbox_changed();
				}
			};
			exps.Angle = function (ret)
			{
				ret.set_float(cr.to_clamped_degrees(this.angle));
			};
		}
		if (!singleglobal_)
		{
			cnds.CompareInstanceVar = function (iv, cmp, val)
			{
				return cr.do_cmp(this.instance_vars[iv], cmp, val);
			};
			cnds.IsBoolInstanceVarSet = function (iv)
			{
				return this.instance_vars[iv];
			};
			cnds.PickInstVarHiLow = function (which, iv)
			{
				var sol = this.getCurrentSol();
				var instances = sol.getObjects();
				if (!instances.length)
					return false;
				var inst = instances[0];
				var pickme = inst;
				var val = inst.instance_vars[iv];
				var i, len, v;
				for (i = 1, len = instances.length; i < len; i++)
				{
					inst = instances[i];
					v = inst.instance_vars[iv];
					if ((which === 0 && v < val) || (which === 1 && v > val))
					{
						val = v;
						pickme = inst;
					}
				}
				sol.pick_one(pickme);
				return true;
			};
			cnds.PickByUID = function (u)
			{
				var i, len, j, inst, families, instances, sol;
				var cnd = this.runtime.getCurrentCondition();
				if (cnd.inverted)
				{
					sol = this.getCurrentSol();
					if (sol.select_all)
					{
						sol.select_all = false;
						cr.clearArray(sol.instances);
						cr.clearArray(sol.else_instances);
						instances = this.instances;
						for (i = 0, len = instances.length; i < len; i++)
						{
							inst = instances[i];
							if (inst.uid === u)
								sol.else_instances.push(inst);
							else
								sol.instances.push(inst);
						}
						this.applySolToContainer();
						return !!sol.instances.length;
					}
					else
					{
						for (i = 0, j = 0, len = sol.instances.length; i < len; i++)
						{
							inst = sol.instances[i];
							sol.instances[j] = inst;
							if (inst.uid === u)
							{
								sol.else_instances.push(inst);
							}
							else
								j++;
						}
						cr.truncateArray(sol.instances, j);
						this.applySolToContainer();
						return !!sol.instances.length;
					}
				}
				else
				{
					inst = this.runtime.getObjectByUID(u);
					if (!inst)
						return false;
					sol = this.getCurrentSol();
					if (!sol.select_all && sol.instances.indexOf(inst) === -1)
						return false;		// not picked
					if (this.is_family)
					{
						families = inst.type.families;
						for (i = 0, len = families.length; i < len; i++)
						{
							if (families[i] === this)
							{
								sol.pick_one(inst);
								this.applySolToContainer();
								return true;
							}
						}
					}
					else if (inst.type === this)
					{
						sol.pick_one(inst);
						this.applySolToContainer();
						return true;
					}
					return false;
				}
			};
			cnds.OnCreated = function ()
			{
				return true;
			};
			cnds.OnDestroyed = function ()
			{
				return true;
			};
			acts.SetInstanceVar = function (iv, val)
			{
				var myinstvars = this.instance_vars;
				if (cr.is_number(myinstvars[iv]))
				{
					if (cr.is_number(val))
						myinstvars[iv] = val;
					else
						myinstvars[iv] = parseFloat(val);
				}
				else if (cr.is_string(myinstvars[iv]))
				{
					if (cr.is_string(val))
						myinstvars[iv] = val;
					else
						myinstvars[iv] = val.toString();
				}
				else
;
			};
			acts.AddInstanceVar = function (iv, val)
			{
				var myinstvars = this.instance_vars;
				if (cr.is_number(myinstvars[iv]))
				{
					if (cr.is_number(val))
						myinstvars[iv] += val;
					else
						myinstvars[iv] += parseFloat(val);
				}
				else if (cr.is_string(myinstvars[iv]))
				{
					if (cr.is_string(val))
						myinstvars[iv] += val;
					else
						myinstvars[iv] += val.toString();
				}
				else
;
			};
			acts.SubInstanceVar = function (iv, val)
			{
				var myinstvars = this.instance_vars;
				if (cr.is_number(myinstvars[iv]))
				{
					if (cr.is_number(val))
						myinstvars[iv] -= val;
					else
						myinstvars[iv] -= parseFloat(val);
				}
				else
;
			};
			acts.SetBoolInstanceVar = function (iv, val)
			{
				this.instance_vars[iv] = val ? 1 : 0;
			};
			acts.ToggleBoolInstanceVar = function (iv)
			{
				this.instance_vars[iv] = 1 - this.instance_vars[iv];
			};
			acts.Destroy = function ()
			{
				this.runtime.DestroyInstance(this);
			};
			if (!acts.LoadFromJsonString)
			{
				acts.LoadFromJsonString = function (str_)
				{
					var o, i, len, binst;
					try {
						o = JSON.parse(str_);
					}
					catch (e) {
						return;
					}
					this.runtime.loadInstanceFromJSON(this, o, true);
					if (this.afterLoad)
						this.afterLoad();
					if (this.behavior_insts)
					{
						for (i = 0, len = this.behavior_insts.length; i < len; ++i)
						{
							binst = this.behavior_insts[i];
							if (binst.afterLoad)
								binst.afterLoad();
						}
					}
				};
			}
			exps.Count = function (ret)
			{
				var count = ret.object_class.instances.length;
				var i, len, inst;
				for (i = 0, len = this.runtime.createRow.length; i < len; i++)
				{
					inst = this.runtime.createRow[i];
					if (ret.object_class.is_family)
					{
						if (inst.type.families.indexOf(ret.object_class) >= 0)
							count++;
					}
					else
					{
						if (inst.type === ret.object_class)
							count++;
					}
				}
				ret.set_int(count);
			};
			exps.PickedCount = function (ret)
			{
				ret.set_int(ret.object_class.getCurrentSol().getObjects().length);
			};
			exps.UID = function (ret)
			{
				ret.set_int(this.uid);
			};
			exps.IID = function (ret)
			{
				ret.set_int(this.get_iid());
			};
			if (!exps.AsJSON)
			{
				exps.AsJSON = function (ret)
				{
					ret.set_string(JSON.stringify(this.runtime.saveInstanceToJSON(this, true)));
				};
			}
		}
		if (appearance_aces)
		{
			cnds.IsVisible = function ()
			{
				return this.visible;
			};
			acts.SetVisible = function (v)
			{
				if (!v !== !this.visible)
				{
					this.visible = !!v;
					this.runtime.redraw = true;
				}
			};
			cnds.CompareOpacity = function (cmp, x)
			{
				return cr.do_cmp(cr.round6dp(this.opacity * 100), cmp, x);
			};
			acts.SetOpacity = function (x)
			{
				var new_opacity = x / 100.0;
				if (new_opacity < 0)
					new_opacity = 0;
				else if (new_opacity > 1)
					new_opacity = 1;
				if (new_opacity !== this.opacity)
				{
					this.opacity = new_opacity;
					this.runtime.redraw = true;
				}
			};
			exps.Opacity = function (ret)
			{
				ret.set_float(cr.round6dp(this.opacity * 100.0));
			};
		}
		if (zorder_aces)
		{
			cnds.IsOnLayer = function (layer_)
			{
				if (!layer_)
					return false;
				return this.layer === layer_;
			};
			cnds.PickTopBottom = function (which_)
			{
				var sol = this.getCurrentSol();
				var instances = sol.getObjects();
				if (!instances.length)
					return false;
				var inst = instances[0];
				var pickme = inst;
				var i, len;
				for (i = 1, len = instances.length; i < len; i++)
				{
					inst = instances[i];
					if (which_ === 0)
					{
						if (inst.layer.index > pickme.layer.index || (inst.layer.index === pickme.layer.index && inst.get_zindex() > pickme.get_zindex()))
						{
							pickme = inst;
						}
					}
					else
					{
						if (inst.layer.index < pickme.layer.index || (inst.layer.index === pickme.layer.index && inst.get_zindex() < pickme.get_zindex()))
						{
							pickme = inst;
						}
					}
				}
				sol.pick_one(pickme);
				return true;
			};
			acts.MoveToTop = function ()
			{
				var layer = this.layer;
				var layer_instances = layer.instances;
				if (layer_instances.length && layer_instances[layer_instances.length - 1] === this)
					return;		// is already at top
				layer.removeFromInstanceList(this, false);
				layer.appendToInstanceList(this, false);
				this.runtime.redraw = true;
			};
			acts.MoveToBottom = function ()
			{
				var layer = this.layer;
				var layer_instances = layer.instances;
				if (layer_instances.length && layer_instances[0] === this)
					return;		// is already at bottom
				layer.removeFromInstanceList(this, false);
				layer.prependToInstanceList(this, false);
				this.runtime.redraw = true;
			};
			acts.MoveToLayer = function (layerMove)
			{
				if (!layerMove || layerMove == this.layer)
					return;
				this.layer.removeFromInstanceList(this, true);
				this.layer = layerMove;
				layerMove.appendToInstanceList(this, true);
				this.runtime.redraw = true;
			};
			acts.ZMoveToObject = function (where_, obj_)
			{
				var isafter = (where_ === 0);
				if (!obj_)
					return;
				var other = obj_.getFirstPicked(this);
				if (!other || other.uid === this.uid)
					return;
				if (this.layer.index !== other.layer.index)
				{
					this.layer.removeFromInstanceList(this, true);
					this.layer = other.layer;
					other.layer.appendToInstanceList(this, true);
				}
				this.layer.moveInstanceAdjacent(this, other, isafter);
				this.runtime.redraw = true;
			};
			exps.LayerNumber = function (ret)
			{
				ret.set_int(this.layer.number);
			};
			exps.LayerName = function (ret)
			{
				ret.set_string(this.layer.name);
			};
			exps.ZIndex = function (ret)
			{
				ret.set_int(this.get_zindex());
			};
		}
		if (effects_aces)
		{
			acts.SetEffectEnabled = function (enable_, effectname_)
			{
				if (!this.runtime.glwrap)
					return;
				var i = this.type.getEffectIndexByName(effectname_);
				if (i < 0)
					return;		// effect name not found
				var enable = (enable_ === 1);
				if (this.active_effect_flags[i] === enable)
					return;		// no change
				this.active_effect_flags[i] = enable;
				this.updateActiveEffects();
				this.runtime.redraw = true;
			};
			acts.SetEffectParam = function (effectname_, index_, value_)
			{
				if (!this.runtime.glwrap)
					return;
				var i = this.type.getEffectIndexByName(effectname_);
				if (i < 0)
					return;		// effect name not found
				var et = this.type.effect_types[i];
				var params = this.effect_params[i];
				index_ = Math.floor(index_);
				if (index_ < 0 || index_ >= params.length)
					return;		// effect index out of bounds
				if (this.runtime.glwrap.getProgramParameterType(et.shaderindex, index_) === 1)
					value_ /= 100.0;
				if (params[index_] === value_)
					return;		// no change
				params[index_] = value_;
				if (et.active)
					this.runtime.redraw = true;
			};
		}
	};
	cr.set_bbox_changed = function ()
	{
		this.bbox_changed = true;      		// will recreate next time box requested
		this.cell_changed = true;
		this.type.any_cell_changed = true;	// avoid unnecessary updateAllBBox() calls
		this.runtime.redraw = true;     	// assume runtime needs to redraw
		var i, len, callbacks = this.bbox_changed_callbacks;
		for (i = 0, len = callbacks.length; i < len; ++i)
		{
			callbacks[i](this);
		}
		if (this.layer.useRenderCells)
			this.update_bbox();
	};
	cr.add_bbox_changed_callback = function (f)
	{
		if (f)
		{
			this.bbox_changed_callbacks.push(f);
		}
	};
	cr.update_bbox = function ()
	{
		if (!this.bbox_changed)
			return;                 // bounding box not changed
		var bbox = this.bbox;
		var bquad = this.bquad;
		bbox.set(this.x, this.y, this.x + this.width, this.y + this.height);
		bbox.offset(-this.hotspotX * this.width, -this.hotspotY * this.height);
		if (!this.angle)
		{
			bquad.set_from_rect(bbox);    // make bounding quad from box
		}
		else
		{
			bbox.offset(-this.x, -this.y);       			// translate to origin
			bquad.set_from_rotated_rect(bbox, this.angle);	// rotate around origin
			bquad.offset(this.x, this.y);      				// translate back to original position
			bquad.bounding_box(bbox);
		}
		bbox.normalize();
		this.bbox_changed = false;  // bounding box up to date
		this.update_render_cell();
	};
	var tmprc = new cr.rect(0, 0, 0, 0);
	cr.update_render_cell = function ()
	{
		if (!this.layer.useRenderCells)
			return;
		var mygrid = this.layer.render_grid;
		var bbox = this.bbox;
		tmprc.set(mygrid.XToCell(bbox.left), mygrid.YToCell(bbox.top), mygrid.XToCell(bbox.right), mygrid.YToCell(bbox.bottom));
		if (this.rendercells.equals(tmprc))
			return;
		if (this.rendercells.right < this.rendercells.left)
			mygrid.update(this, null, tmprc);		// first insertion with invalid rect: don't provide old range
		else
			mygrid.update(this, this.rendercells, tmprc);
		this.rendercells.copy(tmprc);
		this.layer.render_list_stale = true;
	};
	cr.update_collision_cell = function ()
	{
		if (!this.cell_changed || !this.collisionsEnabled)
			return;
		this.update_bbox();
		var mygrid = this.type.collision_grid;
		var bbox = this.bbox;
		tmprc.set(mygrid.XToCell(bbox.left), mygrid.YToCell(bbox.top), mygrid.XToCell(bbox.right), mygrid.YToCell(bbox.bottom));
		if (this.collcells.equals(tmprc))
			return;
		if (this.collcells.right < this.collcells.left)
			mygrid.update(this, null, tmprc);		// first insertion with invalid rect: don't provide old range
		else
			mygrid.update(this, this.collcells, tmprc);
		this.collcells.copy(tmprc);
		this.cell_changed = false;
	};
	cr.inst_contains_pt = function (x, y)
	{
		if (!this.bbox.contains_pt(x, y))
			return false;
		if (!this.bquad.contains_pt(x, y))
			return false;
		if (this.collision_poly && !this.collision_poly.is_empty())
		{
			this.collision_poly.cache_poly(this.width, this.height, this.angle);
			return this.collision_poly.contains_pt(x - this.x, y - this.y);
		}
		else
			return true;
	};
	cr.inst_get_iid = function ()
	{
		this.type.updateIIDs();
		return this.iid;
	};
	cr.inst_get_zindex = function ()
	{
		this.layer.updateZIndices();
		return this.zindex;
	};
	cr.inst_updateActiveEffects = function ()
	{
		cr.clearArray(this.active_effect_types);
		var i, len, et;
		var preserves_opaqueness = true;
		for (i = 0, len = this.active_effect_flags.length; i < len; i++)
		{
			if (this.active_effect_flags[i])
			{
				et = this.type.effect_types[i];
				this.active_effect_types.push(et);
				if (!et.preservesOpaqueness)
					preserves_opaqueness = false;
			}
		}
		this.uses_shaders = !!this.active_effect_types.length;
		this.shaders_preserve_opaqueness = preserves_opaqueness;
	};
	cr.inst_toString = function ()
	{
		return "Inst" + this.puid;
	};
	cr.type_getFirstPicked = function (frominst)
	{
		if (frominst && frominst.is_contained && frominst.type != this)
		{
			var i, len, s;
			for (i = 0, len = frominst.siblings.length; i < len; i++)
			{
				s = frominst.siblings[i];
				if (s.type == this)
					return s;
			}
		}
		var instances = this.getCurrentSol().getObjects();
		if (instances.length)
			return instances[0];
		else
			return null;
	};
	cr.type_getPairedInstance = function (inst)
	{
		var instances = this.getCurrentSol().getObjects();
		if (instances.length)
			return instances[inst.get_iid() % instances.length];
		else
			return null;
	};
	cr.type_updateIIDs = function ()
	{
		if (!this.stale_iids || this.is_family)
			return;		// up to date or is family - don't want family to overwrite IIDs
		var i, len;
		for (i = 0, len = this.instances.length; i < len; i++)
			this.instances[i].iid = i;
		var next_iid = i;
		var createRow = this.runtime.createRow;
		for (i = 0, len = createRow.length; i < len; ++i)
		{
			if (createRow[i].type === this)
				createRow[i].iid = next_iid++;
		}
		this.stale_iids = false;
	};
	cr.type_getInstanceByIID = function (i)
	{
		if (i < this.instances.length)
			return this.instances[i];
		i -= this.instances.length;
		var createRow = this.runtime.createRow;
		var j, lenj;
		for (j = 0, lenj = createRow.length; j < lenj; ++j)
		{
			if (createRow[j].type === this)
			{
				if (i === 0)
					return createRow[j];
				--i;
			}
		}
;
		return null;
	};
	cr.type_getCurrentSol = function ()
	{
		return this.solstack[this.cur_sol];
	};
	cr.type_pushCleanSol = function ()
	{
		this.cur_sol++;
		if (this.cur_sol === this.solstack.length)
		{
			this.solstack.push(new cr.selection(this));
		}
		else
		{
			this.solstack[this.cur_sol].select_all = true;  // else clear next SOL
			cr.clearArray(this.solstack[this.cur_sol].else_instances);
		}
	};
	cr.type_pushCopySol = function ()
	{
		this.cur_sol++;
		if (this.cur_sol === this.solstack.length)
			this.solstack.push(new cr.selection(this));
		var clonesol = this.solstack[this.cur_sol];
		var prevsol = this.solstack[this.cur_sol - 1];
		if (prevsol.select_all)
		{
			clonesol.select_all = true;
			cr.clearArray(clonesol.else_instances);
		}
		else
		{
			clonesol.select_all = false;
			cr.shallowAssignArray(clonesol.instances, prevsol.instances);
			cr.shallowAssignArray(clonesol.else_instances, prevsol.else_instances);
		}
	};
	cr.type_popSol = function ()
	{
;
		this.cur_sol--;
	};
	cr.type_getBehaviorByName = function (behname)
	{
		var i, len, j, lenj, f, index = 0;
		if (!this.is_family)
		{
			for (i = 0, len = this.families.length; i < len; i++)
			{
				f = this.families[i];
				for (j = 0, lenj = f.behaviors.length; j < lenj; j++)
				{
					if (behname === f.behaviors[j].name)
					{
						this.extra["lastBehIndex"] = index;
						return f.behaviors[j];
					}
					index++;
				}
			}
		}
		for (i = 0, len = this.behaviors.length; i < len; i++) {
			if (behname === this.behaviors[i].name)
			{
				this.extra["lastBehIndex"] = index;
				return this.behaviors[i];
			}
			index++;
		}
		return null;
	};
	cr.type_getBehaviorIndexByName = function (behname)
	{
		var b = this.getBehaviorByName(behname);
		if (b)
			return this.extra["lastBehIndex"];
		else
			return -1;
	};
	cr.type_getEffectIndexByName = function (name_)
	{
		var i, len;
		for (i = 0, len = this.effect_types.length; i < len; i++)
		{
			if (this.effect_types[i].name === name_)
				return i;
		}
		return -1;
	};
	cr.type_applySolToContainer = function ()
	{
		if (!this.is_contained || this.is_family)
			return;
		var i, len, j, lenj, t, sol, sol2;
		this.updateIIDs();
		sol = this.getCurrentSol();
		var select_all = sol.select_all;
		var es = this.runtime.getCurrentEventStack();
		var orblock = es && es.current_event && es.current_event.orblock;
		for (i = 0, len = this.container.length; i < len; i++)
		{
			t = this.container[i];
			if (t === this)
				continue;
			t.updateIIDs();
			sol2 = t.getCurrentSol();
			sol2.select_all = select_all;
			if (!select_all)
			{
				cr.clearArray(sol2.instances);
				for (j = 0, lenj = sol.instances.length; j < lenj; ++j)
					sol2.instances[j] = t.getInstanceByIID(sol.instances[j].iid);
				if (orblock)
				{
					cr.clearArray(sol2.else_instances);
					for (j = 0, lenj = sol.else_instances.length; j < lenj; ++j)
						sol2.else_instances[j] = t.getInstanceByIID(sol.else_instances[j].iid);
				}
			}
		}
	};
	cr.type_toString = function ()
	{
		return "Type" + this.sid;
	};
	cr.do_cmp = function (x, cmp, y)
	{
		if (typeof x === "undefined" || typeof y === "undefined")
			return false;
		switch (cmp)
		{
			case 0:     // equal
				return x === y;
			case 1:     // not equal
				return x !== y;
			case 2:     // less
				return x < y;
			case 3:     // less/equal
				return x <= y;
			case 4:     // greater
				return x > y;
			case 5:     // greater/equal
				return x >= y;
			default:
;
				return false;
		}
	};
})();
cr.shaders = {};
;
;
cr.plugins_.Audio = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Audio.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
	};
	var audRuntime = null;
	var audInst = null;
	var audTag = "";
	var appPath = "";			// for Cordova only
	var API_HTML5 = 0;
	var API_WEBAUDIO = 1;
	var API_CORDOVA = 2;
	var API_APPMOBI = 3;
	var api = API_HTML5;
	var context = null;
	var audioBuffers = [];		// cache of buffers
	var audioInstances = [];	// cache of instances
	var lastAudio = null;
	var useOgg = false;			// determined at create time
	var timescale_mode = 0;
	var silent = false;
	var masterVolume = 1;
	var listenerX = 0;
	var listenerY = 0;
	var isContextSuspended = false;
	var panningModel = 1;		// HRTF
	var distanceModel = 1;		// Inverse
	var refDistance = 10;
	var maxDistance = 10000;
	var rolloffFactor = 1;
	var micSource = null;
	var micTag = "";
	var isMusicWorkaround = false;
	var musicPlayNextTouch = [];
	var playMusicAsSoundWorkaround = false;		// play music tracks with Web Audio API
	function dbToLinear(x)
	{
		var v = dbToLinear_nocap(x);
		if (!isFinite(v))	// accidentally passing a string can result in NaN; set volume to 0 if so
			v = 0;
		if (v < 0)
			v = 0;
		if (v > 1)
			v = 1;
		return v;
	};
	function linearToDb(x)
	{
		if (x < 0)
			x = 0;
		if (x > 1)
			x = 1;
		return linearToDb_nocap(x);
	};
	function dbToLinear_nocap(x)
	{
		return Math.pow(10, x / 20);
	};
	function linearToDb_nocap(x)
	{
		return (Math.log(x) / Math.log(10)) * 20;
	};
	var effects = {};
	function getDestinationForTag(tag)
	{
		tag = tag.toLowerCase();
		if (effects.hasOwnProperty(tag))
		{
			if (effects[tag].length)
				return effects[tag][0].getInputNode();
		}
		return context["destination"];
	};
	function createGain()
	{
		if (context["createGain"])
			return context["createGain"]();
		else
			return context["createGainNode"]();
	};
	function createDelay(d)
	{
		if (context["createDelay"])
			return context["createDelay"](d);
		else
			return context["createDelayNode"](d);
	};
	function startSource(s, scheduledTime)
	{
		if (s["start"])
			s["start"](scheduledTime || 0);
		else
			s["noteOn"](scheduledTime || 0);
	};
	function startSourceAt(s, x, d, scheduledTime)
	{
		if (s["start"])
			s["start"](scheduledTime || 0, x);
		else
			s["noteGrainOn"](scheduledTime || 0, x, d - x);
	};
	function stopSource(s)
	{
		try {
			if (s["stop"])
				s["stop"](0);
			else
				s["noteOff"](0);
		}
		catch (e) {}
	};
	function setAudioParam(ap, value, ramp, time)
	{
		if (!ap)
			return;		// iOS is missing some parameters
		ap["cancelScheduledValues"](0);
		if (time === 0)
		{
			ap["value"] = value;
			return;
		}
		var curTime = context["currentTime"];
		time += curTime;
		switch (ramp) {
		case 0:		// step
			ap["setValueAtTime"](value, time);
			break;
		case 1:		// linear
			ap["setValueAtTime"](ap["value"], curTime);		// to set what to ramp from
			ap["linearRampToValueAtTime"](value, time);
			break;
		case 2:		// exponential
			ap["setValueAtTime"](ap["value"], curTime);		// to set what to ramp from
			ap["exponentialRampToValueAtTime"](value, time);
			break;
		}
	};
	var filterTypes = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];
	function FilterEffect(type, freq, detune, q, gain, mix)
	{
		this.type = "filter";
		this.params = [type, freq, detune, q, gain, mix];
		this.inputNode = createGain();
		this.wetNode = createGain();
		this.wetNode["gain"]["value"] = mix;
		this.dryNode = createGain();
		this.dryNode["gain"]["value"] = 1 - mix;
		this.filterNode = context["createBiquadFilter"]();
		if (typeof this.filterNode["type"] === "number")
			this.filterNode["type"] = type;
		else
			this.filterNode["type"] = filterTypes[type];
		this.filterNode["frequency"]["value"] = freq;
		if (this.filterNode["detune"])		// iOS 6 doesn't have detune yet
			this.filterNode["detune"]["value"] = detune;
		this.filterNode["Q"]["value"] = q;
		this.filterNode["gain"]["value"] = gain;
		this.inputNode["connect"](this.filterNode);
		this.inputNode["connect"](this.dryNode);
		this.filterNode["connect"](this.wetNode);
	};
	FilterEffect.prototype.connectTo = function (node)
	{
		this.wetNode["disconnect"]();
		this.wetNode["connect"](node);
		this.dryNode["disconnect"]();
		this.dryNode["connect"](node);
	};
	FilterEffect.prototype.remove = function ()
	{
		this.inputNode["disconnect"]();
		this.filterNode["disconnect"]();
		this.wetNode["disconnect"]();
		this.dryNode["disconnect"]();
	};
	FilterEffect.prototype.getInputNode = function ()
	{
		return this.inputNode;
	};
	FilterEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[5] = value;
			setAudioParam(this.wetNode["gain"], value, ramp, time);
			setAudioParam(this.dryNode["gain"], 1 - value, ramp, time);
			break;
		case 1:		// filter frequency
			this.params[1] = value;
			setAudioParam(this.filterNode["frequency"], value, ramp, time);
			break;
		case 2:		// filter detune
			this.params[2] = value;
			setAudioParam(this.filterNode["detune"], value, ramp, time);
			break;
		case 3:		// filter Q
			this.params[3] = value;
			setAudioParam(this.filterNode["Q"], value, ramp, time);
			break;
		case 4:		// filter/delay gain (note value is in dB here)
			this.params[4] = value;
			setAudioParam(this.filterNode["gain"], value, ramp, time);
			break;
		}
	};
	function DelayEffect(delayTime, delayGain, mix)
	{
		this.type = "delay";
		this.params = [delayTime, delayGain, mix];
		this.inputNode = createGain();
		this.wetNode = createGain();
		this.wetNode["gain"]["value"] = mix;
		this.dryNode = createGain();
		this.dryNode["gain"]["value"] = 1 - mix;
		this.mainNode = createGain();
		this.delayNode = createDelay(delayTime);
		this.delayNode["delayTime"]["value"] = delayTime;
		this.delayGainNode = createGain();
		this.delayGainNode["gain"]["value"] = delayGain;
		this.inputNode["connect"](this.mainNode);
		this.inputNode["connect"](this.dryNode);
		this.mainNode["connect"](this.wetNode);
		this.mainNode["connect"](this.delayNode);
		this.delayNode["connect"](this.delayGainNode);
		this.delayGainNode["connect"](this.mainNode);
	};
	DelayEffect.prototype.connectTo = function (node)
	{
		this.wetNode["disconnect"]();
		this.wetNode["connect"](node);
		this.dryNode["disconnect"]();
		this.dryNode["connect"](node);
	};
	DelayEffect.prototype.remove = function ()
	{
		this.inputNode["disconnect"]();
		this.mainNode["disconnect"]();
		this.delayNode["disconnect"]();
		this.delayGainNode["disconnect"]();
		this.wetNode["disconnect"]();
		this.dryNode["disconnect"]();
	};
	DelayEffect.prototype.getInputNode = function ()
	{
		return this.inputNode;
	};
	DelayEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[2] = value;
			setAudioParam(this.wetNode["gain"], value, ramp, time);
			setAudioParam(this.dryNode["gain"], 1 - value, ramp, time);
			break;
		case 4:		// filter/delay gain (note value is passed in dB but needs to be linear here)
			this.params[1] = dbToLinear(value);
			setAudioParam(this.delayGainNode["gain"], dbToLinear(value), ramp, time);
			break;
		case 5:		// delay time
			this.params[0] = value;
			setAudioParam(this.delayNode["delayTime"], value, ramp, time);
			break;
		}
	};
	function ConvolveEffect(buffer, normalize, mix, src)
	{
		this.type = "convolve";
		this.params = [normalize, mix, src];
		this.inputNode = createGain();
		this.wetNode = createGain();
		this.wetNode["gain"]["value"] = mix;
		this.dryNode = createGain();
		this.dryNode["gain"]["value"] = 1 - mix;
		this.convolveNode = context["createConvolver"]();
		if (buffer)
		{
			this.convolveNode["normalize"] = normalize;
			this.convolveNode["buffer"] = buffer;
		}
		this.inputNode["connect"](this.convolveNode);
		this.inputNode["connect"](this.dryNode);
		this.convolveNode["connect"](this.wetNode);
	};
	ConvolveEffect.prototype.connectTo = function (node)
	{
		this.wetNode["disconnect"]();
		this.wetNode["connect"](node);
		this.dryNode["disconnect"]();
		this.dryNode["connect"](node);
	};
	ConvolveEffect.prototype.remove = function ()
	{
		this.inputNode["disconnect"]();
		this.convolveNode["disconnect"]();
		this.wetNode["disconnect"]();
		this.dryNode["disconnect"]();
	};
	ConvolveEffect.prototype.getInputNode = function ()
	{
		return this.inputNode;
	};
	ConvolveEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[1] = value;
			setAudioParam(this.wetNode["gain"], value, ramp, time);
			setAudioParam(this.dryNode["gain"], 1 - value, ramp, time);
			break;
		}
	};
	function FlangerEffect(delay, modulation, freq, feedback, mix)
	{
		this.type = "flanger";
		this.params = [delay, modulation, freq, feedback, mix];
		this.inputNode = createGain();
		this.dryNode = createGain();
		this.dryNode["gain"]["value"] = 1 - (mix / 2);
		this.wetNode = createGain();
		this.wetNode["gain"]["value"] = mix / 2;
		this.feedbackNode = createGain();
		this.feedbackNode["gain"]["value"] = feedback;
		this.delayNode = createDelay(delay + modulation);
		this.delayNode["delayTime"]["value"] = delay;
		this.oscNode = context["createOscillator"]();
		this.oscNode["frequency"]["value"] = freq;
		this.oscGainNode = createGain();
		this.oscGainNode["gain"]["value"] = modulation;
		this.inputNode["connect"](this.delayNode);
		this.inputNode["connect"](this.dryNode);
		this.delayNode["connect"](this.wetNode);
		this.delayNode["connect"](this.feedbackNode);
		this.feedbackNode["connect"](this.delayNode);
		this.oscNode["connect"](this.oscGainNode);
		this.oscGainNode["connect"](this.delayNode["delayTime"]);
		startSource(this.oscNode);
	};
	FlangerEffect.prototype.connectTo = function (node)
	{
		this.dryNode["disconnect"]();
		this.dryNode["connect"](node);
		this.wetNode["disconnect"]();
		this.wetNode["connect"](node);
	};
	FlangerEffect.prototype.remove = function ()
	{
		this.inputNode["disconnect"]();
		this.delayNode["disconnect"]();
		this.oscNode["disconnect"]();
		this.oscGainNode["disconnect"]();
		this.dryNode["disconnect"]();
		this.wetNode["disconnect"]();
		this.feedbackNode["disconnect"]();
	};
	FlangerEffect.prototype.getInputNode = function ()
	{
		return this.inputNode;
	};
	FlangerEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[4] = value;
			setAudioParam(this.wetNode["gain"], value / 2, ramp, time);
			setAudioParam(this.dryNode["gain"], 1 - (value / 2), ramp, time);
			break;
		case 6:		// modulation
			this.params[1] = value / 1000;
			setAudioParam(this.oscGainNode["gain"], value / 1000, ramp, time);
			break;
		case 7:		// modulation frequency
			this.params[2] = value;
			setAudioParam(this.oscNode["frequency"], value, ramp, time);
			break;
		case 8:		// feedback
			this.params[3] = value / 100;
			setAudioParam(this.feedbackNode["gain"], value / 100, ramp, time);
			break;
		}
	};
	function PhaserEffect(freq, detune, q, modulation, modfreq, mix)
	{
		this.type = "phaser";
		this.params = [freq, detune, q, modulation, modfreq, mix];
		this.inputNode = createGain();
		this.dryNode = createGain();
		this.dryNode["gain"]["value"] = 1 - (mix / 2);
		this.wetNode = createGain();
		this.wetNode["gain"]["value"] = mix / 2;
		this.filterNode = context["createBiquadFilter"]();
		if (typeof this.filterNode["type"] === "number")
			this.filterNode["type"] = 7;	// all-pass
		else
			this.filterNode["type"] = "allpass";
		this.filterNode["frequency"]["value"] = freq;
		if (this.filterNode["detune"])		// iOS 6 doesn't have detune yet
			this.filterNode["detune"]["value"] = detune;
		this.filterNode["Q"]["value"] = q;
		this.oscNode = context["createOscillator"]();
		this.oscNode["frequency"]["value"] = modfreq;
		this.oscGainNode = createGain();
		this.oscGainNode["gain"]["value"] = modulation;
		this.inputNode["connect"](this.filterNode);
		this.inputNode["connect"](this.dryNode);
		this.filterNode["connect"](this.wetNode);
		this.oscNode["connect"](this.oscGainNode);
		this.oscGainNode["connect"](this.filterNode["frequency"]);
		startSource(this.oscNode);
	};
	PhaserEffect.prototype.connectTo = function (node)
	{
		this.dryNode["disconnect"]();
		this.dryNode["connect"](node);
		this.wetNode["disconnect"]();
		this.wetNode["connect"](node);
	};
	PhaserEffect.prototype.remove = function ()
	{
		this.inputNode["disconnect"]();
		this.filterNode["disconnect"]();
		this.oscNode["disconnect"]();
		this.oscGainNode["disconnect"]();
		this.dryNode["disconnect"]();
		this.wetNode["disconnect"]();
	};
	PhaserEffect.prototype.getInputNode = function ()
	{
		return this.inputNode;
	};
	PhaserEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[5] = value;
			setAudioParam(this.wetNode["gain"], value / 2, ramp, time);
			setAudioParam(this.dryNode["gain"], 1 - (value / 2), ramp, time);
			break;
		case 1:		// filter frequency
			this.params[0] = value;
			setAudioParam(this.filterNode["frequency"], value, ramp, time);
			break;
		case 2:		// filter detune
			this.params[1] = value;
			setAudioParam(this.filterNode["detune"], value, ramp, time);
			break;
		case 3:		// filter Q
			this.params[2] = value;
			setAudioParam(this.filterNode["Q"], value, ramp, time);
			break;
		case 6:		// modulation
			this.params[3] = value;
			setAudioParam(this.oscGainNode["gain"], value, ramp, time);
			break;
		case 7:		// modulation frequency
			this.params[4] = value;
			setAudioParam(this.oscNode["frequency"], value, ramp, time);
			break;
		}
	};
	function GainEffect(g)
	{
		this.type = "gain";
		this.params = [g];
		this.node = createGain();
		this.node["gain"]["value"] = g;
	};
	GainEffect.prototype.connectTo = function (node_)
	{
		this.node["disconnect"]();
		this.node["connect"](node_);
	};
	GainEffect.prototype.remove = function ()
	{
		this.node["disconnect"]();
	};
	GainEffect.prototype.getInputNode = function ()
	{
		return this.node;
	};
	GainEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 4:		// gain
			this.params[0] = dbToLinear(value);
			setAudioParam(this.node["gain"], dbToLinear(value), ramp, time);
			break;
		}
	};
	function TremoloEffect(freq, mix)
	{
		this.type = "tremolo";
		this.params = [freq, mix];
		this.node = createGain();
		this.node["gain"]["value"] = 1 - (mix / 2);
		this.oscNode = context["createOscillator"]();
		this.oscNode["frequency"]["value"] = freq;
		this.oscGainNode = createGain();
		this.oscGainNode["gain"]["value"] = mix / 2;
		this.oscNode["connect"](this.oscGainNode);
		this.oscGainNode["connect"](this.node["gain"]);
		startSource(this.oscNode);
	};
	TremoloEffect.prototype.connectTo = function (node_)
	{
		this.node["disconnect"]();
		this.node["connect"](node_);
	};
	TremoloEffect.prototype.remove = function ()
	{
		this.oscNode["disconnect"]();
		this.oscGainNode["disconnect"]();
		this.node["disconnect"]();
	};
	TremoloEffect.prototype.getInputNode = function ()
	{
		return this.node;
	};
	TremoloEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[1] = value;
			setAudioParam(this.node["gain"]["value"], 1 - (value / 2), ramp, time);
			setAudioParam(this.oscGainNode["gain"]["value"], value / 2, ramp, time);
			break;
		case 7:		// modulation frequency
			this.params[0] = value;
			setAudioParam(this.oscNode["frequency"], value, ramp, time);
			break;
		}
	};
	function RingModulatorEffect(freq, mix)
	{
		this.type = "ringmod";
		this.params = [freq, mix];
		this.inputNode = createGain();
		this.wetNode = createGain();
		this.wetNode["gain"]["value"] = mix;
		this.dryNode = createGain();
		this.dryNode["gain"]["value"] = 1 - mix;
		this.ringNode = createGain();
		this.ringNode["gain"]["value"] = 0;
		this.oscNode = context["createOscillator"]();
		this.oscNode["frequency"]["value"] = freq;
		this.oscNode["connect"](this.ringNode["gain"]);
		startSource(this.oscNode);
		this.inputNode["connect"](this.ringNode);
		this.inputNode["connect"](this.dryNode);
		this.ringNode["connect"](this.wetNode);
	};
	RingModulatorEffect.prototype.connectTo = function (node_)
	{
		this.wetNode["disconnect"]();
		this.wetNode["connect"](node_);
		this.dryNode["disconnect"]();
		this.dryNode["connect"](node_);
	};
	RingModulatorEffect.prototype.remove = function ()
	{
		this.oscNode["disconnect"]();
		this.ringNode["disconnect"]();
		this.inputNode["disconnect"]();
		this.wetNode["disconnect"]();
		this.dryNode["disconnect"]();
	};
	RingModulatorEffect.prototype.getInputNode = function ()
	{
		return this.inputNode;
	};
	RingModulatorEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[1] = value;
			setAudioParam(this.wetNode["gain"], value, ramp, time);
			setAudioParam(this.dryNode["gain"], 1 - value, ramp, time);
			break;
		case 7:		// modulation frequency
			this.params[0] = value;
			setAudioParam(this.oscNode["frequency"], value, ramp, time);
			break;
		}
	};
	function DistortionEffect(threshold, headroom, drive, makeupgain, mix)
	{
		this.type = "distortion";
		this.params = [threshold, headroom, drive, makeupgain, mix];
		this.inputNode = createGain();
		this.preGain = createGain();
		this.postGain = createGain();
		this.setDrive(drive, dbToLinear_nocap(makeupgain));
		this.wetNode = createGain();
		this.wetNode["gain"]["value"] = mix;
		this.dryNode = createGain();
		this.dryNode["gain"]["value"] = 1 - mix;
		this.waveShaper = context["createWaveShaper"]();
		this.curve = new Float32Array(65536);
		this.generateColortouchCurve(threshold, headroom);
		this.waveShaper.curve = this.curve;
		this.inputNode["connect"](this.preGain);
		this.inputNode["connect"](this.dryNode);
		this.preGain["connect"](this.waveShaper);
		this.waveShaper["connect"](this.postGain);
		this.postGain["connect"](this.wetNode);
	};
	DistortionEffect.prototype.setDrive = function (drive, makeupgain)
	{
		if (drive < 0.01)
			drive = 0.01;
		this.preGain["gain"]["value"] = drive;
		this.postGain["gain"]["value"] = Math.pow(1 / drive, 0.6) * makeupgain;
	};
	function e4(x, k)
	{
		return 1.0 - Math.exp(-k * x);
	}
	DistortionEffect.prototype.shape = function (x, linearThreshold, linearHeadroom)
	{
		var maximum = 1.05 * linearHeadroom * linearThreshold;
		var kk = (maximum - linearThreshold);
		var sign = x < 0 ? -1 : +1;
		var absx = x < 0 ? -x : x;
		var shapedInput = absx < linearThreshold ? absx : linearThreshold + kk * e4(absx - linearThreshold, 1.0 / kk);
		shapedInput *= sign;
		return shapedInput;
	};
	DistortionEffect.prototype.generateColortouchCurve = function (threshold, headroom)
	{
		var linearThreshold = dbToLinear_nocap(threshold);
		var linearHeadroom = dbToLinear_nocap(headroom);
		var n = 65536;
		var n2 = n / 2;
		var x = 0;
		for (var i = 0; i < n2; ++i) {
			x = i / n2;
			x = this.shape(x, linearThreshold, linearHeadroom);
			this.curve[n2 + i] = x;
			this.curve[n2 - i - 1] = -x;
		}
	};
	DistortionEffect.prototype.connectTo = function (node)
	{
		this.wetNode["disconnect"]();
		this.wetNode["connect"](node);
		this.dryNode["disconnect"]();
		this.dryNode["connect"](node);
	};
	DistortionEffect.prototype.remove = function ()
	{
		this.inputNode["disconnect"]();
		this.preGain["disconnect"]();
		this.waveShaper["disconnect"]();
		this.postGain["disconnect"]();
		this.wetNode["disconnect"]();
		this.dryNode["disconnect"]();
	};
	DistortionEffect.prototype.getInputNode = function ()
	{
		return this.inputNode;
	};
	DistortionEffect.prototype.setParam = function(param, value, ramp, time)
	{
		switch (param) {
		case 0:		// mix
			value = value / 100;
			if (value < 0) value = 0;
			if (value > 1) value = 1;
			this.params[4] = value;
			setAudioParam(this.wetNode["gain"], value, ramp, time);
			setAudioParam(this.dryNode["gain"], 1 - value, ramp, time);
			break;
		}
	};
	function CompressorEffect(threshold, knee, ratio, attack, release)
	{
		this.type = "compressor";
		this.params = [threshold, knee, ratio, attack, release];
		this.node = context["createDynamicsCompressor"]();
		try {
			this.node["threshold"]["value"] = threshold;
			this.node["knee"]["value"] = knee;
			this.node["ratio"]["value"] = ratio;
			this.node["attack"]["value"] = attack;
			this.node["release"]["value"] = release;
		}
		catch (e) {}
	};
	CompressorEffect.prototype.connectTo = function (node_)
	{
		this.node["disconnect"]();
		this.node["connect"](node_);
	};
	CompressorEffect.prototype.remove = function ()
	{
		this.node["disconnect"]();
	};
	CompressorEffect.prototype.getInputNode = function ()
	{
		return this.node;
	};
	CompressorEffect.prototype.setParam = function(param, value, ramp, time)
	{
	};
	function AnalyserEffect(fftSize, smoothing)
	{
		this.type = "analyser";
		this.params = [fftSize, smoothing];
		this.node = context["createAnalyser"]();
		this.node["fftSize"] = fftSize;
		this.node["smoothingTimeConstant"] = smoothing;
		this.freqBins = new Float32Array(this.node["frequencyBinCount"]);
		this.signal = new Uint8Array(fftSize);
		this.peak = 0;
		this.rms = 0;
	};
	AnalyserEffect.prototype.tick = function ()
	{
		this.node["getFloatFrequencyData"](this.freqBins);
		this.node["getByteTimeDomainData"](this.signal);
		var fftSize = this.node["fftSize"];
		var i = 0;
		this.peak = 0;
		var rmsSquaredSum = 0;
		var s = 0;
		for ( ; i < fftSize; i++)
		{
			s = (this.signal[i] - 128) / 128;
			if (s < 0)
				s = -s;
			if (this.peak < s)
				this.peak = s;
			rmsSquaredSum += s * s;
		}
		this.peak = linearToDb(this.peak);
		this.rms = linearToDb(Math.sqrt(rmsSquaredSum / fftSize));
	};
	AnalyserEffect.prototype.connectTo = function (node_)
	{
		this.node["disconnect"]();
		this.node["connect"](node_);
	};
	AnalyserEffect.prototype.remove = function ()
	{
		this.node["disconnect"]();
	};
	AnalyserEffect.prototype.getInputNode = function ()
	{
		return this.node;
	};
	AnalyserEffect.prototype.setParam = function(param, value, ramp, time)
	{
	};
	function ObjectTracker()
	{
		this.obj = null;
		this.loadUid = 0;
	};
	ObjectTracker.prototype.setObject = function (obj_)
	{
		this.obj = obj_;
	};
	ObjectTracker.prototype.hasObject = function ()
	{
		return !!this.obj;
	};
	ObjectTracker.prototype.tick = function (dt)
	{
	};
	var iOShadtouchstart = false;	// has had touch start input on iOS <=8 to work around web audio API muting
	var iOShadtouchend = false;		// has had touch end input on iOS 9+ to work around web audio API muting
	function C2AudioBuffer(src_, is_music)
	{
		this.src = src_;
		this.myapi = api;
		this.is_music = is_music;
		this.added_end_listener = false;
		var self = this;
		this.outNode = null;
		this.mediaSourceNode = null;
		this.panWhenReady = [];		// for web audio API positioned sounds
		this.seekWhenReady = 0;
		this.pauseWhenReady = false;
		this.supportWebAudioAPI = false;
		this.failedToLoad = false;
		this.wasEverReady = false;	// if a buffer is ever marked as ready, it's permanently considered ready after then.
		if (api === API_WEBAUDIO && is_music && !playMusicAsSoundWorkaround)
		{
			this.myapi = API_HTML5;
			this.outNode = createGain();
		}
		this.bufferObject = null;			// actual audio object
		this.audioData = null;				// web audio api: ajax request result (compressed audio that needs decoding)
		var request;
		switch (this.myapi) {
		case API_HTML5:
			this.bufferObject = new Audio();
			this.bufferObject.crossOrigin = "anonymous";
			this.bufferObject.addEventListener("canplaythrough", function () {
				self.wasEverReady = true;	// update loaded state so preload is considered complete
			});
			if (api === API_WEBAUDIO && context["createMediaElementSource"] && !/wiiu/i.test(navigator.userAgent))
			{
				this.supportWebAudioAPI = true;		// can be routed through web audio api
				this.bufferObject.addEventListener("canplay", function ()
				{
					if (!self.mediaSourceNode)		// protect against this event firing twice
					{
						self.mediaSourceNode = context["createMediaElementSource"](self.bufferObject);
						self.mediaSourceNode["connect"](self.outNode);
					}
				});
			}
			this.bufferObject.autoplay = false;	// this is only a source buffer, not an instance
			this.bufferObject.preload = "auto";
			this.bufferObject.src = src_;
			break;
		case API_WEBAUDIO:
			if (audRuntime.isWKWebView)
			{
				audRuntime.fetchLocalFileViaCordovaAsArrayBuffer(src_, function (arrayBuffer)
				{
					self.audioData = arrayBuffer;
					self.decodeAudioBuffer();
				}, function (err)
				{
					self.failedToLoad = true;
				});
			}
			else
			{
				request = new XMLHttpRequest();
				request.open("GET", src_, true);
				request.responseType = "arraybuffer";
				request.onload = function () {
					self.audioData = request.response;
					self.decodeAudioBuffer();
				};
				request.onerror = function () {
					self.failedToLoad = true;
				};
				request.send();
			}
			break;
		case API_CORDOVA:
			this.bufferObject = true;
			break;
		case API_APPMOBI:
			this.bufferObject = true;
			break;
		}
	};
	C2AudioBuffer.prototype.release = function ()
	{
		var i, len, j, a;
		for (i = 0, j = 0, len = audioInstances.length; i < len; ++i)
		{
			a = audioInstances[i];
			audioInstances[j] = a;
			if (a.buffer === this)
				a.stop();
			else
				++j;		// keep
		}
		audioInstances.length = j;
		this.bufferObject = null;
		this.audioData = null;
	};
	C2AudioBuffer.prototype.decodeAudioBuffer = function ()
	{
		if (this.bufferObject || !this.audioData)
			return;		// audio already decoded or AJAX request not yet complete
		var self = this;
		if (context["decodeAudioData"])
		{
			context["decodeAudioData"](this.audioData, function (buffer) {
					self.bufferObject = buffer;
					self.audioData = null;		// clear AJAX response to allow GC and save memory, only need the bufferObject now
					var p, i, len, a;
					if (!cr.is_undefined(self.playTagWhenReady) && !silent)
					{
						if (self.panWhenReady.length)
						{
							for (i = 0, len = self.panWhenReady.length; i < len; i++)
							{
								p = self.panWhenReady[i];
								a = new C2AudioInstance(self, p.thistag);
								a.setPannerEnabled(true);
								if (typeof p.objUid !== "undefined")
								{
									p.obj = audRuntime.getObjectByUID(p.objUid);
									if (!p.obj)
										continue;
								}
								if (p.obj)
								{
									var px = cr.rotatePtAround(p.obj.x, p.obj.y, -p.obj.layer.getAngle(), listenerX, listenerY, true);
									var py = cr.rotatePtAround(p.obj.x, p.obj.y, -p.obj.layer.getAngle(), listenerX, listenerY, false);
									a.setPan(px, py, cr.to_degrees(p.obj.angle - p.obj.layer.getAngle()), p.ia, p.oa, p.og);
									a.setObject(p.obj);
								}
								else
								{
									a.setPan(p.x, p.y, p.a, p.ia, p.oa, p.og);
								}
								a.play(self.loopWhenReady, self.volumeWhenReady, self.seekWhenReady);
								if (self.pauseWhenReady)
									a.pause();
								audioInstances.push(a);
							}
							cr.clearArray(self.panWhenReady);
						}
						else
						{
							a = new C2AudioInstance(self, self.playTagWhenReady || "");		// sometimes playTagWhenReady is not set - TODO: why?
							a.play(self.loopWhenReady, self.volumeWhenReady, self.seekWhenReady);
							if (self.pauseWhenReady)
								a.pause();
							audioInstances.push(a);
						}
					}
					else if (!cr.is_undefined(self.convolveWhenReady))
					{
						var convolveNode = self.convolveWhenReady.convolveNode;
						convolveNode["normalize"] = self.normalizeWhenReady;
						convolveNode["buffer"] = buffer;
					}
			}, function (e) {
				self.failedToLoad = true;
			});
		}
		else
		{
			this.bufferObject = context["createBuffer"](this.audioData, false);
			this.audioData = null;		// clear AJAX response to allow GC and save memory, only need the bufferObject now
			if (!cr.is_undefined(this.playTagWhenReady) && !silent)
			{
				var a = new C2AudioInstance(this, this.playTagWhenReady);
				a.play(this.loopWhenReady, this.volumeWhenReady, this.seekWhenReady);
				if (this.pauseWhenReady)
					a.pause();
				audioInstances.push(a);
			}
			else if (!cr.is_undefined(this.convolveWhenReady))
			{
				var convolveNode = this.convolveWhenReady.convolveNode;
				convolveNode["normalize"] = this.normalizeWhenReady;
				convolveNode["buffer"] = this.bufferObject;
			}
		}
	};
	C2AudioBuffer.prototype.isLoaded = function ()
	{
		switch (this.myapi) {
		case API_HTML5:
			var ret = this.bufferObject["readyState"] >= 4;	// HAVE_ENOUGH_DATA
			if (ret)
				this.wasEverReady = true;
			return ret || this.wasEverReady;
		case API_WEBAUDIO:
			return !!this.audioData || !!this.bufferObject;
		case API_CORDOVA:
			return true;
		case API_APPMOBI:
			return true;
		}
		return false;
	};
	C2AudioBuffer.prototype.isLoadedAndDecoded = function ()
	{
		switch (this.myapi) {
		case API_HTML5:
			return this.isLoaded();		// no distinction between loaded and decoded in HTML5 audio, just rely on ready state
		case API_WEBAUDIO:
			return !!this.bufferObject;
		case API_CORDOVA:
			return true;
		case API_APPMOBI:
			return true;
		}
		return false;
	};
	C2AudioBuffer.prototype.hasFailedToLoad = function ()
	{
		switch (this.myapi) {
		case API_HTML5:
			return !!this.bufferObject["error"];
		case API_WEBAUDIO:
			return this.failedToLoad;
		}
		return false;
	};
	function C2AudioInstance(buffer_, tag_)
	{
		var self = this;
		this.tag = tag_;
		this.fresh = true;
		this.stopped = true;
		this.src = buffer_.src;
		this.buffer = buffer_;
		this.myapi = api;
		this.is_music = buffer_.is_music;
		this.playbackRate = 1;
		this.hasPlaybackEnded = true;	// ended flag
		this.resume_me = false;			// make sure resumes when leaving suspend
		this.is_paused = false;
		this.resume_position = 0;		// for web audio api to resume from correct playback position
		this.looping = false;
		this.is_muted = false;
		this.is_silent = false;
		this.volume = 1;
		this.onended_handler = function (e)
		{
			if (self.is_paused || self.resume_me)
				return;
			var bufferThatEnded = this;
			if (!bufferThatEnded)
				bufferThatEnded = e.target;
			if (bufferThatEnded !== self.active_buffer)
				return;
			self.hasPlaybackEnded = true;
			self.stopped = true;
			audTag = self.tag;
			audRuntime.trigger(cr.plugins_.Audio.prototype.cnds.OnEnded, audInst);
		};
		this.active_buffer = null;
		this.isTimescaled = ((timescale_mode === 1 && !this.is_music) || timescale_mode === 2);
		this.mutevol = 1;
		this.startTime = (this.isTimescaled ? audRuntime.kahanTime.sum : audRuntime.wallTime.sum);
		this.gainNode = null;
		this.pannerNode = null;
		this.pannerEnabled = false;
		this.objectTracker = null;
		this.panX = 0;
		this.panY = 0;
		this.panAngle = 0;
		this.panConeInner = 0;
		this.panConeOuter = 0;
		this.panConeOuterGain = 0;
		this.instanceObject = null;
		var add_end_listener = false;
		if (this.myapi === API_WEBAUDIO && this.buffer.myapi === API_HTML5 && !this.buffer.supportWebAudioAPI)
			this.myapi = API_HTML5;
		switch (this.myapi) {
		case API_HTML5:
			if (this.is_music)
			{
				this.instanceObject = buffer_.bufferObject;
				add_end_listener = !buffer_.added_end_listener;
				buffer_.added_end_listener = true;
			}
			else
			{
				this.instanceObject = new Audio();
				this.instanceObject.crossOrigin = "anonymous";
				this.instanceObject.autoplay = false;
				this.instanceObject.src = buffer_.bufferObject.src;
				add_end_listener = true;
			}
			if (add_end_listener)
			{
				this.instanceObject.addEventListener('ended', function () {
						audTag = self.tag;
						self.stopped = true;
						audRuntime.trigger(cr.plugins_.Audio.prototype.cnds.OnEnded, audInst);
				});
			}
			break;
		case API_WEBAUDIO:
			this.gainNode = createGain();
			this.gainNode["connect"](getDestinationForTag(tag_));
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				if (buffer_.bufferObject)
				{
					this.instanceObject = context["createBufferSource"]();
					this.instanceObject["buffer"] = buffer_.bufferObject;
					this.instanceObject["connect"](this.gainNode);
				}
			}
			else
			{
				this.instanceObject = this.buffer.bufferObject;		// reference the audio element
				this.buffer.outNode["connect"](this.gainNode);
				if (!this.buffer.added_end_listener)
				{
					this.buffer.added_end_listener = true;
					this.buffer.bufferObject.addEventListener('ended', function () {
							audTag = self.tag;
							self.stopped = true;
							audRuntime.trigger(cr.plugins_.Audio.prototype.cnds.OnEnded, audInst);
					});
				}
			}
			break;
		case API_CORDOVA:
			this.instanceObject = new window["Media"](appPath + this.src, null, null, function (status) {
					if (status === window["Media"]["MEDIA_STOPPED"])
					{
						self.hasPlaybackEnded = true;
						self.stopped = true;
						audTag = self.tag;
						audRuntime.trigger(cr.plugins_.Audio.prototype.cnds.OnEnded, audInst);
					}
			});
			break;
		case API_APPMOBI:
			this.instanceObject = true;
			break;
		}
	};
	C2AudioInstance.prototype.hasEnded = function ()
	{
		var time;
		switch (this.myapi) {
		case API_HTML5:
			return this.instanceObject.ended;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				if (!this.fresh && !this.stopped && this.instanceObject["loop"])
					return false;
				if (this.is_paused)
					return false;
				return this.hasPlaybackEnded;
			}
			else
				return this.instanceObject.ended;
		case API_CORDOVA:
			return this.hasPlaybackEnded;
		case API_APPMOBI:
			true;	// recycling an AppMobi sound does not matter because it will just do another throwaway playSound
		}
		return true;
	};
	C2AudioInstance.prototype.canBeRecycled = function ()
	{
		if (this.fresh || this.stopped)
			return true;		// not yet used or is not playing
		return this.hasEnded();
	};
	C2AudioInstance.prototype.setPannerEnabled = function (enable_)
	{
		if (api !== API_WEBAUDIO)
			return;
		if (!this.pannerEnabled && enable_)
		{
			if (!this.gainNode)
				return;
			if (!this.pannerNode)
			{
				this.pannerNode = context["createPanner"]();
				if (typeof this.pannerNode["panningModel"] === "number")
					this.pannerNode["panningModel"] = panningModel;
				else
					this.pannerNode["panningModel"] = ["equalpower", "HRTF", "soundfield"][panningModel];
				if (typeof this.pannerNode["distanceModel"] === "number")
					this.pannerNode["distanceModel"] = distanceModel;
				else
					this.pannerNode["distanceModel"] = ["linear", "inverse", "exponential"][distanceModel];
				this.pannerNode["refDistance"] = refDistance;
				this.pannerNode["maxDistance"] = maxDistance;
				this.pannerNode["rolloffFactor"] = rolloffFactor;
			}
			this.gainNode["disconnect"]();
			this.gainNode["connect"](this.pannerNode);
			this.pannerNode["connect"](getDestinationForTag(this.tag));
			this.pannerEnabled = true;
		}
		else if (this.pannerEnabled && !enable_)
		{
			if (!this.gainNode)
				return;
			this.pannerNode["disconnect"]();
			this.gainNode["disconnect"]();
			this.gainNode["connect"](getDestinationForTag(this.tag));
			this.pannerEnabled = false;
		}
	};
	C2AudioInstance.prototype.setPan = function (x, y, angle, innerangle, outerangle, outergain)
	{
		if (!this.pannerEnabled || api !== API_WEBAUDIO)
			return;
		this.pannerNode["setPosition"](x, y, 0);
		this.pannerNode["setOrientation"](Math.cos(cr.to_radians(angle)), Math.sin(cr.to_radians(angle)), 0);
		this.pannerNode["coneInnerAngle"] = innerangle;
		this.pannerNode["coneOuterAngle"] = outerangle;
		this.pannerNode["coneOuterGain"] = outergain;
		this.panX = x;
		this.panY = y;
		this.panAngle = angle;
		this.panConeInner = innerangle;
		this.panConeOuter = outerangle;
		this.panConeOuterGain = outergain;
	};
	C2AudioInstance.prototype.setObject = function (o)
	{
		if (!this.pannerEnabled || api !== API_WEBAUDIO)
			return;
		if (!this.objectTracker)
			this.objectTracker = new ObjectTracker();
		this.objectTracker.setObject(o);
	};
	C2AudioInstance.prototype.tick = function (dt)
	{
		if (!this.pannerEnabled || api !== API_WEBAUDIO || !this.objectTracker || !this.objectTracker.hasObject() || !this.isPlaying())
		{
			return;
		}
		this.objectTracker.tick(dt);
		var inst = this.objectTracker.obj;
		var px = cr.rotatePtAround(inst.x, inst.y, -inst.layer.getAngle(), listenerX, listenerY, true);
		var py = cr.rotatePtAround(inst.x, inst.y, -inst.layer.getAngle(), listenerX, listenerY, false);
		this.pannerNode["setPosition"](px, py, 0);
		var a = 0;
		if (typeof this.objectTracker.obj.angle !== "undefined")
		{
			a = inst.angle - inst.layer.getAngle();
			this.pannerNode["setOrientation"](Math.cos(a), Math.sin(a), 0);
		}
	};
	C2AudioInstance.prototype.play = function (looping, vol, fromPosition, scheduledTime)
	{
		var instobj = this.instanceObject;
		this.looping = looping;
		this.volume = vol;
		var seekPos = fromPosition || 0;
		scheduledTime = scheduledTime || 0;
		switch (this.myapi) {
		case API_HTML5:
			if (instobj.playbackRate !== 1.0)
				instobj.playbackRate = 1.0;
			if (instobj.volume !== vol * masterVolume)
				instobj.volume = vol * masterVolume;
			if (instobj.loop !== looping)
				instobj.loop = looping;
			if (instobj.muted)
				instobj.muted = false;
			if (instobj.currentTime !== seekPos)
			{
				try {
					instobj.currentTime = seekPos;
				}
				catch (err)
				{
;
				}
			}
			if (this.is_music && isMusicWorkaround && !audRuntime.isInUserInputEvent)
				musicPlayNextTouch.push(this);
			else
			{
				try {
					this.instanceObject.play();
				}
				catch (e) {		// sometimes throws on WP8.1... try not to kill the app
					if (console && console.log)
						console.log("[C2] WARNING: exception trying to play audio '" + this.buffer.src + "': ", e);
				}
			}
			break;
		case API_WEBAUDIO:
			this.muted = false;
			this.mutevol = 1;
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				this.gainNode["gain"]["value"] = vol * masterVolume;
				if (!this.fresh)
				{
					this.instanceObject = context["createBufferSource"]();
					this.instanceObject["buffer"] = this.buffer.bufferObject;
					this.instanceObject["connect"](this.gainNode);
				}
				this.instanceObject["onended"] = this.onended_handler;
				this.active_buffer = this.instanceObject;
				this.instanceObject.loop = looping;
				this.hasPlaybackEnded = false;
				if (seekPos === 0)
					startSource(this.instanceObject, scheduledTime);
				else
					startSourceAt(this.instanceObject, seekPos, this.getDuration(), scheduledTime);
			}
			else
			{
				if (instobj.playbackRate !== 1.0)
					instobj.playbackRate = 1.0;
				if (instobj.loop !== looping)
					instobj.loop = looping;
				instobj.volume = vol * masterVolume;
				if (instobj.currentTime !== seekPos)
				{
					try {
						instobj.currentTime = seekPos;
					}
					catch (err)
					{
;
					}
				}
				if (this.is_music && isMusicWorkaround && !audRuntime.isInUserInputEvent)
					musicPlayNextTouch.push(this);
				else
					instobj.play();
			}
			break;
		case API_CORDOVA:
			if ((!this.fresh && this.stopped) || seekPos !== 0)
				instobj["seekTo"](seekPos);
			instobj["play"]();
			this.hasPlaybackEnded = false;
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				AppMobi["context"]["playSound"](this.src, looping);
			else
				AppMobi["player"]["playSound"](this.src, looping);
			break;
		}
		this.playbackRate = 1;
		this.startTime = (this.isTimescaled ? audRuntime.kahanTime.sum : audRuntime.wallTime.sum) - seekPos;
		this.fresh = false;
		this.stopped = false;
		this.is_paused = false;
	};
	C2AudioInstance.prototype.stop = function ()
	{
		switch (this.myapi) {
		case API_HTML5:
			if (!this.instanceObject.paused)
				this.instanceObject.pause();
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
				stopSource(this.instanceObject);
			else
			{
				if (!this.instanceObject.paused)
					this.instanceObject.pause();
			}
			break;
		case API_CORDOVA:
			this.instanceObject["stop"]();
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				AppMobi["context"]["stopSound"](this.src);
			break;
		}
		this.stopped = true;
		this.is_paused = false;
	};
	C2AudioInstance.prototype.pause = function ()
	{
		if (this.fresh || this.stopped || this.hasEnded() || this.is_paused)
			return;
		switch (this.myapi) {
		case API_HTML5:
			if (!this.instanceObject.paused)
				this.instanceObject.pause();
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				this.resume_position = this.getPlaybackTime(true);
				if (this.looping)
					this.resume_position = this.resume_position % this.getDuration();
				this.is_paused = true;
				stopSource(this.instanceObject);
			}
			else
			{
				if (!this.instanceObject.paused)
					this.instanceObject.pause();
			}
			break;
		case API_CORDOVA:
			this.instanceObject["pause"]();
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				AppMobi["context"]["stopSound"](this.src);
			break;
		}
		this.is_paused = true;
	};
	C2AudioInstance.prototype.resume = function ()
	{
		if (this.fresh || this.stopped || this.hasEnded() || !this.is_paused)
			return;
		switch (this.myapi) {
		case API_HTML5:
			this.instanceObject.play();
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				this.instanceObject = context["createBufferSource"]();
				this.instanceObject["buffer"] = this.buffer.bufferObject;
				this.instanceObject["connect"](this.gainNode);
				this.instanceObject["onended"] = this.onended_handler;
				this.active_buffer = this.instanceObject;
				this.instanceObject.loop = this.looping;
				this.gainNode["gain"]["value"] = masterVolume * this.volume * this.mutevol;
				this.updatePlaybackRate();
				this.startTime = (this.isTimescaled ? audRuntime.kahanTime.sum : audRuntime.wallTime.sum) - (this.resume_position / (this.playbackRate || 0.001));
				startSourceAt(this.instanceObject, this.resume_position, this.getDuration());
			}
			else
			{
				this.instanceObject.play();
			}
			break;
		case API_CORDOVA:
			this.instanceObject["play"]();
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				AppMobi["context"]["resumeSound"](this.src);
			break;
		}
		this.is_paused = false;
	};
	C2AudioInstance.prototype.seek = function (pos)
	{
		if (this.fresh || this.stopped || this.hasEnded())
			return;
		switch (this.myapi) {
		case API_HTML5:
			try {
				this.instanceObject.currentTime = pos;
			}
			catch (e) {}
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				if (this.is_paused)
					this.resume_position = pos;
				else
				{
					this.pause();
					this.resume_position = pos;
					this.resume();
				}
			}
			else
			{
				try {
					this.instanceObject.currentTime = pos;
				}
				catch (e) {}
			}
			break;
		case API_CORDOVA:
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				AppMobi["context"]["seekSound"](this.src, pos);
			break;
		}
	};
	C2AudioInstance.prototype.reconnect = function (toNode)
	{
		if (this.myapi !== API_WEBAUDIO)
			return;
		if (this.pannerEnabled)
		{
			this.pannerNode["disconnect"]();
			this.pannerNode["connect"](toNode);
		}
		else
		{
			this.gainNode["disconnect"]();
			this.gainNode["connect"](toNode);
		}
	};
	C2AudioInstance.prototype.getDuration = function (applyPlaybackRate)
	{
		var ret = 0;
		switch (this.myapi) {
		case API_HTML5:
			if (typeof this.instanceObject.duration !== "undefined")
				ret = this.instanceObject.duration;
			break;
		case API_WEBAUDIO:
			ret = this.buffer.bufferObject["duration"];
			break;
		case API_CORDOVA:
			ret = this.instanceObject["getDuration"]();
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				ret = AppMobi["context"]["getDurationSound"](this.src);
			break;
		}
		if (applyPlaybackRate)
			ret /= (this.playbackRate || 0.001);		// avoid divide-by-zero
		return ret;
	};
	C2AudioInstance.prototype.getPlaybackTime = function (applyPlaybackRate)
	{
		var duration = this.getDuration();
		var ret = 0;
		switch (this.myapi) {
		case API_HTML5:
			if (typeof this.instanceObject.currentTime !== "undefined")
				ret = this.instanceObject.currentTime;
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				if (this.is_paused)
					return this.resume_position;
				else
					ret = (this.isTimescaled ? audRuntime.kahanTime.sum : audRuntime.wallTime.sum) - this.startTime;
			}
			else if (typeof this.instanceObject.currentTime !== "undefined")
				ret = this.instanceObject.currentTime;
			break;
		case API_CORDOVA:
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				ret = AppMobi["context"]["getPlaybackTimeSound"](this.src);
			break;
		}
		if (applyPlaybackRate)
			ret *= this.playbackRate;
		if (!this.looping && ret > duration)
			ret = duration;
		return ret;
	};
	C2AudioInstance.prototype.isPlaying = function ()
	{
		return !this.is_paused && !this.fresh && !this.stopped && !this.hasEnded();
	};
	C2AudioInstance.prototype.shouldSave = function ()
	{
		return !this.fresh && !this.stopped && !this.hasEnded();
	};
	C2AudioInstance.prototype.setVolume = function (v)
	{
		this.volume = v;
		this.updateVolume();
	};
	C2AudioInstance.prototype.updateVolume = function ()
	{
		var volToSet = this.volume * masterVolume;
		if (!isFinite(volToSet))
			volToSet = 0;		// HTMLMediaElement throws if setting non-finite volume
		switch (this.myapi) {
		case API_HTML5:
			if (typeof this.instanceObject.volume !== "undefined" && this.instanceObject.volume !== volToSet)
				this.instanceObject.volume = volToSet;
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				this.gainNode["gain"]["value"] = volToSet * this.mutevol;
			}
			else
			{
				if (typeof this.instanceObject.volume !== "undefined" && this.instanceObject.volume !== volToSet)
					this.instanceObject.volume = volToSet;
			}
			break;
		case API_CORDOVA:
			break;
		case API_APPMOBI:
			break;
		}
	};
	C2AudioInstance.prototype.getVolume = function ()
	{
		return this.volume;
	};
	C2AudioInstance.prototype.doSetMuted = function (m)
	{
		switch (this.myapi) {
		case API_HTML5:
			if (this.instanceObject.muted !== !!m)
				this.instanceObject.muted = !!m;
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				this.mutevol = (m ? 0 : 1);
				this.gainNode["gain"]["value"] = masterVolume * this.volume * this.mutevol;
			}
			else
			{
				if (this.instanceObject.muted !== !!m)
					this.instanceObject.muted = !!m;
			}
			break;
		case API_CORDOVA:
			break;
		case API_APPMOBI:
			break;
		}
	};
	C2AudioInstance.prototype.setMuted = function (m)
	{
		this.is_muted = !!m;
		this.doSetMuted(this.is_muted || this.is_silent);
	};
	C2AudioInstance.prototype.setSilent = function (m)
	{
		this.is_silent = !!m;
		this.doSetMuted(this.is_muted || this.is_silent);
	};
	C2AudioInstance.prototype.setLooping = function (l)
	{
		this.looping = l;
		switch (this.myapi) {
		case API_HTML5:
			if (this.instanceObject.loop !== !!l)
				this.instanceObject.loop = !!l;
			break;
		case API_WEBAUDIO:
			if (this.instanceObject.loop !== !!l)
				this.instanceObject.loop = !!l;
			break;
		case API_CORDOVA:
			break;
		case API_APPMOBI:
			if (audRuntime.isDirectCanvas)
				AppMobi["context"]["setLoopingSound"](this.src, l);
			break;
		}
	};
	C2AudioInstance.prototype.setPlaybackRate = function (r)
	{
		this.playbackRate = r;
		this.updatePlaybackRate();
	};
	C2AudioInstance.prototype.updatePlaybackRate = function ()
	{
		var r = this.playbackRate;
		if (this.isTimescaled)
			r *= audRuntime.timescale;
		switch (this.myapi) {
		case API_HTML5:
			if (this.instanceObject.playbackRate !== r)
				this.instanceObject.playbackRate = r;
			break;
		case API_WEBAUDIO:
			if (this.buffer.myapi === API_WEBAUDIO)
			{
				if (this.instanceObject["playbackRate"]["value"] !== r)
					this.instanceObject["playbackRate"]["value"] = r;
			}
			else
			{
				if (this.instanceObject.playbackRate !== r)
					this.instanceObject.playbackRate = r;
			}
			break;
		case API_CORDOVA:
			break;
		case API_APPMOBI:
			break;
		}
	};
	C2AudioInstance.prototype.setSuspended = function (s)
	{
		switch (this.myapi) {
		case API_HTML5:
			if (s)
			{
				if (this.isPlaying())
				{
					this.resume_me = true;
					this.instanceObject["pause"]();
				}
				else
					this.resume_me = false;
			}
			else
			{
				if (this.resume_me)
				{
					this.instanceObject["play"]();
					this.resume_me = false;
				}
			}
			break;
		case API_WEBAUDIO:
			if (s)
			{
				if (this.isPlaying())
				{
					this.resume_me = true;
					if (this.buffer.myapi === API_WEBAUDIO)
					{
						this.resume_position = this.getPlaybackTime(true);
						if (this.looping)
							this.resume_position = this.resume_position % this.getDuration();
						stopSource(this.instanceObject);
					}
					else
						this.instanceObject["pause"]();
				}
				else
					this.resume_me = false;
			}
			else
			{
				if (this.resume_me)
				{
					if (this.buffer.myapi === API_WEBAUDIO)
					{
						this.instanceObject = context["createBufferSource"]();
						this.instanceObject["buffer"] = this.buffer.bufferObject;
						this.instanceObject["connect"](this.gainNode);
						this.instanceObject["onended"] = this.onended_handler;
						this.active_buffer = this.instanceObject;
						this.instanceObject.loop = this.looping;
						this.gainNode["gain"]["value"] = masterVolume * this.volume * this.mutevol;
						this.updatePlaybackRate();
						this.startTime = (this.isTimescaled ? audRuntime.kahanTime.sum : audRuntime.wallTime.sum) - (this.resume_position / (this.playbackRate || 0.001));
						startSourceAt(this.instanceObject, this.resume_position, this.getDuration());
					}
					else
					{
						this.instanceObject["play"]();
					}
					this.resume_me = false;
				}
			}
			break;
		case API_CORDOVA:
			if (s)
			{
				if (this.isPlaying())
				{
					this.instanceObject["pause"]();
					this.resume_me = true;
				}
				else
					this.resume_me = false;
			}
			else
			{
				if (this.resume_me)
				{
					this.resume_me = false;
					this.instanceObject["play"]();
				}
			}
			break;
		case API_APPMOBI:
			break;
		}
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
		audRuntime = this.runtime;
		audInst = this;
		this.listenerTracker = null;
		this.listenerZ = -600;
		if (this.runtime.isWKWebView)
			playMusicAsSoundWorkaround = true;
		if ((this.runtime.isiOS || (this.runtime.isAndroid && (this.runtime.isChrome || this.runtime.isAndroidStockBrowser))) && !this.runtime.isCrosswalk && !this.runtime.isDomFree && !this.runtime.isAmazonWebApp && !playMusicAsSoundWorkaround)
		{
			isMusicWorkaround = true;
		}
		context = null;
		if (typeof AudioContext !== "undefined")
		{
			api = API_WEBAUDIO;
			context = new AudioContext();
		}
		else if (typeof webkitAudioContext !== "undefined")
		{
			api = API_WEBAUDIO;
			context = new webkitAudioContext();
		}
		if (this.runtime.isiOS && context)
		{
			if (context.close)
				context.close();
			if (typeof AudioContext !== "undefined")
				context = new AudioContext();
			else if (typeof webkitAudioContext !== "undefined")
				context = new webkitAudioContext();
		}
		var isAndroid = this.runtime.isAndroid;
		var playDummyBuffer = function ()
		{
			if (isContextSuspended || !context["createBuffer"])
				return;
			var buffer = context["createBuffer"](1, 220, 22050);
			var source = context["createBufferSource"]();
			source["buffer"] = buffer;
			source["connect"](context["destination"]);
			startSource(source);
		};
		if (isMusicWorkaround)
		{
			var playQueuedMusic = function ()
			{
				var i, len, m;
				if (isMusicWorkaround)
				{
					if (!silent)
					{
						for (i = 0, len = musicPlayNextTouch.length; i < len; ++i)
						{
							m = musicPlayNextTouch[i];
							if (!m.stopped && !m.is_paused)
								m.instanceObject.play();
						}
					}
					cr.clearArray(musicPlayNextTouch);
				}
			};
			document.addEventListener("touchend", function ()
			{
				if (!iOShadtouchend && context)
				{
					playDummyBuffer();
					iOShadtouchend = true;
				}
				playQueuedMusic();
			}, true);
		}
		else if (playMusicAsSoundWorkaround)
		{
			document.addEventListener("touchend", function ()
			{
				if (!iOShadtouchend && context)
				{
					playDummyBuffer();
					iOShadtouchend = true;
				}
			}, true);
		}
		if (api !== API_WEBAUDIO)
		{
			if (this.runtime.isCordova && typeof window["Media"] !== "undefined")
				api = API_CORDOVA;
			else if (this.runtime.isAppMobi)
				api = API_APPMOBI;
		}
		if (api === API_CORDOVA)
		{
			appPath = location.href;
			var i = appPath.lastIndexOf("/");
			if (i > -1)
				appPath = appPath.substr(0, i + 1);
			appPath = appPath.replace("file://", "");
		}
		if (this.runtime.isSafari && this.runtime.isWindows && typeof Audio === "undefined")
		{
			alert("It looks like you're using Safari for Windows without Quicktime.  Audio cannot be played until Quicktime is installed.");
			this.runtime.DestroyInstance(this);
		}
		else
		{
			if (this.runtime.isDirectCanvas)
				useOgg = this.runtime.isAndroid;		// AAC on iOS, OGG on Android
			else
			{
				try {
					useOgg = !!(new Audio().canPlayType('audio/ogg; codecs="vorbis"'));
				}
				catch (e)
				{
					useOgg = false;
				}
			}
			switch (api) {
			case API_HTML5:
;
				break;
			case API_WEBAUDIO:
;
				break;
			case API_CORDOVA:
;
				break;
			case API_APPMOBI:
;
				break;
			default:
;
			}
			this.runtime.tickMe(this);
		}
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onCreate = function ()
	{
		this.runtime.audioInstance = this;
		timescale_mode = this.properties[0];	// 0 = off, 1 = sounds only, 2 = all
		this.saveload = this.properties[1];		// 0 = all, 1 = sounds only, 2 = music only, 3 = none
		this.playinbackground = (this.properties[2] !== 0);
		this.nextPlayTime = 0;
		panningModel = this.properties[3];		// 0 = equalpower, 1 = hrtf, 3 = soundfield
		distanceModel = this.properties[4];		// 0 = linear, 1 = inverse, 2 = exponential
		this.listenerZ = -this.properties[5];
		refDistance = this.properties[6];
		maxDistance = this.properties[7];
		rolloffFactor = this.properties[8];
		this.listenerTracker = new ObjectTracker();
		var draw_width = (this.runtime.draw_width || this.runtime.width);
		var draw_height = (this.runtime.draw_height || this.runtime.height);
		if (api === API_WEBAUDIO)
		{
			context["listener"]["setPosition"](draw_width / 2, draw_height / 2, this.listenerZ);
			context["listener"]["setOrientation"](0, 0, 1, 0, -1, 0);
			window["c2OnAudioMicStream"] = function (localMediaStream, tag)
			{
				if (micSource)
					micSource["disconnect"]();
				micTag = tag.toLowerCase();
				micSource = context["createMediaStreamSource"](localMediaStream);
				micSource["connect"](getDestinationForTag(micTag));
			};
		}
		this.runtime.addSuspendCallback(function(s)
		{
			audInst.onSuspend(s);
		});
		var self = this;
		this.runtime.addDestroyCallback(function (inst)
		{
			self.onInstanceDestroyed(inst);
		});
	};
	instanceProto.onInstanceDestroyed = function (inst)
	{
		var i, len, a;
		for (i = 0, len = audioInstances.length; i < len; i++)
		{
			a = audioInstances[i];
			if (a.objectTracker)
			{
				if (a.objectTracker.obj === inst)
				{
					a.objectTracker.obj = null;
					if (a.pannerEnabled && a.isPlaying() && a.looping)
						a.stop();
				}
			}
		}
		if (this.listenerTracker.obj === inst)
			this.listenerTracker.obj = null;
	};
	instanceProto.saveToJSON = function ()
	{
		var o = {
			"silent": silent,
			"masterVolume": masterVolume,
			"listenerZ": this.listenerZ,
			"listenerUid": this.listenerTracker.hasObject() ? this.listenerTracker.obj.uid : -1,
			"playing": [],
			"effects": {}
		};
		var playingarr = o["playing"];
		var i, len, a, d, p, panobj, playbackTime;
		for (i = 0, len = audioInstances.length; i < len; i++)
		{
			a = audioInstances[i];
			if (!a.shouldSave())
				continue;				// no need to save stopped sounds
			if (this.saveload === 3)	// not saving/loading any sounds/music
				continue;
			if (a.is_music && this.saveload === 1)	// not saving/loading music
				continue;
			if (!a.is_music && this.saveload === 2)	// not saving/loading sound
				continue;
			playbackTime = a.getPlaybackTime();
			if (a.looping)
				playbackTime = playbackTime % a.getDuration();
			d = {
				"tag": a.tag,
				"buffersrc": a.buffer.src,
				"is_music": a.is_music,
				"playbackTime": playbackTime,
				"volume": a.volume,
				"looping": a.looping,
				"muted": a.is_muted,
				"playbackRate": a.playbackRate,
				"paused": a.is_paused,
				"resume_position": a.resume_position
			};
			if (a.pannerEnabled)
			{
				d["pan"] = {};
				panobj = d["pan"];
				if (a.objectTracker && a.objectTracker.hasObject())
				{
					panobj["objUid"] = a.objectTracker.obj.uid;
				}
				else
				{
					panobj["x"] = a.panX;
					panobj["y"] = a.panY;
					panobj["a"] = a.panAngle;
				}
				panobj["ia"] = a.panConeInner;
				panobj["oa"] = a.panConeOuter;
				panobj["og"] = a.panConeOuterGain;
			}
			playingarr.push(d);
		}
		var fxobj = o["effects"];
		var fxarr;
		for (p in effects)
		{
			if (effects.hasOwnProperty(p))
			{
				fxarr = [];
				for (i = 0, len = effects[p].length; i < len; i++)
				{
					fxarr.push({ "type": effects[p][i].type, "params": effects[p][i].params });
				}
				fxobj[p] = fxarr;
			}
		}
		return o;
	};
	var objectTrackerUidsToLoad = [];
	instanceProto.loadFromJSON = function (o)
	{
		var setSilent = o["silent"];
		masterVolume = o["masterVolume"];
		this.listenerZ = o["listenerZ"];
		this.listenerTracker.setObject(null);
		var listenerUid = o["listenerUid"];
		if (listenerUid !== -1)
		{
			this.listenerTracker.loadUid = listenerUid;
			objectTrackerUidsToLoad.push(this.listenerTracker);
		}
		var playingarr = o["playing"];
		var i, len, d, src, is_music, tag, playbackTime, looping, vol, b, a, p, pan, panObjUid;
		if (this.saveload !== 3)
		{
			for (i = 0, len = audioInstances.length; i < len; i++)
			{
				a = audioInstances[i];
				if (a.is_music && this.saveload === 1)
					continue;		// only saving/loading sound: leave music playing
				if (!a.is_music && this.saveload === 2)
					continue;		// only saving/loading music: leave sound playing
				a.stop();
			}
		}
		var fxarr, fxtype, fxparams, fx;
		for (p in effects)
		{
			if (effects.hasOwnProperty(p))
			{
				for (i = 0, len = effects[p].length; i < len; i++)
					effects[p][i].remove();
			}
		}
		cr.wipe(effects);
		for (p in o["effects"])
		{
			if (o["effects"].hasOwnProperty(p))
			{
				fxarr = o["effects"][p];
				for (i = 0, len = fxarr.length; i < len; i++)
				{
					fxtype = fxarr[i]["type"];
					fxparams = fxarr[i]["params"];
					switch (fxtype) {
					case "filter":
						addEffectForTag(p, new FilterEffect(fxparams[0], fxparams[1], fxparams[2], fxparams[3], fxparams[4], fxparams[5]));
						break;
					case "delay":
						addEffectForTag(p, new DelayEffect(fxparams[0], fxparams[1], fxparams[2]));
						break;
					case "convolve":
						src = fxparams[2];
						b = this.getAudioBuffer(src, false);
						if (b.bufferObject)
						{
							fx = new ConvolveEffect(b.bufferObject, fxparams[0], fxparams[1], src);
						}
						else
						{
							fx = new ConvolveEffect(null, fxparams[0], fxparams[1], src);
							b.normalizeWhenReady = fxparams[0];
							b.convolveWhenReady = fx;
						}
						addEffectForTag(p, fx);
						break;
					case "flanger":
						addEffectForTag(p, new FlangerEffect(fxparams[0], fxparams[1], fxparams[2], fxparams[3], fxparams[4]));
						break;
					case "phaser":
						addEffectForTag(p, new PhaserEffect(fxparams[0], fxparams[1], fxparams[2], fxparams[3], fxparams[4], fxparams[5]));
						break;
					case "gain":
						addEffectForTag(p, new GainEffect(fxparams[0]));
						break;
					case "tremolo":
						addEffectForTag(p, new TremoloEffect(fxparams[0], fxparams[1]));
						break;
					case "ringmod":
						addEffectForTag(p, new RingModulatorEffect(fxparams[0], fxparams[1]));
						break;
					case "distortion":
						addEffectForTag(p, new DistortionEffect(fxparams[0], fxparams[1], fxparams[2], fxparams[3], fxparams[4]));
						break;
					case "compressor":
						addEffectForTag(p, new CompressorEffect(fxparams[0], fxparams[1], fxparams[2], fxparams[3], fxparams[4]));
						break;
					case "analyser":
						addEffectForTag(p, new AnalyserEffect(fxparams[0], fxparams[1]));
						break;
					}
				}
			}
		}
		for (i = 0, len = playingarr.length; i < len; i++)
		{
			if (this.saveload === 3)	// not saving/loading any sounds/music
				continue;
			d = playingarr[i];
			src = d["buffersrc"];
			is_music = d["is_music"];
			tag = d["tag"];
			playbackTime = d["playbackTime"];
			looping = d["looping"];
			vol = d["volume"];
			pan = d["pan"];
			panObjUid = (pan && pan.hasOwnProperty("objUid")) ? pan["objUid"] : -1;
			if (is_music && this.saveload === 1)	// not saving/loading music
				continue;
			if (!is_music && this.saveload === 2)	// not saving/loading sound
				continue;
			a = this.getAudioInstance(src, tag, is_music, looping, vol);
			if (!a)
			{
				b = this.getAudioBuffer(src, is_music);
				b.seekWhenReady = playbackTime;
				b.pauseWhenReady = d["paused"];
				if (pan)
				{
					if (panObjUid !== -1)
					{
						b.panWhenReady.push({ objUid: panObjUid, ia: pan["ia"], oa: pan["oa"], og: pan["og"], thistag: tag });
					}
					else
					{
						b.panWhenReady.push({ x: pan["x"], y: pan["y"], a: pan["a"], ia: pan["ia"], oa: pan["oa"], og: pan["og"], thistag: tag });
					}
				}
				continue;
			}
			a.resume_position = d["resume_position"];
			a.setPannerEnabled(!!pan);
			a.play(looping, vol, playbackTime);
			a.updatePlaybackRate();
			a.updateVolume();
			a.doSetMuted(a.is_muted || a.is_silent);
			if (d["paused"])
				a.pause();
			if (d["muted"])
				a.setMuted(true);
			a.doSetMuted(a.is_muted || a.is_silent);
			if (pan)
			{
				if (panObjUid !== -1)
				{
					a.objectTracker = a.objectTracker || new ObjectTracker();
					a.objectTracker.loadUid = panObjUid;
					objectTrackerUidsToLoad.push(a.objectTracker);
				}
				else
				{
					a.setPan(pan["x"], pan["y"], pan["a"], pan["ia"], pan["oa"], pan["og"]);
				}
			}
		}
		if (setSilent && !silent)			// setting silent
		{
			for (i = 0, len = audioInstances.length; i < len; i++)
				audioInstances[i].setSilent(true);
			silent = true;
		}
		else if (!setSilent && silent)		// setting not silent
		{
			for (i = 0, len = audioInstances.length; i < len; i++)
				audioInstances[i].setSilent(false);
			silent = false;
		}
	};
	instanceProto.afterLoad = function ()
	{
		var i, len, ot, inst;
		for (i = 0, len = objectTrackerUidsToLoad.length; i < len; i++)
		{
			ot = objectTrackerUidsToLoad[i];
			inst = this.runtime.getObjectByUID(ot.loadUid);
			ot.setObject(inst);
			ot.loadUid = -1;
			if (inst)
			{
				listenerX = inst.x;
				listenerY = inst.y;
			}
		}
		cr.clearArray(objectTrackerUidsToLoad);
	};
	instanceProto.onSuspend = function (s)
	{
		if (this.playinbackground)
			return;
		if (!s && context && context["resume"])
		{
			context["resume"]();
			isContextSuspended = false;
		}
		var i, len;
		for (i = 0, len = audioInstances.length; i < len; i++)
			audioInstances[i].setSuspended(s);
		if (s && context && context["suspend"])
		{
			context["suspend"]();
			isContextSuspended = true;
		}
	};
	instanceProto.tick = function ()
	{
		var dt = this.runtime.dt;
		var i, len, a;
		for (i = 0, len = audioInstances.length; i < len; i++)
		{
			a = audioInstances[i];
			a.tick(dt);
			if (timescale_mode !== 0)
				a.updatePlaybackRate();
		}
		var p, arr, f;
		for (p in effects)
		{
			if (effects.hasOwnProperty(p))
			{
				arr = effects[p];
				for (i = 0, len = arr.length; i < len; i++)
				{
					f = arr[i];
					if (f.tick)
						f.tick();
				}
			}
		}
		if (api === API_WEBAUDIO && this.listenerTracker.hasObject())
		{
			this.listenerTracker.tick(dt);
			listenerX = this.listenerTracker.obj.x;
			listenerY = this.listenerTracker.obj.y;
			context["listener"]["setPosition"](this.listenerTracker.obj.x, this.listenerTracker.obj.y, this.listenerZ);
		}
	};
	var preload_list = [];
	instanceProto.setPreloadList = function (arr)
	{
		var i, len, p, filename, size, isOgg;
		var total_size = 0;
		for (i = 0, len = arr.length; i < len; ++i)
		{
			p = arr[i];
			filename = p[0];
			size = p[1] * 2;
			isOgg = (filename.length > 4 && filename.substr(filename.length - 4) === ".ogg");
			if ((isOgg && useOgg) || (!isOgg && !useOgg))
			{
				preload_list.push({
					filename: filename,
					size: size,
					obj: null
				});
				total_size += size;
			}
		}
		return total_size;
	};
	instanceProto.startPreloads = function ()
	{
		var i, len, p, src;
		for (i = 0, len = preload_list.length; i < len; ++i)
		{
			p = preload_list[i];
			src = this.runtime.files_subfolder + p.filename;
			p.obj = this.getAudioBuffer(src, false);
		}
	};
	instanceProto.getPreloadedSize = function ()
	{
		var completed = 0;
		var i, len, p;
		for (i = 0, len = preload_list.length; i < len; ++i)
		{
			p = preload_list[i];
			if (p.obj.isLoadedAndDecoded() || p.obj.hasFailedToLoad() || this.runtime.isDomFree || this.runtime.isAndroidStockBrowser)
			{
				completed += p.size;
			}
			else if (p.obj.isLoaded())	// downloaded but not decoded: only happens in Web Audio API, count as half-way progress
			{
				completed += Math.floor(p.size / 2);
			}
		};
		return completed;
	};
	instanceProto.releaseAllMusicBuffers = function ()
	{
		var i, len, j, b;
		for (i = 0, j = 0, len = audioBuffers.length; i < len; ++i)
		{
			b = audioBuffers[i];
			audioBuffers[j] = b;
			if (b.is_music)
				b.release();
			else
				++j;		// keep
		}
		audioBuffers.length = j;
	};
	instanceProto.getAudioBuffer = function (src_, is_music)
	{
		var i, len, a, ret = null, j, k, lenj, ai;
		for (i = 0, len = audioBuffers.length; i < len; i++)
		{
			a = audioBuffers[i];
			if (a.src === src_)
			{
				ret = a;
				break;
			}
		}
		if (!ret)
		{
			if (playMusicAsSoundWorkaround && is_music)
				this.releaseAllMusicBuffers();
			ret = new C2AudioBuffer(src_, is_music);
			audioBuffers.push(ret);
		}
		return ret;
	};
	instanceProto.getAudioInstance = function (src_, tag, is_music, looping, vol)
	{
		var i, len, a;
		for (i = 0, len = audioInstances.length; i < len; i++)
		{
			a = audioInstances[i];
			if (a.src === src_ && (a.canBeRecycled() || is_music))
			{
				a.tag = tag;
				return a;
			}
		}
		var b = this.getAudioBuffer(src_, is_music);
		if (!b.bufferObject)
		{
			if (tag !== "<preload>")
			{
				b.playTagWhenReady = tag;
				b.loopWhenReady = looping;
				b.volumeWhenReady = vol;
			}
			return null;
		}
		a = new C2AudioInstance(b, tag);
		audioInstances.push(a);
		return a;
	};
	var taggedAudio = [];
	function SortByIsPlaying(a, b)
	{
		var an = a.isPlaying() ? 1 : 0;
		var bn = b.isPlaying() ? 1 : 0;
		if (an === bn)
			return 0;
		else if (an < bn)
			return 1;
		else
			return -1;
	};
	function getAudioByTag(tag, sort_by_playing)
	{
		cr.clearArray(taggedAudio);
		if (!tag.length)
		{
			if (!lastAudio || lastAudio.hasEnded())
				return;
			else
			{
				cr.clearArray(taggedAudio);
				taggedAudio[0] = lastAudio;
				return;
			}
		}
		var i, len, a;
		for (i = 0, len = audioInstances.length; i < len; i++)
		{
			a = audioInstances[i];
			if (cr.equals_nocase(tag, a.tag))
				taggedAudio.push(a);
		}
		if (sort_by_playing)
			taggedAudio.sort(SortByIsPlaying);
	};
	function reconnectEffects(tag)
	{
		var i, len, arr, n, toNode = context["destination"];
		if (effects.hasOwnProperty(tag))
		{
			arr = effects[tag];
			if (arr.length)
			{
				toNode = arr[0].getInputNode();
				for (i = 0, len = arr.length; i < len; i++)
				{
					n = arr[i];
					if (i + 1 === len)
						n.connectTo(context["destination"]);
					else
						n.connectTo(arr[i + 1].getInputNode());
				}
			}
		}
		getAudioByTag(tag);
		for (i = 0, len = taggedAudio.length; i < len; i++)
			taggedAudio[i].reconnect(toNode);
		if (micSource && micTag === tag)
		{
			micSource["disconnect"]();
			micSource["connect"](toNode);
		}
	};
	function addEffectForTag(tag, fx)
	{
		if (!effects.hasOwnProperty(tag))
			effects[tag] = [fx];
		else
			effects[tag].push(fx);
		reconnectEffects(tag);
	};
	function Cnds() {};
	Cnds.prototype.OnEnded = function (t)
	{
		return cr.equals_nocase(audTag, t);
	};
	Cnds.prototype.PreloadsComplete = function ()
	{
		var i, len;
		for (i = 0, len = audioBuffers.length; i < len; i++)
		{
			if (!audioBuffers[i].isLoadedAndDecoded() && !audioBuffers[i].hasFailedToLoad())
				return false;
		}
		return true;
	};
	Cnds.prototype.AdvancedAudioSupported = function ()
	{
		return api === API_WEBAUDIO;
	};
	Cnds.prototype.IsSilent = function ()
	{
		return silent;
	};
	Cnds.prototype.IsAnyPlaying = function ()
	{
		var i, len;
		for (i = 0, len = audioInstances.length; i < len; i++)
		{
			if (audioInstances[i].isPlaying())
				return true;
		}
		return false;
	};
	Cnds.prototype.IsTagPlaying = function (tag)
	{
		getAudioByTag(tag);
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
		{
			if (taggedAudio[i].isPlaying())
				return true;
		}
		return false;
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.Play = function (file, looping, vol, tag)
	{
		if (silent)
			return;
		var v = dbToLinear(vol);
		var is_music = file[1];
		var src = this.runtime.files_subfolder + file[0] + (useOgg ? ".ogg" : ".m4a");
		lastAudio = this.getAudioInstance(src, tag, is_music, looping!==0, v);
		if (!lastAudio)
			return;
		lastAudio.setPannerEnabled(false);
		lastAudio.play(looping!==0, v, 0, this.nextPlayTime);
		this.nextPlayTime = 0;
	};
	Acts.prototype.PlayAtPosition = function (file, looping, vol, x_, y_, angle_, innerangle_, outerangle_, outergain_, tag)
	{
		if (silent)
			return;
		var v = dbToLinear(vol);
		var is_music = file[1];
		var src = this.runtime.files_subfolder + file[0] + (useOgg ? ".ogg" : ".m4a");
		lastAudio = this.getAudioInstance(src, tag, is_music, looping!==0, v);
		if (!lastAudio)
		{
			var b = this.getAudioBuffer(src, is_music);
			b.panWhenReady.push({ x: x_, y: y_, a: angle_, ia: innerangle_, oa: outerangle_, og: dbToLinear(outergain_), thistag: tag });
			return;
		}
		lastAudio.setPannerEnabled(true);
		lastAudio.setPan(x_, y_, angle_, innerangle_, outerangle_, dbToLinear(outergain_));
		lastAudio.play(looping!==0, v, 0, this.nextPlayTime);
		this.nextPlayTime = 0;
	};
	Acts.prototype.PlayAtObject = function (file, looping, vol, obj, innerangle, outerangle, outergain, tag)
	{
		if (silent || !obj)
			return;
		var inst = obj.getFirstPicked();
		if (!inst)
			return;
		var v = dbToLinear(vol);
		var is_music = file[1];
		var src = this.runtime.files_subfolder + file[0] + (useOgg ? ".ogg" : ".m4a");
		lastAudio = this.getAudioInstance(src, tag, is_music, looping!==0, v);
		if (!lastAudio)
		{
			var b = this.getAudioBuffer(src, is_music);
			b.panWhenReady.push({ obj: inst, ia: innerangle, oa: outerangle, og: dbToLinear(outergain), thistag: tag });
			return;
		}
		lastAudio.setPannerEnabled(true);
		var px = cr.rotatePtAround(inst.x, inst.y, -inst.layer.getAngle(), listenerX, listenerY, true);
		var py = cr.rotatePtAround(inst.x, inst.y, -inst.layer.getAngle(), listenerX, listenerY, false);
		lastAudio.setPan(px, py, cr.to_degrees(inst.angle - inst.layer.getAngle()), innerangle, outerangle, dbToLinear(outergain));
		lastAudio.setObject(inst);
		lastAudio.play(looping!==0, v, 0, this.nextPlayTime);
		this.nextPlayTime = 0;
	};
	Acts.prototype.PlayByName = function (folder, filename, looping, vol, tag)
	{
		if (silent)
			return;
		var v = dbToLinear(vol);
		var is_music = (folder === 1);
		var src = this.runtime.files_subfolder + filename.toLowerCase() + (useOgg ? ".ogg" : ".m4a");
		lastAudio = this.getAudioInstance(src, tag, is_music, looping!==0, v);
		if (!lastAudio)
			return;
		lastAudio.setPannerEnabled(false);
		lastAudio.play(looping!==0, v, 0, this.nextPlayTime);
		this.nextPlayTime = 0;
	};
	Acts.prototype.PlayAtPositionByName = function (folder, filename, looping, vol, x_, y_, angle_, innerangle_, outerangle_, outergain_, tag)
	{
		if (silent)
			return;
		var v = dbToLinear(vol);
		var is_music = (folder === 1);
		var src = this.runtime.files_subfolder + filename.toLowerCase() + (useOgg ? ".ogg" : ".m4a");
		lastAudio = this.getAudioInstance(src, tag, is_music, looping!==0, v);
		if (!lastAudio)
		{
			var b = this.getAudioBuffer(src, is_music);
			b.panWhenReady.push({ x: x_, y: y_, a: angle_, ia: innerangle_, oa: outerangle_, og: dbToLinear(outergain_), thistag: tag });
			return;
		}
		lastAudio.setPannerEnabled(true);
		lastAudio.setPan(x_, y_, angle_, innerangle_, outerangle_, dbToLinear(outergain_));
		lastAudio.play(looping!==0, v, 0, this.nextPlayTime);
		this.nextPlayTime = 0;
	};
	Acts.prototype.PlayAtObjectByName = function (folder, filename, looping, vol, obj, innerangle, outerangle, outergain, tag)
	{
		if (silent || !obj)
			return;
		var inst = obj.getFirstPicked();
		if (!inst)
			return;
		var v = dbToLinear(vol);
		var is_music = (folder === 1);
		var src = this.runtime.files_subfolder + filename.toLowerCase() + (useOgg ? ".ogg" : ".m4a");
		lastAudio = this.getAudioInstance(src, tag, is_music, looping!==0, v);
		if (!lastAudio)
		{
			var b = this.getAudioBuffer(src, is_music);
			b.panWhenReady.push({ obj: inst, ia: innerangle, oa: outerangle, og: dbToLinear(outergain), thistag: tag });
			return;
		}
		lastAudio.setPannerEnabled(true);
		var px = cr.rotatePtAround(inst.x, inst.y, -inst.layer.getAngle(), listenerX, listenerY, true);
		var py = cr.rotatePtAround(inst.x, inst.y, -inst.layer.getAngle(), listenerX, listenerY, false);
		lastAudio.setPan(px, py, cr.to_degrees(inst.angle - inst.layer.getAngle()), innerangle, outerangle, dbToLinear(outergain));
		lastAudio.setObject(inst);
		lastAudio.play(looping!==0, v, 0, this.nextPlayTime);
		this.nextPlayTime = 0;
	};
	Acts.prototype.SetLooping = function (tag, looping)
	{
		getAudioByTag(tag);
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
			taggedAudio[i].setLooping(looping === 0);
	};
	Acts.prototype.SetMuted = function (tag, muted)
	{
		getAudioByTag(tag);
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
			taggedAudio[i].setMuted(muted === 0);
	};
	Acts.prototype.SetVolume = function (tag, vol)
	{
		getAudioByTag(tag);
		var v = dbToLinear(vol);
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
			taggedAudio[i].setVolume(v);
	};
	Acts.prototype.Preload = function (file)
	{
		if (silent)
			return;
		var is_music = file[1];
		var src = this.runtime.files_subfolder + file[0] + (useOgg ? ".ogg" : ".m4a");
		if (api === API_APPMOBI)
		{
			if (this.runtime.isDirectCanvas)
				AppMobi["context"]["loadSound"](src);
			else
				AppMobi["player"]["loadSound"](src);
			return;
		}
		else if (api === API_CORDOVA)
		{
			return;
		}
		this.getAudioInstance(src, "<preload>", is_music, false);
	};
	Acts.prototype.PreloadByName = function (folder, filename)
	{
		if (silent)
			return;
		var is_music = (folder === 1);
		var src = this.runtime.files_subfolder + filename.toLowerCase() + (useOgg ? ".ogg" : ".m4a");
		if (api === API_APPMOBI)
		{
			if (this.runtime.isDirectCanvas)
				AppMobi["context"]["loadSound"](src);
			else
				AppMobi["player"]["loadSound"](src);
			return;
		}
		else if (api === API_CORDOVA)
		{
			return;
		}
		this.getAudioInstance(src, "<preload>", is_music, false);
	};
	Acts.prototype.SetPlaybackRate = function (tag, rate)
	{
		getAudioByTag(tag);
		if (rate < 0.0)
			rate = 0;
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
			taggedAudio[i].setPlaybackRate(rate);
	};
	Acts.prototype.Stop = function (tag)
	{
		getAudioByTag(tag);
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
			taggedAudio[i].stop();
	};
	Acts.prototype.StopAll = function ()
	{
		var i, len;
		for (i = 0, len = audioInstances.length; i < len; i++)
			audioInstances[i].stop();
	};
	Acts.prototype.SetPaused = function (tag, state)
	{
		getAudioByTag(tag);
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
		{
			if (state === 0)
				taggedAudio[i].pause();
			else
				taggedAudio[i].resume();
		}
	};
	Acts.prototype.Seek = function (tag, pos)
	{
		getAudioByTag(tag);
		var i, len;
		for (i = 0, len = taggedAudio.length; i < len; i++)
		{
			taggedAudio[i].seek(pos);
		}
	};
	Acts.prototype.SetSilent = function (s)
	{
		var i, len;
		if (s === 2)					// toggling
			s = (silent ? 1 : 0);		// choose opposite state
		if (s === 0 && !silent)			// setting silent
		{
			for (i = 0, len = audioInstances.length; i < len; i++)
				audioInstances[i].setSilent(true);
			silent = true;
		}
		else if (s === 1 && silent)		// setting not silent
		{
			for (i = 0, len = audioInstances.length; i < len; i++)
				audioInstances[i].setSilent(false);
			silent = false;
		}
	};
	Acts.prototype.SetMasterVolume = function (vol)
	{
		masterVolume = dbToLinear(vol);
		var i, len;
		for (i = 0, len = audioInstances.length; i < len; i++)
			audioInstances[i].updateVolume();
	};
	Acts.prototype.AddFilterEffect = function (tag, type, freq, detune, q, gain, mix)
	{
		if (api !== API_WEBAUDIO || type < 0 || type >= filterTypes.length || !context["createBiquadFilter"])
			return;
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		addEffectForTag(tag, new FilterEffect(type, freq, detune, q, gain, mix));
	};
	Acts.prototype.AddDelayEffect = function (tag, delay, gain, mix)
	{
		if (api !== API_WEBAUDIO)
			return;
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		addEffectForTag(tag, new DelayEffect(delay, dbToLinear(gain), mix));
	};
	Acts.prototype.AddFlangerEffect = function (tag, delay, modulation, freq, feedback, mix)
	{
		if (api !== API_WEBAUDIO || !context["createOscillator"])
			return;
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		addEffectForTag(tag, new FlangerEffect(delay / 1000, modulation / 1000, freq, feedback / 100, mix));
	};
	Acts.prototype.AddPhaserEffect = function (tag, freq, detune, q, mod, modfreq, mix)
	{
		if (api !== API_WEBAUDIO || !context["createOscillator"])
			return;
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		addEffectForTag(tag, new PhaserEffect(freq, detune, q, mod, modfreq, mix));
	};
	Acts.prototype.AddConvolutionEffect = function (tag, file, norm, mix)
	{
		if (api !== API_WEBAUDIO || !context["createConvolver"])
			return;
		var doNormalize = (norm === 0);
		var src = this.runtime.files_subfolder + file[0] + (useOgg ? ".ogg" : ".m4a");
		var b = this.getAudioBuffer(src, false);
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		var fx;
		if (b.bufferObject)
		{
			fx = new ConvolveEffect(b.bufferObject, doNormalize, mix, src);
		}
		else
		{
			fx = new ConvolveEffect(null, doNormalize, mix, src);
			b.normalizeWhenReady = doNormalize;
			b.convolveWhenReady = fx;
		}
		addEffectForTag(tag, fx);
	};
	Acts.prototype.AddGainEffect = function (tag, g)
	{
		if (api !== API_WEBAUDIO)
			return;
		tag = tag.toLowerCase();
		addEffectForTag(tag, new GainEffect(dbToLinear(g)));
	};
	Acts.prototype.AddMuteEffect = function (tag)
	{
		if (api !== API_WEBAUDIO)
			return;
		tag = tag.toLowerCase();
		addEffectForTag(tag, new GainEffect(0));	// re-use gain effect with 0 gain
	};
	Acts.prototype.AddTremoloEffect = function (tag, freq, mix)
	{
		if (api !== API_WEBAUDIO || !context["createOscillator"])
			return;
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		addEffectForTag(tag, new TremoloEffect(freq, mix));
	};
	Acts.prototype.AddRingModEffect = function (tag, freq, mix)
	{
		if (api !== API_WEBAUDIO || !context["createOscillator"])
			return;
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		addEffectForTag(tag, new RingModulatorEffect(freq, mix));
	};
	Acts.prototype.AddDistortionEffect = function (tag, threshold, headroom, drive, makeupgain, mix)
	{
		if (api !== API_WEBAUDIO || !context["createWaveShaper"])
			return;
		tag = tag.toLowerCase();
		mix = mix / 100;
		if (mix < 0) mix = 0;
		if (mix > 1) mix = 1;
		addEffectForTag(tag, new DistortionEffect(threshold, headroom, drive, makeupgain, mix));
	};
	Acts.prototype.AddCompressorEffect = function (tag, threshold, knee, ratio, attack, release)
	{
		if (api !== API_WEBAUDIO || !context["createDynamicsCompressor"])
			return;
		tag = tag.toLowerCase();
		addEffectForTag(tag, new CompressorEffect(threshold, knee, ratio, attack / 1000, release / 1000));
	};
	Acts.prototype.AddAnalyserEffect = function (tag, fftSize, smoothing)
	{
		if (api !== API_WEBAUDIO)
			return;
		tag = tag.toLowerCase();
		addEffectForTag(tag, new AnalyserEffect(fftSize, smoothing));
	};
	Acts.prototype.RemoveEffects = function (tag)
	{
		if (api !== API_WEBAUDIO)
			return;
		tag = tag.toLowerCase();
		var i, len, arr;
		if (effects.hasOwnProperty(tag))
		{
			arr = effects[tag];
			if (arr.length)
			{
				for (i = 0, len = arr.length; i < len; i++)
					arr[i].remove();
				cr.clearArray(arr);
				reconnectEffects(tag);
			}
		}
	};
	Acts.prototype.SetEffectParameter = function (tag, index, param, value, ramp, time)
	{
		if (api !== API_WEBAUDIO)
			return;
		tag = tag.toLowerCase();
		index = Math.floor(index);
		var arr;
		if (!effects.hasOwnProperty(tag))
			return;
		arr = effects[tag];
		if (index < 0 || index >= arr.length)
			return;
		arr[index].setParam(param, value, ramp, time);
	};
	Acts.prototype.SetListenerObject = function (obj_)
	{
		if (!obj_ || api !== API_WEBAUDIO)
			return;
		var inst = obj_.getFirstPicked();
		if (!inst)
			return;
		this.listenerTracker.setObject(inst);
		listenerX = inst.x;
		listenerY = inst.y;
	};
	Acts.prototype.SetListenerZ = function (z)
	{
		this.listenerZ = z;
	};
	Acts.prototype.ScheduleNextPlay = function (t)
	{
		if (!context)
			return;		// needs Web Audio API
		this.nextPlayTime = t;
	};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.Duration = function (ret, tag)
	{
		getAudioByTag(tag, true);
		if (taggedAudio.length)
			ret.set_float(taggedAudio[0].getDuration());
		else
			ret.set_float(0);
	};
	Exps.prototype.PlaybackTime = function (ret, tag)
	{
		getAudioByTag(tag, true);
		if (taggedAudio.length)
			ret.set_float(taggedAudio[0].getPlaybackTime(true));
		else
			ret.set_float(0);
	};
	Exps.prototype.Volume = function (ret, tag)
	{
		getAudioByTag(tag, true);
		if (taggedAudio.length)
		{
			var v = taggedAudio[0].getVolume();
			ret.set_float(linearToDb(v));
		}
		else
			ret.set_float(0);
	};
	Exps.prototype.MasterVolume = function (ret)
	{
		ret.set_float(linearToDb(masterVolume));
	};
	Exps.prototype.EffectCount = function (ret, tag)
	{
		tag = tag.toLowerCase();
		var arr = null;
		if (effects.hasOwnProperty(tag))
			arr = effects[tag];
		ret.set_int(arr ? arr.length : 0);
	};
	function getAnalyser(tag, index)
	{
		var arr = null;
		if (effects.hasOwnProperty(tag))
			arr = effects[tag];
		if (arr && index >= 0 && index < arr.length && arr[index].freqBins)
			return arr[index];
		else
			return null;
	};
	Exps.prototype.AnalyserFreqBinCount = function (ret, tag, index)
	{
		tag = tag.toLowerCase();
		index = Math.floor(index);
		var analyser = getAnalyser(tag, index);
		ret.set_int(analyser ? analyser.node["frequencyBinCount"] : 0);
	};
	Exps.prototype.AnalyserFreqBinAt = function (ret, tag, index, bin)
	{
		tag = tag.toLowerCase();
		index = Math.floor(index);
		bin = Math.floor(bin);
		var analyser = getAnalyser(tag, index);
		if (!analyser)
			ret.set_float(0);
		else if (bin < 0 || bin >= analyser.node["frequencyBinCount"])
			ret.set_float(0);
		else
			ret.set_float(analyser.freqBins[bin]);
	};
	Exps.prototype.AnalyserPeakLevel = function (ret, tag, index)
	{
		tag = tag.toLowerCase();
		index = Math.floor(index);
		var analyser = getAnalyser(tag, index);
		if (analyser)
			ret.set_float(analyser.peak);
		else
			ret.set_float(0);
	};
	Exps.prototype.AnalyserRMSLevel = function (ret, tag, index)
	{
		tag = tag.toLowerCase();
		index = Math.floor(index);
		var analyser = getAnalyser(tag, index);
		if (analyser)
			ret.set_float(analyser.rms);
		else
			ret.set_float(0);
	};
	Exps.prototype.SampleRate = function (ret)
	{
		ret.set_int(context ? context.sampleRate : 0);
	};
	Exps.prototype.CurrentTime = function (ret)
	{
		ret.set_float(context ? context.currentTime : cr.performance_now());
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.plugins_.Browser = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Browser.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onCreate = function()
	{
		var self = this;
		window.addEventListener("resize", function () {
			self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnResize, self);
		});
		if (typeof navigator.onLine !== "undefined")
		{
			window.addEventListener("online", function() {
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnOnline, self);
			});
			window.addEventListener("offline", function() {
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnOffline, self);
			});
		}
		if (typeof window.applicationCache !== "undefined")
		{
			window.applicationCache.addEventListener('updateready', function() {
				self.runtime.loadingprogress = 1;
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnUpdateReady, self);
			});
			window.applicationCache.addEventListener('progress', function(e) {
				self.runtime.loadingprogress = (e["loaded"] / e["total"]) || 0;
			});
		}
		if (!this.runtime.isDirectCanvas)
		{
			document.addEventListener("appMobi.device.update.available", function() {
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnUpdateReady, self);
			});
			document.addEventListener("backbutton", function() {
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnBackButton, self);
			});
			document.addEventListener("menubutton", function() {
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnMenuButton, self);
			});
			document.addEventListener("searchbutton", function() {
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnSearchButton, self);
			});
			document.addEventListener("tizenhwkey", function (e) {
				var ret;
				switch (e["keyName"]) {
				case "back":
					ret = self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnBackButton, self);
					if (!ret)
					{
						if (window["tizen"])
							window["tizen"]["application"]["getCurrentApplication"]()["exit"]();
					}
					break;
				case "menu":
					ret = self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnMenuButton, self);
					if (!ret)
						e.preventDefault();
					break;
				}
			});
		}
		if (this.runtime.isWindows10 && typeof Windows !== "undefined")
		{
			Windows["UI"]["Core"]["SystemNavigationManager"]["getForCurrentView"]().addEventListener("backrequested", function (e)
			{
				var ret = self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnBackButton, self);
				if (ret)
					e.handled = true;
		    });
		}
		else if (this.runtime.isWinJS && WinJS["Application"])
		{
			WinJS["Application"]["onbackclick"] = function (e)
			{
				return !!self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnBackButton, self);
			};
		}
		this.runtime.addSuspendCallback(function(s) {
			if (s)
			{
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnPageHidden, self);
			}
			else
			{
				self.runtime.trigger(cr.plugins_.Browser.prototype.cnds.OnPageVisible, self);
			}
		});
		this.is_arcade = (typeof window["is_scirra_arcade"] !== "undefined");
	};
	var batteryManager = null;
	var loadedBatteryManager = false;
	function maybeLoadBatteryManager()
	{
		if (loadedBatteryManager)
			return;
		if (!navigator["getBattery"])
			return;
		var promise = navigator["getBattery"]();
		loadedBatteryManager = true;
		if (promise)
		{
			promise.then(function (manager) {
				batteryManager = manager;
			});
		}
	};
	function Cnds() {};
	Cnds.prototype.CookiesEnabled = function()
	{
		return navigator ? navigator.cookieEnabled : false;
	};
	Cnds.prototype.IsOnline = function()
	{
		return navigator ? navigator.onLine : false;
	};
	Cnds.prototype.HasJava = function()
	{
		return navigator ? navigator.javaEnabled() : false;
	};
	Cnds.prototype.OnOnline = function()
	{
		return true;
	};
	Cnds.prototype.OnOffline = function()
	{
		return true;
	};
	Cnds.prototype.IsDownloadingUpdate = function ()
	{
		if (typeof window["applicationCache"] === "undefined")
			return false;
		else
			return window["applicationCache"]["status"] === window["applicationCache"]["DOWNLOADING"];
	};
	Cnds.prototype.OnUpdateReady = function ()
	{
		return true;
	};
	Cnds.prototype.PageVisible = function ()
	{
		return !this.runtime.isSuspended;
	};
	Cnds.prototype.OnPageVisible = function ()
	{
		return true;
	};
	Cnds.prototype.OnPageHidden = function ()
	{
		return true;
	};
	Cnds.prototype.OnResize = function ()
	{
		return true;
	};
	Cnds.prototype.IsFullscreen = function ()
	{
		return !!(document["mozFullScreen"] || document["webkitIsFullScreen"] || document["fullScreen"] || this.runtime.isNodeFullscreen);
	};
	Cnds.prototype.OnBackButton = function ()
	{
		return true;
	};
	Cnds.prototype.OnMenuButton = function ()
	{
		return true;
	};
	Cnds.prototype.OnSearchButton = function ()
	{
		return true;
	};
	Cnds.prototype.IsMetered = function ()
	{
		var connection = navigator["connection"] || navigator["mozConnection"] || navigator["webkitConnection"];
		if (!connection)
			return false;
		return !!connection["metered"];
	};
	Cnds.prototype.IsCharging = function ()
	{
		var battery = navigator["battery"] || navigator["mozBattery"] || navigator["webkitBattery"];
		if (battery)
		{
			return !!battery["charging"]
		}
		else
		{
			maybeLoadBatteryManager();
			if (batteryManager)
			{
				return !!batteryManager["charging"];
			}
			else
			{
				return true;		// if unknown, default to charging (powered)
			}
		}
	};
	Cnds.prototype.IsPortraitLandscape = function (p)
	{
		var current = (window.innerWidth <= window.innerHeight ? 0 : 1);
		return current === p;
	};
	Cnds.prototype.SupportsFullscreen = function ()
	{
		if (this.runtime.isNodeWebkit)
			return true;
		var elem = this.runtime.canvasdiv || this.runtime.canvas;
		return !!(elem["requestFullscreen"] || elem["mozRequestFullScreen"] || elem["msRequestFullscreen"] || elem["webkitRequestFullScreen"]);
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.Alert = function (msg)
	{
		if (!this.runtime.isDomFree)
			alert(msg.toString());
	};
	Acts.prototype.Close = function ()
	{
		if (this.runtime.isCocoonJs)
			CocoonJS["App"]["forceToFinish"]();
		else if (window["tizen"])
			window["tizen"]["application"]["getCurrentApplication"]()["exit"]();
		else if (navigator["app"] && navigator["app"]["exitApp"])
			navigator["app"]["exitApp"]();
		else if (navigator["device"] && navigator["device"]["exitApp"])
			navigator["device"]["exitApp"]();
		else if (!this.is_arcade && !this.runtime.isDomFree)
			window.close();
	};
	Acts.prototype.Focus = function ()
	{
		if (this.runtime.isNodeWebkit)
		{
			var win = window["nwgui"]["Window"]["get"]();
			win["focus"]();
		}
		else if (!this.is_arcade && !this.runtime.isDomFree)
			window.focus();
	};
	Acts.prototype.Blur = function ()
	{
		if (this.runtime.isNodeWebkit)
		{
			var win = window["nwgui"]["Window"]["get"]();
			win["blur"]();
		}
		else if (!this.is_arcade && !this.runtime.isDomFree)
			window.blur();
	};
	Acts.prototype.GoBack = function ()
	{
		if (navigator["app"] && navigator["app"]["backHistory"])
			navigator["app"]["backHistory"]();
		else if (!this.is_arcade && !this.runtime.isDomFree && window.back)
			window.back();
	};
	Acts.prototype.GoForward = function ()
	{
		if (!this.is_arcade && !this.runtime.isDomFree && window.forward)
			window.forward();
	};
	Acts.prototype.GoHome = function ()
	{
		if (!this.is_arcade && !this.runtime.isDomFree && window.home)
			window.home();
	};
	Acts.prototype.GoToURL = function (url, target)
	{
		if (this.runtime.isCocoonJs)
			CocoonJS["App"]["openURL"](url);
		else if (this.runtime.isEjecta)
			ejecta["openURL"](url);
		else if (this.runtime.isWinJS)
			Windows["System"]["Launcher"]["launchUriAsync"](new Windows["Foundation"]["Uri"](url));
		else if (navigator["app"] && navigator["app"]["loadUrl"])
			navigator["app"]["loadUrl"](url, { "openExternal": true });
		else if (this.runtime.isCordova)
			window.open(url, "_system");
		else if (!this.is_arcade && !this.runtime.isDomFree)
		{
			if (target === 2 && !this.is_arcade)		// top
				window.top.location = url;
			else if (target === 1 && !this.is_arcade)	// parent
				window.parent.location = url;
			else					// self
				window.location = url;
		}
	};
	Acts.prototype.GoToURLWindow = function (url, tag)
	{
		if (this.runtime.isCocoonJs)
			CocoonJS["App"]["openURL"](url);
		else if (this.runtime.isEjecta)
			ejecta["openURL"](url);
		else if (this.runtime.isWinJS)
			Windows["System"]["Launcher"]["launchUriAsync"](new Windows["Foundation"]["Uri"](url));
		else if (navigator["app"] && navigator["app"]["loadUrl"])
			navigator["app"]["loadUrl"](url, { "openExternal": true });
		else if (this.runtime.isCordova)
			window.open(url, "_system");
		else if (!this.is_arcade && !this.runtime.isDomFree)
			window.open(url, tag);
	};
	Acts.prototype.Reload = function ()
	{
		if (!this.is_arcade && !this.runtime.isDomFree)
			window.location.reload();
	};
	var firstRequestFullscreen = true;
	var crruntime = null;
	function onFullscreenError(e)
	{
		if (console && console.warn)
			console.warn("Fullscreen request failed: ", e);
		crruntime["setSize"](window.innerWidth, window.innerHeight);
	};
	Acts.prototype.RequestFullScreen = function (stretchmode)
	{
		if (this.runtime.isDomFree)
		{
			cr.logexport("[Construct 2] Requesting fullscreen is not supported on this platform - the request has been ignored");
			return;
		}
		if (stretchmode >= 2)
			stretchmode += 1;
		if (stretchmode === 6)
			stretchmode = 2;
		if (this.runtime.isNodeWebkit)
		{
			if (this.runtime.isDebug)
			{
				debuggerFullscreen(true);
			}
			else if (!this.runtime.isNodeFullscreen && window["nwgui"])
			{
				window["nwgui"]["Window"]["get"]()["enterFullscreen"]();
				this.runtime.isNodeFullscreen = true;
				this.runtime.fullscreen_scaling = (stretchmode >= 2 ? stretchmode : 0);
			}
		}
		else
		{
			if (document["mozFullScreen"] || document["webkitIsFullScreen"] || !!document["msFullscreenElement"] || document["fullScreen"] || document["fullScreenElement"])
			{
				return;
			}
			this.runtime.fullscreen_scaling = (stretchmode >= 2 ? stretchmode : 0);
			var elem = this.runtime.canvasdiv || this.runtime.canvas;
			if (firstRequestFullscreen)
			{
				firstRequestFullscreen = false;
				crruntime = this.runtime;
				elem.addEventListener("mozfullscreenerror", onFullscreenError);
				elem.addEventListener("webkitfullscreenerror", onFullscreenError);
				elem.addEventListener("MSFullscreenError", onFullscreenError);
				elem.addEventListener("fullscreenerror", onFullscreenError);
			}
			if (elem["requestFullscreen"])
				elem["requestFullscreen"]();
			else if (elem["mozRequestFullScreen"])
				elem["mozRequestFullScreen"]();
			else if (elem["msRequestFullscreen"])
				elem["msRequestFullscreen"]();
			else if (elem["webkitRequestFullScreen"])
			{
				if (typeof Element !== "undefined" && typeof Element["ALLOW_KEYBOARD_INPUT"] !== "undefined")
					elem["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]);
				else
					elem["webkitRequestFullScreen"]();
			}
		}
	};
	Acts.prototype.CancelFullScreen = function ()
	{
		if (this.runtime.isDomFree)
		{
			cr.logexport("[Construct 2] Exiting fullscreen is not supported on this platform - the request has been ignored");
			return;
		}
		if (this.runtime.isNodeWebkit)
		{
			if (this.runtime.isDebug)
			{
				debuggerFullscreen(false);
			}
			else if (this.runtime.isNodeFullscreen && window["nwgui"])
			{
				window["nwgui"]["Window"]["get"]()["leaveFullscreen"]();
				this.runtime.isNodeFullscreen = false;
			}
		}
		else
		{
			if (document["exitFullscreen"])
				document["exitFullscreen"]();
			else if (document["mozCancelFullScreen"])
				document["mozCancelFullScreen"]();
			else if (document["msExitFullscreen"])
				document["msExitFullscreen"]();
			else if (document["webkitCancelFullScreen"])
				document["webkitCancelFullScreen"]();
		}
	};
	Acts.prototype.Vibrate = function (pattern_)
	{
		try {
			var arr = pattern_.split(",");
			var i, len;
			for (i = 0, len = arr.length; i < len; i++)
			{
				arr[i] = parseInt(arr[i], 10);
			}
			if (navigator["vibrate"])
				navigator["vibrate"](arr);
			else if (navigator["mozVibrate"])
				navigator["mozVibrate"](arr);
			else if (navigator["webkitVibrate"])
				navigator["webkitVibrate"](arr);
			else if (navigator["msVibrate"])
				navigator["msVibrate"](arr);
		}
		catch (e) {}
	};
	Acts.prototype.InvokeDownload = function (url_, filename_)
	{
		var a = document.createElement("a");
		if (typeof a["download"] === "undefined")
		{
			window.open(url_);
		}
		else
		{
			var body = document.getElementsByTagName("body")[0];
			a.textContent = filename_;
			a.href = url_;
			a["download"] = filename_;
			body.appendChild(a);
			var clickEvent = new MouseEvent("click");
			a.dispatchEvent(clickEvent);
			body.removeChild(a);
		}
	};
	Acts.prototype.InvokeDownloadString = function (str_, mimetype_, filename_)
	{
		var datauri = "data:" + mimetype_ + "," + encodeURIComponent(str_);
		var a = document.createElement("a");
		if (typeof a["download"] === "undefined")
		{
			window.open(datauri);
		}
		else
		{
			var body = document.getElementsByTagName("body")[0];
			a.textContent = filename_;
			a.href = datauri;
			a["download"] = filename_;
			body.appendChild(a);
			var clickEvent = new MouseEvent("click");
			a.dispatchEvent(clickEvent);
			body.removeChild(a);
		}
	};
	Acts.prototype.ConsoleLog = function (type_, msg_)
	{
		if (typeof console === "undefined")
			return;
		if (type_ === 0 && console.log)
			console.log(msg_.toString());
		if (type_ === 1 && console.warn)
			console.warn(msg_.toString());
		if (type_ === 2 && console.error)
			console.error(msg_.toString());
	};
	Acts.prototype.ConsoleGroup = function (name_)
	{
		if (console && console.group)
			console.group(name_);
	};
	Acts.prototype.ConsoleGroupEnd = function ()
	{
		if (console && console.groupEnd)
			console.groupEnd();
	};
	Acts.prototype.ExecJs = function (js_)
	{
		try {
			if (eval)
				eval(js_);
		}
		catch (e)
		{
			if (console && console.error)
				console.error("Error executing Javascript: ", e);
		}
	};
	var orientations = [
		"portrait",
		"landscape",
		"portrait-primary",
		"portrait-secondary",
		"landscape-primary",
		"landscape-secondary"
	];
	Acts.prototype.LockOrientation = function (o)
	{
		o = Math.floor(o);
		if (o < 0 || o >= orientations.length)
			return;
		this.runtime.autoLockOrientation = false;
		var orientation = orientations[o];
		if (screen["orientation"] && screen["orientation"]["lock"])
			screen["orientation"]["lock"](orientation);
		else if (screen["lockOrientation"])
			screen["lockOrientation"](orientation);
		else if (screen["webkitLockOrientation"])
			screen["webkitLockOrientation"](orientation);
		else if (screen["mozLockOrientation"])
			screen["mozLockOrientation"](orientation);
		else if (screen["msLockOrientation"])
			screen["msLockOrientation"](orientation);
	};
	Acts.prototype.UnlockOrientation = function ()
	{
		this.runtime.autoLockOrientation = false;
		if (screen["orientation"] && screen["orientation"]["unlock"])
			screen["orientation"]["unlock"]();
		else if (screen["unlockOrientation"])
			screen["unlockOrientation"]();
		else if (screen["webkitUnlockOrientation"])
			screen["webkitUnlockOrientation"]();
		else if (screen["mozUnlockOrientation"])
			screen["mozUnlockOrientation"]();
		else if (screen["msUnlockOrientation"])
			screen["msUnlockOrientation"]();
	};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.URL = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : window.location.toString());
	};
	Exps.prototype.Protocol = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : window.location.protocol);
	};
	Exps.prototype.Domain = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : window.location.hostname);
	};
	Exps.prototype.PathName = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : window.location.pathname);
	};
	Exps.prototype.Hash = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : window.location.hash);
	};
	Exps.prototype.Referrer = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : document.referrer);
	};
	Exps.prototype.Title = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : document.title);
	};
	Exps.prototype.Name = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : navigator.appName);
	};
	Exps.prototype.Version = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : navigator.appVersion);
	};
	Exps.prototype.Language = function (ret)
	{
		if (navigator && navigator.language)
			ret.set_string(navigator.language);
		else
			ret.set_string("");
	};
	Exps.prototype.Platform = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : navigator.platform);
	};
	Exps.prototype.Product = function (ret)
	{
		if (navigator && navigator.product)
			ret.set_string(navigator.product);
		else
			ret.set_string("");
	};
	Exps.prototype.Vendor = function (ret)
	{
		if (navigator && navigator.vendor)
			ret.set_string(navigator.vendor);
		else
			ret.set_string("");
	};
	Exps.prototype.UserAgent = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : navigator.userAgent);
	};
	Exps.prototype.QueryString = function (ret)
	{
		ret.set_string(this.runtime.isDomFree ? "" : window.location.search);
	};
	Exps.prototype.QueryParam = function (ret, paramname)
	{
		if (this.runtime.isDomFree)
		{
			ret.set_string("");
			return;
		}
		var match = RegExp('[?&]' + paramname + '=([^&]*)').exec(window.location.search);
		if (match)
			ret.set_string(decodeURIComponent(match[1].replace(/\+/g, ' ')));
		else
			ret.set_string("");
	};
	Exps.prototype.Bandwidth = function (ret)
	{
		var connection = navigator["connection"] || navigator["mozConnection"] || navigator["webkitConnection"];
		if (!connection)
			ret.set_float(Number.POSITIVE_INFINITY);
		else
		{
			if (typeof connection["bandwidth"] !== "undefined")
				ret.set_float(connection["bandwidth"]);
			else if (typeof connection["downlinkMax"] !== "undefined")
				ret.set_float(connection["downlinkMax"]);
			else
				ret.set_float(Number.POSITIVE_INFINITY);
		}
	};
	Exps.prototype.ConnectionType = function (ret)
	{
		var connection = navigator["connection"] || navigator["mozConnection"] || navigator["webkitConnection"];
		if (!connection)
			ret.set_string("unknown");
		else
		{
			ret.set_string(connection["type"] || "unknown");
		}
	};
	Exps.prototype.BatteryLevel = function (ret)
	{
		var battery = navigator["battery"] || navigator["mozBattery"] || navigator["webkitBattery"];
		if (battery)
		{
			ret.set_float(battery["level"]);
		}
		else
		{
			maybeLoadBatteryManager();
			if (batteryManager)
			{
				ret.set_float(batteryManager["level"]);
			}
			else
			{
				ret.set_float(1);		// not supported/unknown: assume charged
			}
		}
	};
	Exps.prototype.BatteryTimeLeft = function (ret)
	{
		var battery = navigator["battery"] || navigator["mozBattery"] || navigator["webkitBattery"];
		if (battery)
		{
			ret.set_float(battery["dischargingTime"]);
		}
		else
		{
			maybeLoadBatteryManager();
			if (batteryManager)
			{
				ret.set_float(batteryManager["dischargingTime"]);
			}
			else
			{
				ret.set_float(Number.POSITIVE_INFINITY);		// not supported/unknown: assume infinite time left
			}
		}
	};
	Exps.prototype.ExecJS = function (ret, js_)
	{
		if (!eval)
		{
			ret.set_any(0);
			return;
		}
		var result = 0;
		try {
			result = eval(js_);
		}
		catch (e)
		{
			if (console && console.error)
				console.error("Error executing Javascript: ", e);
		}
		if (typeof result === "number")
			ret.set_any(result);
		else if (typeof result === "string")
			ret.set_any(result);
		else if (typeof result === "boolean")
			ret.set_any(result ? 1 : 0);
		else
			ret.set_any(0);
	};
	Exps.prototype.ScreenWidth = function (ret)
	{
		ret.set_int(screen.width);
	};
	Exps.prototype.ScreenHeight = function (ret)
	{
		ret.set_int(screen.height);
	};
	Exps.prototype.DevicePixelRatio = function (ret)
	{
		ret.set_float(this.runtime.devicePixelRatio);
	};
	Exps.prototype.WindowInnerWidth = function (ret)
	{
		ret.set_int(window.innerWidth);
	};
	Exps.prototype.WindowInnerHeight = function (ret)
	{
		ret.set_int(window.innerHeight);
	};
	Exps.prototype.WindowOuterWidth = function (ret)
	{
		ret.set_int(window.outerWidth);
	};
	Exps.prototype.WindowOuterHeight = function (ret)
	{
		ret.set_int(window.outerHeight);
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.plugins_.Function = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Function.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
	};
	var instanceProto = pluginProto.Instance.prototype;
	var funcStack = [];
	var funcStackPtr = -1;
	var isInPreview = false;	// set in onCreate
	function FuncStackEntry()
	{
		this.name = "";
		this.retVal = 0;
		this.params = [];
	};
	function pushFuncStack()
	{
		funcStackPtr++;
		if (funcStackPtr === funcStack.length)
			funcStack.push(new FuncStackEntry());
		return funcStack[funcStackPtr];
	};
	function getCurrentFuncStack()
	{
		if (funcStackPtr < 0)
			return null;
		return funcStack[funcStackPtr];
	};
	function getOneAboveFuncStack()
	{
		if (!funcStack.length)
			return null;
		var i = funcStackPtr + 1;
		if (i >= funcStack.length)
			i = funcStack.length - 1;
		return funcStack[i];
	};
	function popFuncStack()
	{
;
		funcStackPtr--;
	};
	instanceProto.onCreate = function()
	{
		isInPreview = (typeof cr_is_preview !== "undefined");
		var self = this;
		window["c2_callFunction"] = function (name_, params_)
		{
			var i, len, v;
			var fs = pushFuncStack();
			fs.name = name_.toLowerCase();
			fs.retVal = 0;
			if (params_)
			{
				fs.params.length = params_.length;
				for (i = 0, len = params_.length; i < len; ++i)
				{
					v = params_[i];
					if (typeof v === "number" || typeof v === "string")
						fs.params[i] = v;
					else if (typeof v === "boolean")
						fs.params[i] = (v ? 1 : 0);
					else
						fs.params[i] = 0;
				}
			}
			else
			{
				cr.clearArray(fs.params);
			}
			self.runtime.trigger(cr.plugins_.Function.prototype.cnds.OnFunction, self, fs.name);
			popFuncStack();
			return fs.retVal;
		};
	};
	function Cnds() {};
	Cnds.prototype.OnFunction = function (name_)
	{
		var fs = getCurrentFuncStack();
		if (!fs)
			return false;
		return cr.equals_nocase(name_, fs.name);
	};
	Cnds.prototype.CompareParam = function (index_, cmp_, value_)
	{
		var fs = getCurrentFuncStack();
		if (!fs)
			return false;
		index_ = cr.floor(index_);
		if (index_ < 0 || index_ >= fs.params.length)
			return false;
		return cr.do_cmp(fs.params[index_], cmp_, value_);
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.CallFunction = function (name_, params_)
	{
		var fs = pushFuncStack();
		fs.name = name_.toLowerCase();
		fs.retVal = 0;
		cr.shallowAssignArray(fs.params, params_);
		var ran = this.runtime.trigger(cr.plugins_.Function.prototype.cnds.OnFunction, this, fs.name);
		if (isInPreview && !ran)
		{
;
		}
		popFuncStack();
	};
	Acts.prototype.SetReturnValue = function (value_)
	{
		var fs = getCurrentFuncStack();
		if (fs)
			fs.retVal = value_;
		else
;
	};
	Acts.prototype.CallExpression = function (unused)
	{
	};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.ReturnValue = function (ret)
	{
		var fs = getOneAboveFuncStack();
		if (fs)
			ret.set_any(fs.retVal);
		else
			ret.set_int(0);
	};
	Exps.prototype.ParamCount = function (ret)
	{
		var fs = getCurrentFuncStack();
		if (fs)
			ret.set_int(fs.params.length);
		else
		{
;
			ret.set_int(0);
		}
	};
	Exps.prototype.Param = function (ret, index_)
	{
		index_ = cr.floor(index_);
		var fs = getCurrentFuncStack();
		if (fs)
		{
			if (index_ >= 0 && index_ < fs.params.length)
			{
				ret.set_any(fs.params[index_]);
			}
			else
			{
;
				ret.set_int(0);
			}
		}
		else
		{
;
			ret.set_int(0);
		}
	};
	Exps.prototype.Call = function (ret, name_)
	{
		var fs = pushFuncStack();
		fs.name = name_.toLowerCase();
		fs.retVal = 0;
		cr.clearArray(fs.params);
		var i, len;
		for (i = 2, len = arguments.length; i < len; i++)
			fs.params.push(arguments[i]);
		var ran = this.runtime.trigger(cr.plugins_.Function.prototype.cnds.OnFunction, this, fs.name);
		if (isInPreview && !ran)
		{
;
		}
		popFuncStack();
		ret.set_any(fs.retVal);
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.plugins_.Keyboard = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Keyboard.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
		this.keyMap = new Array(256);	// stores key up/down state
		this.usedKeys = new Array(256);
		this.triggerKey = 0;
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onCreate = function()
	{
		var self = this;
		if (!this.runtime.isDomFree)
		{
			jQuery(document).keydown(
				function(info) {
					self.onKeyDown(info);
				}
			);
			jQuery(document).keyup(
				function(info) {
					self.onKeyUp(info);
				}
			);
		}
	};
	var keysToBlockWhenFramed = [32, 33, 34, 35, 36, 37, 38, 39, 40, 44];
	instanceProto.onKeyDown = function (info)
	{
		var alreadyPreventedDefault = false;
		if (window != window.top && keysToBlockWhenFramed.indexOf(info.which) > -1)
		{
			info.preventDefault();
			alreadyPreventedDefault = true;
			info.stopPropagation();
		}
		if (this.keyMap[info.which])
		{
			if (this.usedKeys[info.which] && !alreadyPreventedDefault)
				info.preventDefault();
			return;
		}
		this.keyMap[info.which] = true;
		this.triggerKey = info.which;
		this.runtime.isInUserInputEvent = true;
		this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnAnyKey, this);
		var eventRan = this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKey, this);
		var eventRan2 = this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKeyCode, this);
		this.runtime.isInUserInputEvent = false;
		if (eventRan || eventRan2)
		{
			this.usedKeys[info.which] = true;
			if (!alreadyPreventedDefault)
				info.preventDefault();
		}
	};
	instanceProto.onKeyUp = function (info)
	{
		this.keyMap[info.which] = false;
		this.triggerKey = info.which;
		this.runtime.isInUserInputEvent = true;
		this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnAnyKeyReleased, this);
		var eventRan = this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKeyReleased, this);
		var eventRan2 = this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKeyCodeReleased, this);
		this.runtime.isInUserInputEvent = false;
		if (eventRan || eventRan2 || this.usedKeys[info.which])
		{
			this.usedKeys[info.which] = true;
			info.preventDefault();
		}
	};
	instanceProto.onWindowBlur = function ()
	{
		var i;
		for (i = 0; i < 256; ++i)
		{
			if (!this.keyMap[i])
				continue;		// key already up
			this.keyMap[i] = false;
			this.triggerKey = i;
			this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnAnyKeyReleased, this);
			var eventRan = this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKeyReleased, this);
			var eventRan2 = this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKeyCodeReleased, this);
			if (eventRan || eventRan2)
				this.usedKeys[i] = true;
		}
	};
	instanceProto.saveToJSON = function ()
	{
		return { "triggerKey": this.triggerKey };
	};
	instanceProto.loadFromJSON = function (o)
	{
		this.triggerKey = o["triggerKey"];
	};
	function Cnds() {};
	Cnds.prototype.IsKeyDown = function(key)
	{
		return this.keyMap[key];
	};
	Cnds.prototype.OnKey = function(key)
	{
		return (key === this.triggerKey);
	};
	Cnds.prototype.OnAnyKey = function(key)
	{
		return true;
	};
	Cnds.prototype.OnAnyKeyReleased = function(key)
	{
		return true;
	};
	Cnds.prototype.OnKeyReleased = function(key)
	{
		return (key === this.triggerKey);
	};
	Cnds.prototype.IsKeyCodeDown = function(key)
	{
		key = Math.floor(key);
		if (key < 0 || key >= this.keyMap.length)
			return false;
		return this.keyMap[key];
	};
	Cnds.prototype.OnKeyCode = function(key)
	{
		return (key === this.triggerKey);
	};
	Cnds.prototype.OnKeyCodeReleased = function(key)
	{
		return (key === this.triggerKey);
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.LastKeyCode = function (ret)
	{
		ret.set_int(this.triggerKey);
	};
	function fixedStringFromCharCode(kc)
	{
		kc = Math.floor(kc);
		switch (kc) {
		case 8:		return "backspace";
		case 9:		return "tab";
		case 13:	return "enter";
		case 16:	return "shift";
		case 17:	return "control";
		case 18:	return "alt";
		case 19:	return "pause";
		case 20:	return "capslock";
		case 27:	return "esc";
		case 33:	return "pageup";
		case 34:	return "pagedown";
		case 35:	return "end";
		case 36:	return "home";
		case 37:	return "←";
		case 38:	return "↑";
		case 39:	return "→";
		case 40:	return "↓";
		case 45:	return "insert";
		case 46:	return "del";
		case 91:	return "left window key";
		case 92:	return "right window key";
		case 93:	return "select";
		case 96:	return "numpad 0";
		case 97:	return "numpad 1";
		case 98:	return "numpad 2";
		case 99:	return "numpad 3";
		case 100:	return "numpad 4";
		case 101:	return "numpad 5";
		case 102:	return "numpad 6";
		case 103:	return "numpad 7";
		case 104:	return "numpad 8";
		case 105:	return "numpad 9";
		case 106:	return "numpad *";
		case 107:	return "numpad +";
		case 109:	return "numpad -";
		case 110:	return "numpad .";
		case 111:	return "numpad /";
		case 112:	return "F1";
		case 113:	return "F2";
		case 114:	return "F3";
		case 115:	return "F4";
		case 116:	return "F5";
		case 117:	return "F6";
		case 118:	return "F7";
		case 119:	return "F8";
		case 120:	return "F9";
		case 121:	return "F10";
		case 122:	return "F11";
		case 123:	return "F12";
		case 144:	return "numlock";
		case 145:	return "scroll lock";
		case 186:	return ";";
		case 187:	return "=";
		case 188:	return ",";
		case 189:	return "-";
		case 190:	return ".";
		case 191:	return "/";
		case 192:	return "'";
		case 219:	return "[";
		case 220:	return "\\";
		case 221:	return "]";
		case 222:	return "#";
		case 223:	return "`";
		default:	return String.fromCharCode(kc);
		}
	};
	Exps.prototype.StringFromKeyCode = function (ret, kc)
	{
		ret.set_string(fixedStringFromCharCode(kc));
	};
	pluginProto.exps = new Exps();
}());
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
},{}],2:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jade = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */
exports.merge = function merge(a, b) {
  if (arguments.length === 1) {
    var attrs = a[0];
    for (var i = 1; i < a.length; i++) {
      attrs = merge(attrs, a[i]);
    }
    return attrs;
  }
  var ac = a['class'];
  var bc = b['class'];
  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    a['class'] = ac.concat(bc).filter(nulls);
  }
  for (var key in b) {
    if (key != 'class') {
      a[key] = b[key];
    }
  }
  return a;
};
/**
 * Filter null `val`s.
 *
 * @param {*} val
 * @return {Boolean}
 * @api private
 */
function nulls(val) {
  return val != null && val !== '';
}
/**
 * join array as classes.
 *
 * @param {*} val
 * @return {String}
 */
exports.joinClasses = joinClasses;
function joinClasses(val) {
  return (Array.isArray(val) ? val.map(joinClasses) :
    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
    [val]).filter(nulls).join(' ');
}
/**
 * Render the given classes.
 *
 * @param {Array} classes
 * @param {Array.<Boolean>} escaped
 * @return {String}
 */
exports.cls = function cls(classes, escaped) {
  var buf = [];
  for (var i = 0; i < classes.length; i++) {
    if (escaped && escaped[i]) {
      buf.push(exports.escape(joinClasses([classes[i]])));
    } else {
      buf.push(joinClasses(classes[i]));
    }
  }
  var text = joinClasses(buf);
  if (text.length) {
    return ' class="' + text + '"';
  } else {
    return '';
  }
};
exports.style = function (val) {
  if (val && typeof val === 'object') {
    return Object.keys(val).map(function (style) {
      return style + ':' + val[style];
    }).join(';');
  } else {
    return val;
  }
};
/**
 * Render the given attribute.
 *
 * @param {String} key
 * @param {String} val
 * @param {Boolean} escaped
 * @param {Boolean} terse
 * @return {String}
 */
exports.attr = function attr(key, val, escaped, terse) {
  if (key === 'style') {
    val = exports.style(val);
  }
  if ('boolean' == typeof val || null == val) {
    if (val) {
      return ' ' + (terse ? key : key + '="' + key + '"');
    } else {
      return '';
    }
  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
    if (JSON.stringify(val).indexOf('&') !== -1) {
      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
                   'will be escaped to `&amp;`');
    };
    if (val && typeof val.toISOString === 'function') {
      console.warn('Jade will eliminate the double quotes around dates in ' +
                   'ISO form after 2.0.0');
    }
    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
  } else if (escaped) {
    if (val && typeof val.toISOString === 'function') {
      console.warn('Jade will stringify dates in ISO form after 2.0.0');
    }
    return ' ' + key + '="' + exports.escape(val) + '"';
  } else {
    if (val && typeof val.toISOString === 'function') {
      console.warn('Jade will stringify dates in ISO form after 2.0.0');
    }
    return ' ' + key + '="' + val + '"';
  }
};
/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 */
exports.attrs = function attrs(obj, terse){
  var buf = [];
  var keys = Object.keys(obj);
  if (keys.length) {
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i]
        , val = obj[key];
      if ('class' == key) {
        if (val = joinClasses(val)) {
          buf.push(' ' + key + '="' + val + '"');
        }
      } else {
        buf.push(exports.attr(key, val, false, terse));
      }
    }
  }
  return buf.join('');
};
/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */
var jade_encode_html_rules = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};
var jade_match_html = /[&<>"]/g;
function jade_encode_char(c) {
  return jade_encode_html_rules[c] || c;
}
exports.escape = jade_escape;
function jade_escape(html){
  var result = String(html).replace(jade_match_html, jade_encode_char);
  if (result === '' + html) return html;
  else return result;
};
/**
 * Re-throw the given `err` in context to the
 * the jade in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */
exports.rethrow = function rethrow(err, filename, lineno, str){
  if (!(err instanceof Error)) throw err;
  if ((typeof window != 'undefined' || !filename) && !str) {
    err.message += ' on line ' + lineno;
    throw err;
  }
  try {
    str = str || require('fs').readFileSync(filename, 'utf8')
  } catch (ex) {
    rethrow(err, null, lineno)
  }
  var context = 3
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? '  > ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
    + '\n' + context + '\n\n' + err.message;
  throw err;
};
exports.DebugItem = function DebugItem(lineno, filename) {
  this.lineno = lineno;
  this.filename = filename;
}
},{"fs":2}],2:[function(require,module,exports){
},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"fs":1}],3:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}
	return Object(val);
}
module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;
	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);
		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}
		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}
	return to;
};
},{}],4:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/19.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _coreHookManager = require("./core/HookManager");
var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
var _coreUIManager = require("./core/UIManager");
var _coreUIManager2 = _interopRequireDefault(_coreUIManager);
var Action = (function () {
    function Action() {
        _classCallCheck(this, Action);
    }
    _createClass(Action, [{
        key: "executedHook",
        /**
         * 执行勾籽
         * @param name
         * @param param
         */
        value: function executedHook(name, param) {
            var evalparam = 0;
            try {
                evalparam = eval(param);
            } catch (e) {
                console.warn("excutedhook fail", name, param);
                return;
            }
            if (!Array.isArray(evalparam)) {
                evalparam = [evalparam];
            }
            if (Array.isArray(evalparam)) {
                _coreHookManager2["default"].excuteHook(name, evalparam);
            }
        }
    }, {
        key: "showCurtainMask",
        value: function showCurtainMask(img, bg, alpha) {
            _coreUIManager2["default"].addCommonToView("commask1");
            if (typeof img === "string") {
                _coreUIManager2["default"].getACommon("commask1").active({ picture: img, background: bg, opacity: alpha });
            }
        }
    }, {
        key: "hideCurtainMask",
        value: function hideCurtainMask() {
            _coreUIManager2["default"].removeCommonFromView("commask1");
        }
        /**
         * 游戏结束
         * @param score
         */
    }, {
        key: "gameOverPanel",
        value: function gameOverPanel(score) {
            _coreUIManager2["default"].enterGameOverState({ score: score });
        }
        /**
         * 游戏结束(星星)
         * @param score
         */
    }, {
        key: "gameOverPanelStar",
        value: function gameOverPanelStar(star, buttonState) {
            _coreUIManager2["default"].enterGameOverStateStar({ star: star, buttonState: buttonState });
        }
    }]);
    return Action;
})();
exports["default"] = Action;
module.exports = exports["default"];
},{"./core/HookManager":9,"./core/UIManager":10}],5:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/19.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _coreConfigureManager = require("./core/ConfigureManager");
var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
var _coreHookManager = require("./core/HookManager");
var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
var _thatConditions;
var Conditions = (function () {
    function Conditions() {
        _classCallCheck(this, Conditions);
        _thatConditions = this;
    }
    _createClass(Conditions, [{
        key: "activeListeners",
        value: function activeListeners(runtime, thisObject) {
            var _this = this;
            _coreHookManager2["default"].addListener(_coreHookManager2["default"].HookExcute, function (hook) {
                if (hook === "noop") return;
                _this.tmphook = hook;
                runtime.trigger(_this.onCbHook, thisObject);
                _this.tmphook = "noop";
                if (["$home", "$pause", "$resume"].indexOf(hook) >= 0) {
                    if (hook === "$pause") {
                        _coreConfigureManager2["default"].getConfig().gameData.pauseState = true;
                    } else if (hook === "$resume") {
                        _coreConfigureManager2["default"].getConfig().gameData.pauseState = false;
                    }
                    _coreHookManager2["default"].emit(hook);
                }
            }, this, -10);
            _coreHookManager2["default"].addListener("$home", function () {
                runtime.trigger(_this.onHome, thisObject);
            });
            _coreHookManager2["default"].addListener("$pause", function () {
                runtime.trigger(_this.onPause, thisObject);
            });
            _coreHookManager2["default"].addListener("$resume", function () {
                runtime.trigger(_this.onResume, thisObject);
            });
            this.orientHoz = false;
            this.doOrientationChange = function () {
                if (window.innerWidth > window.innerHeight) {
                    if (!_this.orientHoz) {
                        _this.orientHoz = true;
                        _coreHookManager2["default"].excuteHook("onorienthoz");
                    }
                    runtime.trigger(_this.onOrientationHoriz, thisObject);
                } else {
                    if (_this.orientHoz) {
                        _this.orientHoz = false;
                        _coreHookManager2["default"].excuteHook("onorientvert");
                    }
                    runtime.trigger(_this.onOrientationVert, thisObject);
                }
                window.removeEventListener("resize", _this.doOrientationChange, false);
                setTimeout(function () {
                    window.addEventListener("resize", _this.doOrientationChange, false);
                }, 200);
            };
            _coreHookManager2["default"].once(_coreHookManager2["default"].HookExcute + ":ready", function () {
                _this.doOrientationChange();
            });
        }
    }, {
        key: "onOrientationHoriz",
        value: function onOrientationHoriz() {
            return true;
        }
    }, {
        key: "onOrientationVert",
        value: function onOrientationVert() {
            return true;
        }
    }, {
        key: "onRelive",
        value: function onRelive() {
            return true;
        }
    }, {
        key: "onHome",
        value: function onHome() {
            return true;
        }
    }, {
        key: "onPause",
        value: function onPause() {
            return true;
        }
    }, {
        key: "onResume",
        value: function onResume() {
            return true;
        }
    }, {
        key: "onCbHook",
        value: function onCbHook(hookname) {
            return _thatConditions.tmphook === hookname;
        }
    }]);
    return Conditions;
})();
exports["default"] = Conditions;
module.exports = exports["default"];
},{"./core/ConfigureManager":8,"./core/HookManager":9}],6:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/20.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _resHook = require("./res/hook");
var hook = _interopRequireWildcard(_resHook);
var _coreConfigureManager = require("./core/ConfigureManager");
var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
var Expressions = (function () {
    function Expressions() {
        _classCallCheck(this, Expressions);
        for (var hookdef in hook.HookDefaultTypeDef) {
            defAExpression(this, "Hook_" + hookdef, hookdef.toLowerCase());
        }
    }
    _createClass(Expressions, [{
        key: "highScore",
        value: function highScore() {
            ret["set_number"](_coreConfigureManager2["default"].getConfig().gameData.gameHighScore);
        }
    }, {
        key: "pauseState",
        value: function pauseState() {
            ret["set_number"](_coreConfigureManager2["default"].getConfig().gameData.pauseState ? 1 : 0);
        }
    }]);
    return Expressions;
})();
function defAExpression(that, name, value) {
    var type = arguments.length <= 3 || arguments[3] === undefined ? "string" : arguments[3];
    that[name] = function (ret) {
        ret["set_" + type](value);
    };
}
exports["default"] = Expressions;
module.exports = exports["default"];
},{"./core/ConfigureManager":8,"./res/hook":12}],7:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/19.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var _Action = require("./Action");
var _Action2 = _interopRequireDefault(_Action);
var _Conditions = require("./Conditions");
var _Conditions2 = _interopRequireDefault(_Conditions);
var _Expressions = require("./Expressions");
var _Expressions2 = _interopRequireDefault(_Expressions);
var _coreConfigureManager = require("./core/ConfigureManager");
var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
var Plugin = function Plugin(runtime) {
    this.runtime = runtime;
};
var pluginProto = Plugin.prototype;
pluginProto.Type = function (plugin) {
    this.plugin = plugin;
    this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function () {};
pluginProto.Instance = function (type) {
    this.type = type;
    this.runtime = type.runtime;
    Plugin.prototype.cnds.activeListeners(this.runtime, this);
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function () {
};
instanceProto.draw = function (ctx) {};
instanceProto.drawGL = function (glw) {};
Plugin.prototype.acts = new _Action2["default"]();
Plugin.prototype.cnds = new _Conditions2["default"]();
Plugin.prototype.exps = new _Expressions2["default"]();
exports["default"] = Plugin;
module.exports = exports["default"];
},{"./Action":4,"./Conditions":5,"./Expressions":6,"./core/ConfigureManager":8}],8:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/21.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var _HookManager = require("./HookManager");
var _HookManager2 = _interopRequireDefault(_HookManager);
var _UIManager = require("./UIManager");
var _UIManager2 = _interopRequireDefault(_UIManager);
var _libEventEmitter = require("./../lib/EventEmitter");
var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
var _uiComBase = require("./../ui/ComBase");
var _uiComBase2 = _interopRequireDefault(_uiComBase);
var _uiComComOverPanel = require("./../ui/com/ComOverPanel");
var _uiComComOverPanel2 = _interopRequireDefault(_uiComComOverPanel);
var objectAssign = require('object-assign');
var configObj = {
    gameData: {
        permitStart: 1,
        buttonLayout: ["restart"],
        pauseState: false,
        skin: {
            OverPanelMainIcon: ""
        }
    }, //TODO:可以用来实现自定义图片资源（如二维码之类的），需要到相应组件修改相关代码。
    tvData: {
        showAdvertising: true
    },
    hook: _HookManager2["default"].hookInterface, //钩子
    "interface": {
        home: function home() {
            ConfigureManager.excuteHook("$home");
        },
        pause: function pause() {
            ConfigureManager.excuteHook("$pause");
        },
        resume: function resume() {
            ConfigureManager.excuteHook("$resume");
        },
        updatePermitStart: function updatePermitStart(value) {
            configObj.gameData.permitStart = value;
        }
    }
};
var ConfigureManager = (function () {
    function ConfigureManager() {
        _classCallCheck(this, ConfigureManager);
    }
    /**
     * 保持和egret公共组件接口的一样
     */
    _createClass(ConfigureManager, null, [{
        key: "excuteInterface",
        value: function excuteInterface(name, parms) {
            if (typeof configObj["interface"][name] === "function") {
                configObj["interface"][name]();
            }
        }
        /**
         * @param name
         * @param parms
         */
    }, {
        key: "excuteHook",
        value: function excuteHook(name, parms) {
            _HookManager2["default"].excuteHook(name, parms);
        }
    }, {
        key: "addCbHookListen",
        value: function addCbHookListen(name, cb) {
            _HookManager2["default"].addListener(_HookManager2["default"].HookExcute + ":" + name, cb);
        }
    }, {
        key: "onceCbHookListen",
        value: function onceCbHookListen(name, cb) {
            _HookManager2["default"].once(_HookManager2["default"].HookExcute + ":" + name, cb);
        }
    }, {
        key: "removeCbHookListen",
        value: function removeCbHookListen(name, cb) {
            _HookManager2["default"].removeListener(_HookManager2["default"].HookExcute + ":" + name, cb);
        }
    }, {
        key: "config",
        set: function set(config) {
            for (var item in config) {
                if (typeof configObj[item] === "undefined" || typeof configObj[item] === "boolean" || typeof configObj[item] === "number" || typeof configObj[item] === "string" || Array.isArray(configObj[item])) {
                    configObj[item] = config[item];
                } else {
                    objectAssign(configObj[item], config[item]);
                }
            }
        }
    }, {
        key: "?config",
        get: function get() {
            return configObj;
        }
    }, {
        key: "instance",
        get: function get() {
            return {
                config_common: function config_common(_gamedata, _cb_hooks) {
                    var gamedata = _gamedata;
                    var cb_hooks = _cb_hooks;
                    if (!gamedata) gamedata = {};
                    if (!cb_hooks) cb_hooks = {};
                    for (var i in cb_hooks) {
                        if (!configObj.hook) configObj.hook = {};
                        if (typeof cb_hooks[i] === "function") {
                            configObj.hook[i] = cb_hooks[i];
                        }
                    }
                    configObj.gameData.gameName = gamedata.name;
                    configObj.gameData.permitStart = gamedata.permitStart || 1;
                    configObj.gameData.buttonLayout = Array.isArray(gamedata.buttonLayout) ? gamedata.buttonLayout : ["restart"];
                    return configObj["interface"];
                }
            };
        }
    }]);
    return ConfigureManager;
})();
var imageRes = require("../res/resource").imageRes;
window["meiriq"] = {
    CommonComponent: ConfigureManager,
    lib: {
        UIManager: _UIManager2["default"],
        HookManager: _HookManager2["default"],
        EventEmitter: _libEventEmitter2["default"],
        ComBase: _uiComBase2["default"],
        ComOverPanel: _uiComComOverPanel2["default"],
        defaultImageRes: imageRes
    },
    onReady: function onReady(fn) {
        fn();
    }
};
var c2runtime;
var c2thisObject;
exports["default"] = {
    getConfig: function getConfig() {
        return ConfigureManager["?config"];
    }
};
module.exports = exports["default"];
},{"../res/resource":13,"./../lib/EventEmitter":11,"./../ui/ComBase":14,"./../ui/com/ComOverPanel":17,"./HookManager":9,"./UIManager":10,"object-assign":3}],9:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/20.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _libEventEmitter = require("../lib/EventEmitter");
var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
var _resHookJs = require("../res/hook.js");
var hook = _interopRequireWildcard(_resHookJs);
var HookManager = (function (_EventEmitter) {
    _inherits(HookManager, _EventEmitter);
    function HookManager() {
        _classCallCheck(this, HookManager);
        _get(Object.getPrototypeOf(HookManager.prototype), "constructor", this).call(this);
        this.HookExcute = "HookExcute";
        this.hookInterface = {};
        for (var hookdef in hook.HookDefaultTypeDef) {
            this.hookInterface["cb_" + hook.HookDefaultTypeDef[hookdef]] = function () {};
        }
        this.hookInterface["cb_debug"] = function () {
            console.log(arguments);
        };
    }
    _createClass(HookManager, [{
        key: "excuteHook",
        value: function excuteHook(name) {
            var params = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
            var cb = arguments.length <= 2 || arguments[2] === undefined ? function () {} : arguments[2];
            var nametolower = name.toLowerCase();
            name = nametolower;
            var gameData = window["meiriq"].CommonComponent["?config"].gameData;
            if (name === "start" || name === "restart") {
                if (!gameData.permitStart) {
                    return;
                }
            }
            var self;
            switch (name) {
                case "start":
                    {
                        self = gameData;
                        if (!self.gameName && typeof params[0] === "string") {
                            self.gameName = params[0];
                        } else {
                            break;
                        }
                        if (!window.localStorage.getItem(self.gameName + "Score")) {
                            self.gameHighScore = 0; // 根据游戏实际情况决定
                        } else {
                                self.gameHighScore = Number(window.localStorage.getItem(self.gameName + "Score"));
                            }
                        break;
                    }
                case "gameover":
                    {
                        if (window["MomoFun_changeShareWord"])window["MomoFun_changeShareWord"](params[0] + "");
                        self = gameData;
                        var score = params[0];
                        if (self.gameName) {
                            if (score > self.gameHighScore || !self.gameHighScore) {
                                window.localStorage.setItem(self.gameName + "Score", params[0] + "");
                                self.gameHighScore = params[0];
                            } else if (!self.gameHighScore) {
                                self.gameHighScore = window.localStorage.getItem(self.gameName + "Score");
                            }
                        } else {
                            self.gameHighScore = 0;
                        }
                        break;
                    }
            }
            if (nametolower === "noop") return;
            this.emit.apply(this, [this.HookExcute, nametolower].concat(params));
            this.emit.apply(this, [this.HookExcute + ":" + nametolower].concat(params));
            var result = true;
            if (typeof this.hookInterface["cb_" + nametolower] === "function") {
                result = this.hookInterface["cb_" + nametolower].apply(null, params);
            }
            if (typeof cb === "function") {
                cb(result);
            }
        }
    }]);
    return HookManager;
})(_libEventEmitter2["default"]);
exports["default"] = new HookManager();
module.exports = exports["default"];
},{"../lib/EventEmitter":11,"../res/hook.js":12}],10:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/21.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _resHookJs = require("../res/hook.js");
var hook = _interopRequireWildcard(_resHookJs);
var _HookManager = require("./HookManager");
var _HookManager2 = _interopRequireDefault(_HookManager);
var _uiComBase = require("../ui/ComBase");
var _uiComBase2 = _interopRequireDefault(_uiComBase);
var _uiComComOverPanel = require("../ui/com/ComOverPanel");
var _uiComComOverPanel2 = _interopRequireDefault(_uiComComOverPanel);
var _uiComComOverPanelStar = require("../ui/com/ComOverPanelStar");
var _uiComComOverPanelStar2 = _interopRequireDefault(_uiComComOverPanelStar);
var _uiComComMask = require("../ui/com/ComMask");
var _uiComComMask2 = _interopRequireDefault(_uiComComMask);
var _libEventEmitter = require("../lib/EventEmitter");
var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
var uistyle = "\n<style rel=\"stylesheet\" scoped=\"scoped\">\n   #MeiriqGameUI *{\n        -webkit-user-select: none;\n        font-family: Microsoft YaHei ,SimHei;\n   }\n</style>\n";
var UIManager = (function (_EventEmitter) {
    _inherits(UIManager, _EventEmitter);
    function UIManager() {
        var _this = this;
        _classCallCheck(this, UIManager);
        _get(Object.getPrototypeOf(UIManager.prototype), "constructor", this).call(this);
        this.root = _uiComBase2["default"].str2dom(function () {
            return "\n                <div style=\"position: fixed;left:0;right:0;top:0;\" meiriqcom=\"root\" id=\"MeiriqGameUI\">\n                   " + uistyle + "\n                </div>\n            ";
        }).children[0];
        document.addEventListener("DOMContentLoaded", function () {
            document.body.appendChild(_this.root);
            _this.emit("domready");
        });
        this.commonsRepository = {
            identity: new _uiComBase2["default"]("")
        };
        _HookManager2["default"].addListener(_HookManager2["default"].HookExcute, function (hook) {
            if (hook === "restart" || hook === "relive" || hook === "levelnext" || hook === "rechallenge") {
                _this.removeCommonFromView(_uiComComOverPanel2["default"].name);
                _this.removeCommonFromView(_uiComComOverPanelStar2["default"].name);
            }
        });
        this.registerACommon(_uiComComOverPanel2["default"].name, _uiComComOverPanel2["default"]);
        this.registerACommon(_uiComComOverPanelStar2["default"].name, _uiComComOverPanelStar2["default"]);
        this.registerACommon(_uiComComMask2["default"].name, _uiComComMask2["default"]);
    }
    _createClass(UIManager, [{
        key: "registerACommon",
        value: function registerACommon(name, common) {
            if (common instanceof _uiComBase2["default"] && !this.commonsRepository[name]) {
                this.commonsRepository[name] = common;
            }
        }
    }, {
        key: "getACommon",
        value: function getACommon(name) {
            return this.commonsRepository[name] ? this.commonsRepository[name] : this.commonsRepository.identity;
        }
    }, {
        key: "clearView",
        value: function clearView() {
            this.root.innerHTML = "" + uistyle;
            this.emit("clear");
        }
    }, {
        key: "addCommonToView",
        value: function addCommonToView(name) {
            var _this2 = this;
            if (this.commonsRepository[name] && name !== "identity") {
                this.root.appendChild(this.commonsRepository[name].content);
                setTimeout(function () {
                    _this2.commonsRepository[name].isMounted = true;
                    _this2.commonsRepository[name].didMount();
                }, 100);
            } else {
                console.log("com", name, "not found!");
            }
        }
    }, {
        key: "removeCommonFromView",
        value: function removeCommonFromView(name) {
            var _this3 = this;
            if (this.commonsRepository[name] && name !== "identity") {
                if (this.commonsRepository[name].content.parentNode === this.root) {
                    this.root.removeChild(this.commonsRepository[name].content);
                    setTimeout(function () {
                        _this3.commonsRepository[name].isMounted = false;
                        _this3.commonsRepository[name].didUnMount();
                    }, 100);
                }
            }
        }
        /**
         * 结束界面
         * @param data
         */
    }, {
        key: "enterGameOverState",
        value: function enterGameOverState() {
            var data = arguments.length <= 0 || arguments[0] === undefined ? { score: 0 } : arguments[0];
            var overPanel = this.getACommon("overpanel");
            var shouldShow = true;
            data.cb = function (result) {
                shouldShow = result !== 0;
            };
            overPanel.active(data);
            if (shouldShow) {
                this.addCommonToView("overpanel");
            }
        }
        /**
         * 结束界面
         * @param data
         */
    }, {
        key: "enterGameOverStateStar",
        value: function enterGameOverStateStar() {
            var data = arguments.length <= 0 || arguments[0] === undefined ? { star: 0 } : arguments[0];
            var overPanel = this.getACommon("overpanelstar");
            var shouldShow = true;
            data.cb = function (result) {
                shouldShow = result !== 0;
            };
            overPanel.active(data);
            if (shouldShow) {
                this.addCommonToView("overpanelstar");
            }
        }
    }]);
    return UIManager;
})(_libEventEmitter2["default"]);
var instance = new UIManager();
window["meiriq"].lib.UIManager = instance;
exports["default"] = instance;
module.exports = exports["default"];
},{"../lib/EventEmitter":11,"../res/hook.js":12,"../ui/ComBase":14,"../ui/com/ComMask":16,"../ui/com/ComOverPanel":17,"../ui/com/ComOverPanelStar":18,"./HookManager":9}],11:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/18.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var eventsMap = "__eventsMap__";
var EventEmitter = (function () {
    function EventEmitter() {
        _classCallCheck(this, EventEmitter);
        this[eventsMap] = {};
    }
    _createClass(EventEmitter, [{
        key: "emit",
        /**
         * 派发一个事件
         * @param event
         * @param args
         */
        value: function emit(event) {
            var eventmap = this[eventsMap][event];
            if (Array.isArray(eventmap)) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                notifyable.notifyArray(eventmap, args);
            }
        }
        /**
         * 返回所有回调方法
         * @param event
         * @returns {*}
         */
    }, {
        key: "listeners",
        value: function listeners(event) {
            var result = this[eventsMap][event];
            if (!result) {
                result = [];
                this[eventsMap][event] = result;
            }
            return result.map(function (bin) {
                return bin.callback;
            });
        }
    }, {
        key: "hasListeners",
        value: function hasListeners(event) {
            if (!this[eventsMap][event]) {
                return false;
            }
            return this[eventsMap][event].length > 0;
        }
        /**
         * 添加一只侦听器
         * @param event
         * @param callback
         * @param thisObject
         * @param priority
         */
    }, {
        key: "addListener",
        value: function addListener(event, callback, thisObject, priority) {
            notifyable.registNotify(this[eventsMap], event, callback, thisObject, null, priority);
        }
        /**
         * 移除一只侦听器
         * @param event
         * @param callback
         * @param thisObject
         */
    }, {
        key: "removeListener",
        value: function removeListener(event, callback, thisObject) {
            notifyable.unregistNotify(this[eventsMap], event, callback, thisObject);
        }
        /**
         * 移除所有侦听器
         * @param event
         */
    }, {
        key: "removeAllListener",
        value: function removeAllListener(event) {
            this[eventsMap][event] = [];
        }
        /**
         * 当,简易触发器
         * @param event
         * @param callback
         */
    }, {
        key: "on",
        value: function on(event, callback) {
            notifyable.registNotify(this[eventsMap], event, callback);
        }
        /**
         * 当,唯一触发器
         * @param event
         * @param callback
         */
    }, {
        key: "once",
        value: function once(event, callback) {
            notifyable.registNotify(this[eventsMap], event, callback, null, null, null, true);
        }
    }, {
        key: "eventsmap",
        get: function get() {
            return this[eventsMap];
        }
    }]);
    return EventEmitter;
})();
exports["default"] = EventEmitter;
var notifyable = {
    registNotify: function registNotify(notifymap, name, callback, thisObject, param, priority, once) {
        if (!notifymap[name]) notifymap[name] = [];
        var arr = notifymap[name];
        var length = arr.length;
        var insertIndex = -1;
        var bin;
        if (priority === undefined) priority = 0;
        for (var i = 0; i < length; i++) {
            bin = arr[i];
            if (bin && bin.callback === callback && bin.thisObject === thisObject) {
                return false; //防止重复插入
            }
            if (bin && insertIndex == -1 && bin.priority < priority) {
                insertIndex = i;
            }
        }
        bin = { callback: callback, thisObject: thisObject, param: param ? param : [], priority: priority, once: once };
        if (insertIndex != -1) {
            arr.splice(insertIndex, 0, bin);
        } else {
            arr.push(bin);
        }
        notifymap[name] = arr;
    },
    unregistNotify: function unregistNotify(notifymap, name, callback, thisObject) {
        if (!notifymap[name]) return;
        var arr = notifymap[name];
        if (arr) {
            notifymap[name] = arr.filter(function (bin) {
                return !(bin.callback === callback && bin.thisObject === thisObject);
            });
        }
    },
    notify: function notify(notifymap, name, param) {
        var arr = notifymap[name];
        if (arr) {
            notifyArray(arr, param);
            return true;
        } else {
            return false;
        }
    },
    notifyArray: function notifyArray(arr, param) {
        for (var i in arr) {
            if (typeof +i === "number" && !isNaN(+i)) {
                var bin = arr[i];
                if (bin && bin.callback) {
                    if (!param) param = [];
                    if (bin.param) param = bin.param.concat(param);
                    bin.callback.apply(bin.thisObject, param);
                    if (bin.once) {
                        arr.splice(i, 1);
                    }
                }
            }
        }
    }
};
module.exports = exports["default"];
},{}],12:[function(require,module,exports){
/* Created by tommyZZM on 2015/11/5.*/
/**
 * 流程相关
 **/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var HookDefaultTypeDef = {
    Start: "start",
    Restart: "restart",
    Revive: "Revive",
    GameAddScore: "gameaddscore",
    LevelStart: "levelstart",
    LevelNext: "levelnext",
    GameOver: "gameover",
    TvExitGame: "tvexitgame"
};
exports.HookDefaultTypeDef = HookDefaultTypeDef;
},{}],13:[function(require,module,exports){
/* Created by tommyZZM on 2015/11/5.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var imageRes = {
    replayUp: "data:image/png;base64,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",
    replayDown: "data:image/png;base64,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",
    shareDown: "data:image/png;base64,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",
    shareUp: "data:image/png;base64,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",
    moreDown: "data:image/png;base64,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",
    moreUp: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABWCAYAAAC6uMiMAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAsfSURBVHhe7Z2/iibHFcUHBBsrEngyvYGyFX4HGwzK9AQCgwOBnDhwIiGDYBGO7ES5nkCOHCuRwU/g3JnBf1byMq5TU7d8+n63qqu7q78d7XcO/PTN1N9bt+7pnllrrTtJkiRJ+tHomRBin/LkZ2/dffDpe3fffPXTuwchbhV4AF4wX8Aga7KB72Lydx++8/DvX98/fP/F/cMPXwpxe6D24QF4AZ6AN8gnoazzbTNRtLAQtwqZ6W3yy4WyifAKk4mEiIE3yo95ZqaFzF35bYRXWbSIELcOvNF7K2UTJd7FL1f6nUiIGHgDHoFXimfaRooWEEI80jISvgDoeHwjvUjOE0KEkJEWf4KHf+S3UeJ9GUmIPsVI7xfP1LeSjCTEBmQkISYwbqQv0gQhRIiMJMQEZCQhJiAjCTEBGUmICchIQkxARhJiAsNGevm7eyFEAxlJiAnISEJMQEYSYgIykhATGDfSZ2mCeDJ8/4dfPLz6658e/vvnP4b9Z/DD1x/l/Vp7mhBX2P+Pv2ewTtR/Bhbv2Xl6UkbKf5SYCgSJfvXt5/nwuJRXf/tLvQQG7VZMGI95mI9/Gzda/yhY/5qKYjBwbtO1CjPfA5RyH/WbIiNx7s4uamYtZsRlRP2jvHYjwTw4RC4MGGSGzGTJXC8/e36x5164GK6hKAaj5qpRIGdwxEh1bhIedr7/LHjfbv/BPL42IyGZeDLVgjhRuNijTxwjv/E2wAUf9feI9genG7pRVL7oRu+Oi3lE9sZCDjYpiJvf3NFD9UdrJLyBsoFegx4vaN4baoRZF8VsLcytwvrdfTcaaatmGolr7fJh+vz/Zzh4P1c1Uk7MScnfollvJ1wELgoF1oLPG/UzVkDrPK9vrVlwwbXiQIxZtege4zCh36+7B37YRf0eE+fSWNRb+nrRRxrPfcywkf7z2/tDXPv3izUhcVGco+QLPOGhgB9Fov3Ohs+CQo7G1OJLY7nddEbsyLPtixry/VxX+WGw406O1gK4ipH4qfGUFF3MKPxEw9e4jIh6sekz6je4ANbi4p/7jwrr5f2LcBa/3xqmnpGw7giIheexUdDPfYBjx1jLJ1MV3AFq06+5h9ONhKfbU9beRLJBon4Dlz8yblEwK0/2mUbK+5KJ9+TD1Iub9+gpMkvNYZJ/yHAuWm/S0bs6wulG4iQ8Se1Mrmm16AeNBExra9rvJkfJT2sqcHwf7We0zmLqxd16WxgmfB3NNXmj1fg7+WWzeSPO4lQjcQKesvYk1/Q6jHSEyEBQVMCeNSMtlMaMrAnYSK27qHsn2Rj+aaeXM15/NKatnGokf1lVJclICD45SVPl9unFE8Xf40wdMRKK6+WLn+Uz27lrjqPzpzYrzDU2GakIe/PYiBpX5x4QY1UZl++0qLcP8mHCGaIxRznNSK3fjXBg/HGhH48nZU0oCe2LMUl88XkfPy993yqOxYWQeJ8RzlTLSDMfOFhr1EDGmpEQt5m43okb6+H7WCtyPj/m8feog2iO0Ysnr5Pat+aDGTfSb9KEDXCCTDnQ0g8zwVS+rR64yMYAewJFbVVpfk5qWfNx3cf/vSebJX1vhmShn+esYcIloHha8AVG/YwpGynYkwtnSNg7gXlY0/Lm8zNK3T+taW0cN+cwGhuBuEyILRpjoL+qnA3CXtF4prUP18/IOi1OMxIHCPni4H5uj4p8iyxJuWDSJbf2uohvYxJNraI3RgsKmFprwgBmurpukp01s9MkI0RnwZ4m5LQ31sNzR/ID+Nwm3rcFmxBr+Dbsj3j8vFFOM5I/sL0NAN48/ITIl49XZOnHoXapXAabEXvlhKU+LlDsudDgRRomu5QWIwUFuKjWzAlqjjbGfQTkEUWLT24ztYyEMfjeU88Apa+tvWeMhfmKRg3A++V16PsRM/Y4zUg+Sbk9meUigabUZmbDofbICpAvt/eEDmMcJJ+jiAvLU/forI8Yeb21S+XznaINueBYOA/1PGmtrfe59iDhhzD2icZELOKwe0naskaL84zEsotJRurJCuiokUA2Jb3lbF3bA3DxQjx2jdOKeaCIuZDOUK+w8CRHP/KIBwDfVctImGO5Z2oxp09u559eIhbnH8iXwT+pVCG+zsN2lOu8kZKsqJHsRRKTkBi02YH2FoovAKxnl7v4ca/8KLCIccOFGNlM7pxHhPhHLhVjcIaZ5DspwtfRvoDvpt5lERuAjcTzmZExHpzdqxcvk+e6Ox/J9wjDRsJ/uXkL3gxIequf28GR4oRhsQYn3MyU1y2X5i8El+rjiMBaAMVnbb4oDV+c0ZhKiof3uTa1qJMQTzRmUYjpE218j3wGNom1eUbGeMKH7MD8RexFo3c+wmlGQrEt5A5b+1M7Crs5rwiHRjEaYUKT0Id1+MdIrGnrG1w4kM1bY3EZ6WvEgbneCP7ifP9TIsdqcvfE4Jwmy1fLDCMmGRnDLH40S3O4Bnr3l+el8ZHQF83ZymlGin4fwsF5DJ58aybCnNZhMT8yFBsnerpyQZhGCt2b40LlcrE/x+XPfZTozHvl1+sVJJ/d8lrb0iePPcNIvD9yvLiP9Bndob9r7Ml1hu/9nD2cZiQQGiMF7o2BBETFPXrIqLCwnk8s9m2N5XFrYF2cLcdMl9tSFMsRZhppkfdOQeenepHdC85kQkw8HmOyOmuOjDE4Tq4LbsfX1p4fsrZ+EffzveEurX0vpxoJNC89HSQflA7kxW+rNZrrrO2T2qP1tmDG8hd3IcSS8oGxR4yFuSiUI+SHCsebYkN7tB/gsVZ4+DRxkS7Gd/I7MgbwPjlOyl02c2qzPrRlc1kblL62mA2/Jvft4XQjgT1P0NaPcy1QBIvkDQgXeaSgDVzKoiihFEs+dy+mMgYX3yvimSCvI4XG5GI1pbHWntcp8vNnGcnfaxQn2nIO8YBhYyUhv6075jvD/GjMKFcxEuCk93SkuPEGGzXtkcRZMbaMks9AxsB57LKj8VWpD3Mxbq+xMA8gRtszx4qiGYg1IsddhK+tPa9ZxHeG9epe6dPaGcRW1RjjTcF798DaiA2fUb/h41zLQ4+rGQkgMflSrQALVjxb30ItkJC8jxWP22dvwromxfqpf+QMbCwuRi/08bze2E0quVgrNCPnr4gNU9vTJ77HebzQVsc31IqD1/O5mMWsPYaN9K+P72+ei0JJBYQ2FEI0fgsLY5UChTF5zGYjYZ0E5mEtrA+j85prwDi2L8eT3xZF1u7z4+O/UMkfj/FYTrBf1D8DO99aLD1kpA3gTYaCx2fUPxMUvN8HxYS2LicWXATnYxFfEEftK/j+10WO+2DeZCQhJiAjCTEBGUmICYwb6VdpghAiREYSYgIykhATkJGEmICMJMQEZCQhJiAjCTGBYSP985f3QogGMpIQE5CRhJiAjCTEBDYZKf9i9XG8kBC3Rv737JIn8PUmI9nf2+DFhLhV2A/bjPTi8f8LAJPx12t5USFuBdQ+PGB/+RJtw0b67sN38mT8jUghxCPwBLyxyUhsplfffi7EzcImGjbSp+/dfWMTIr7++U+EeOOJat+AR+CV4pm2kXoL+Q2FeBOJah+gb8hIz966+6D3VvIbCvEmEtU+gDfgEXileGZhJIDGbKbEJ603k99QiDeRqO7Lm+iT4hHzi/knC18s3krpM5sJ4JcrIW4V8wE80XobmdhICzMRvxfiBqkecCZqGmnxVgKYGBhKiJuCfJB9kWATLYwEmZEWbyZgCwlxi5gPiifMRGakC5m7vJmqoYS4UdgLbKLQSJB1tgwlxK3iDQRWxYOBLSLELeL9sEt+ESFukY7u7v4HJOK9dqjTx5QAAAAASUVORK5CYII=",
    win: "data:image/png;base64,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",
    rankDown: "data:image/png;base64,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",
    rankUp: "data:image/png;base64,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",
    reliveDown: "data:image/png;base64,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",
    reliveUp: "data:image/png;base64,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",
    recoinUp: "data:image/png;base64,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",
    recoinDown: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABWCAMAAACNZji+AAACB1BMVEUAAAAAAAAAAAC9VQhoJgCgOgCfPgYAAAAAAACdOQCbOAAGAgCgOgAAAAAAAADbci7YeS3ZfC7XdC6fOQDYdi7afS7bdC6tRwPHVhPGYhauRQmgOwGdOACbOACbOACaOADzihmgOgDbeTe2SQumPwWKMgCONACUNgB4KwBEGAAAAADlfBTbdBO+Tw/LczjUbA+bOACSNQCgOgBjJACgOgD7kRr////2bxr2cRr3cxqqThn6ixr3dhr7kBr6jhr3eRr6iBr4fRr2bhr5hBr7jxr5hhr3dRr1bBr7jRr3eBr6ihr4fxr8vYThmGD4exr3exr4gRr4gBr5gxr5gRr94tP6jxr4jUT4jkT8wqH4jET7wKH7qXP/+fT8xqH7p3P8xaH+8er+49P+6t/7q3P6pXP92sf80bv8rnPOWxb7pWL6lCX8xKH91Lv8v5P5kU34gxr7uJP6kzj5m2L4hjj5kCX8t4T9zq78ya75o3P7nU32eiX6roT6omL5iTj4iiX7soT8tXb6oGL6mE/4hiX4giX//Pn8vJP6kDj4fiSxUBjGWBf++PT917v+6dX/9u7+8eb+7+D8y6790KXyp2v6qGP7qlv4nlrpl1r7mTf4gzb4gDD+5dP+38D9v37jmWDjh0f7oEX5jDDUZyP6jiD8yKH7wZT9yJH8sGT6kiz5hiL2jyD4gh/6iRy9WpSsAAAANXRSTlMAGgPaPzbaBgnPmhXMEQ7y8vLylvLx8tP45t/TvI55bfwc/eXaZFFELiAM8u/u6+englo5Eby2IDYAAAtcSURBVHjaYhgFo2AUUBeYaLAObaDIhOohdWFx5iEOxHnkkT0lL65tOuSBgiSPItxHrOIKpsMB6MvBvSSrYzosQKg4PJpkhkckmZpKGsG8xLPKdHgAgCTl4F7KMh0eQEB22HlJVHjUS4MfDE0v2SIxbcEYREIB3EtMg9dLAOLJHYdhGIahgBYX3YKcR5406AK8/1UaSm6iBgH6SYHQBknAGfiGcPFY/pxOOxaRJIkuQdLadUvlSa3F9J3MKpJI+x+S1qV1JlvUr2W51zJZjB12oGkWOYekO5aczXtGlsaTBAB9J9SOkdPcAql9hqQUo9qPm80iFLTXYRoezRzoS2EiGejui/XufOju0RhLme5NhEi3FYlD64/JQBRaEUcdC6ifxIUFhYWBNwXnwMGCkW7b64PTsml1GojCMLjxY6XgbzmbQBBqoaiL3CYFoYlpWi6ltqUWbKFQrApeN36jIKggCOrCH+l7zpnpTDohgo/JzOlMvH3e6bnlxoNBL5ZIvR6HEP+Y7V2BNTMcI11CpKsPW85UTjLktic+UBtU9bbg43O2rFbvFzloecreA+gxmIy/Xu6luuvA9Mwk841rVy67SDhCRSwHxtIaiLnrDululM5tYL0wSFsosXpwsxgTlLKqotbKuguYbAQra9Ey0p8QRXGkcN3DKz8Sy9sImsaPNGDnmL1jtDVbq7K8uTjqK+zzEiJqV/haMrtB8wXYx3iKMEKWS1a3g4LNqB4J1CKxPzduLHP87cW7p9ISsQjGFrxGNhH2P3ErGZwqqqB2yaAlmmqqo1OOUcu2i9RCEOmxbVgz5UT0+pOvYkydrmmqV9XSP/QN5bFBXIriY6QU1QaGHr26zaYo1tF/cecOblwgjKTeuEn4+h1liG1+SUtEy2OC3ucR5X5zRESFllOuWlgS0WjWon2HR2U3LYoN5hA/0kljkOHDZ5XVLkCSCMiKr/Ixsrw6EXeRRmQZ76KQLTH5ksXlbmA9neKjrCpiKizc4vsWbh3AdT+SYHV7ZHnx82HUzhIma1ePo8ZIBXYqhnjljjaLk8VyPltgb7GuhTivDCPyyKtFMbsVUo8U1SHHm28/olZgUmm1YTFtblxSIAC7TdFVKrtFo2KqsckRGI5LzKOpZzgjxwhXtS2KqQnz/5HAu1/1rj4WWq7HxnuWh7rYMjszaZIN5G8peC3s+JPbrv3SZZoKUhOVGBvpdnkA7ZF8vuwQoBn9CBbc2BUSiTf+WRAJppxVFVHVTxnt5n80JR7Iy1BYI3XlRVfAbNE4p5HQKn570ymvPpsdc76YtcaXTzGm80KmMU9HZfwul0RZUWZEF7KyHnPl2JVYQATP/vk5Ryxfqryvy5FaCCNZY9WmgBcfft9qYEEhW7PnVqZVTj7Znvefj0n19aTtMMk45mIvji/nmQWPHuv5y26nq3Rw8S34kbhdPKiB/N6PINEOy9vSZ0tEprFLAP2yPFzQCee8v2fJPAvJc3470c2omVEnIIhUhxp5+/RP1/Q2Lq4mRIeuRZeRqesgmmOcE+3x3/D0hE9+RJls7veI1cTi+Xw+Z0Vs5xcTBcvDyRBMDmOi4b8iPXFpRJqawR9JrkUwqWSdsjkS98kBT+N9cfRZaMPPBAyJLmxNdN9bHvY7fdDp4MZg8COpIyPC1Ij+keR8g0jQFX2AmkEkp4vpJc+Nke6HkfrqbuBIpuTlFRcrjGmKIgWrflqLVP9mpBaedlhe4Uitpw0Pq6uTiwQ/uaSUzX6ARlolsE7wo0Q9SVNeThKtUxRcJzzcDCPhcP8Z6XW9MSatp02U5XSONbZeUC6iiGSUnw2PLKDpSJw7KpFGJJl1+QGXQiJoND/SiRe1cK9jWK040kF7xI79+mkTc4G1BOfMUVZpwpHQLTB4RM2oPXgA98SARWOvy+lZenZ2liS4U1TCf0V6/Uk7RXlOlN+v8T6H/moFYVgPMyLKnqWIBBOOJKI643qWOUZ40nHAtnGHMi6JdGaQZeEu3xhwcdEUqc+yLlL4Nf6XFbNZdSIIwugjCC58lFZBaHojiDDjz4AyiIjeyc4YEyTREPwHQREVEdSVoAvxJT1V1ZMux4lRybnT3ZW+SThfTSdX7MPwabxw6fKFt+F33ubD/aTTL+THV6826MC1cENj35B1gyY8bLqN6FwgNu7i23TM3h1n4D0o1F+2z4/hIyF5J8sieifA2B/b79kWpOAHYT4FE0R78f6kPJa/iLIVRsltvqrNR7UNwdxpxFbRu4fQpmTlUQhH1HYxtrhIT9G0TySwhBGef/2iYXTyufhEPKYWu4tsM8T18pOmmUlrN9czN+UUshpZdMOt06LNSaYhdFoki4S71kkjGRqpMB5JFcXSTEcSvborJxpXjUOBubEkCmgkGq0DHV3wcB2HdbZVUaY0CWGWgEgpr+s04r4rUl2nqkoVMB/3kRz4hiHN/YsjoI/gTddnY82OYZESbG5Sc3jn1J4pb+4j8b8XaVekKtWJq5LtqqoroWbpi9pHovnFFBNwvHnP3hjJDvaEokiVyreWu7FMs5FMXQhTe00OsezbXps7hXjzVhTLpmmPeO6q1l326zyGkeSQOILn9aMfat8flYJ135T+HGkzsZuxlExqnBKzsCYEC6+pQAJilyUlknjnSCxdMOYaCGLczlX0kczXLvDfCrefJs9IouUwSNbDGg857XOedXNRAdHodqZW+IKg0tfUcgxRzVSLtl2IsDjzugirdtI03SyO4SM9Sx4f6d2XNARXsD7ProlrXYEEmYpH7rgUtZ6WRfuSw7mwozILWNuNYDDFifQ88hrMqXfYVhKp8N+RXl1JqTS0NFen+WxCoLDkkfrN8F4dHa1W6xtEkrZ3SzwWMx6+JJkS45yHYTJFckrSXazjkN8jnbPL4SPVCVBL2EFQPn/oP3Y5Ur/omAcghOxFBoem0MW4tmrVBblFscBNIyPFPOymPWfOkK1lb5QzZ87IJJePZLLbBM/lHz+36lhF2sqwW2ORbAezrmnXH6Nj1TUZi7Bq23Ye24ZbghWDWYuPbdO5TrOpqJrMukLZhptEyk9gjOMjRWRj+Q75Fl7fe1FRKax7UbNinpdff2tGWcdMRR+GkYD5j5ztVwpbGSd8pAGfXoxac5nuHyMJsdibKQwi7dX2ATC22SYW2BOpWNpByIXlcJEUCny2mtQO/5t/wHRFdU8kOM3QlcJdPtIL6+sgkjvZij8wsPX/O2OuvBhWGoNI2J3GNisbrEz9fk40xEdSseJm0jnSv/SZyw811LpE6m3OmB6Yrvnm2kfaz/5I+3GnObe5bPhI6lsk85L3fKT/4dTpU8BalmMukpO1pXSUeTfI2GxQHRAcbfbiOxlEemAN3i3er3Aw+VNuUdv/ZjzS0PmQnZYfW3zfGYfhJOTKRzpgAvM9MEj/bJfsVRuGoShMIGRxk66unR/IT9sUWlo6xHT04sVdXfoG6tJnCN2S1RDTDAnkSXvw5UpGlNYK0SCTz9LRtafzGeHhGSOFRm2lSOuMsAM6lglIwRhdqbwTfLWtNKfGXJbKGxQ3Uzrlj8aiTeC0SBzLAesYJSoMqDQWSSgDS525NbOQofhDSdWmmVTs9Y65OYI2pTFJVWkhiSw15/bU1bBvkqiRvzCVl6rSt43mAMkXxbQ6d0XU53IglTZm15rfjeHOSfmoxjh4RBzN9mHIShf5Jvq9OV0S+btraySaB5W1zHZ5NWKl/jhdfr0Zk2V0lIEFKDOkAe9Y2AhsBM3lJMGXf/j8SPPgWir5+7QB5Ael9OiLw77YvTrMrijGQgQ3rDSaCCHWqxeHWa0FCD1Wmod+I5Qmwx4r9WbhvftKfvDUVUrd9iCcdpxm2unPvKqS582f225z2/I0pZb7nJVcAEp3zVT6AaNv45Kv9a0XAAAAAElFTkSuQmCC",
    nextLevelDown: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABWCAMAAACNZji+AAAB+FBMVEUAAAAAAAABAAAAAACYNwC8VQgAAACfPgZxKQAAAACdOQCbOAAAAADZfC7bci7YeS3XdC7Ydi51KgDbdC6vRQmYNwDHVhOrRQOgOwGdOACZNwBuKADMZxClPwSaNwCTNQD0ixnBYBy1TgadOACONACSNACDLwB7LABrJgDvomfwhxnZdzblfBTadBO+UA/Lczi4SwybOAD7kRr////2cBr2chqqThn1bRr7jhr6jBr2bxr4fBr7kBr6iBr3dxr4fxr3eRr5hhr5gxr6ihr3cxr6jxr3dRr4gRr6ixr4exr4gBr5hRr8vYT3dhrhmGD4jUT5ghr2dxr7jRr5gRr4jkT6hxr94tP8xqH1bBr7rnP7qnP7rHP8xaH/+PT6m0fOWxX7wKH7oEj+8er6lSX6kSX+6t/4hTj91rX+2rT7wqH5gx76roT4iSX3fCX7jx7928f907v7t5P5n2H6kjj4hSX4fR/6ih3/9Or94dP917v91a/8t4T5jiTGWBf949P8voD5mWL7nVH5izf3gCX//fv++PT8y677u5P6o3P6l075kk32eSX+5NP9x5T8uoH7uH/7tHn7pWP7nkL6lTj3fzKwUBmyURj+48n8ya79x6H8xp39zZr8vHnzqW3pmVzjh0fUZyP+49P7wpb8smTok1Xdezn7mjbPXBfFIr/5AAAAMnRSTlMACgMHOdsR2joPz5oN8vLy8vI48uBv+NPSvH0b6NiNYPzm2JdRRTEmFf38+/Lw7evnp9q2DqsAAAmwSURBVHja7ZzlthQxEIRxd3d3h+Du7u7u7u7u7u68JtVdk0nuhMzgcDnUJt2dzAJf9TZ74AeU+a//+pMq9w8oa6hLpwqlW519Vyg7tm/crmLpVrtqDcurJzpq2LhHv1KvNi2qNYcnOqrQuE2/f0EtmnH2EFv17PdPaELj5uIJu3zTbv3+DbVtLb+d4Kh8teP9/g21aJZaWtfv31Dt9uXLq6Wy/4ylmtXVUvn/lv5m1axethRaGu6VqLE1UmKp/F9uSYgTcouOEOjvsARAH1xF8BQ6LQZj52vw4F9miXBODhNRy2/WYPIiYEkBoZ6AGCiw9KNznWDL+hERXF90MGECYkbOkr4hyd9miZhIfpD93X3HniDBB8MDjVrhSu+YkyoJuMhUUPgp8Xegazu5J2hB+mB4Q6Gl3luwBBKBkIRIG21pSsC5p5D1gM3AeymGIPBu7lw5ZyzFW8pOhuIlwfWng3AKx8KnJWH4pnCEeNAfOhcxPZIdlxOGzIWjIbgZIpo7dy6iZ2k9pwEiF3pte0cpOX9eRp0KnzkgCyZGyoTV/tyggqQE0wQ5Kp4Q4owCFwILTSA5CkkIck2xzlpKGshNIs/SqUOHnu1EqUyEcpj2yKdcfCRJMxqtuBPkl8UNSuGV/mpNXCS4IrgmemMZyt1be5NLWEp/eWQGr8vPDLR5p9Z0kUQIEMSHpLEyCdpcdlNJST1YLnhGCUt8/m2aPJkJSzbEjBVYciY0UAS9AUP0BI7BZGQ/2cakUd/El2fnzpJ7Qg0J+pklZybna9w4bCwosDSX80ZIYqO8ayB68j5nvDJUxxYtevJkUVT3sv1Ous7ly5jr7nBvBU7Ky2jF2ldgiXwO2bXynfE85ei6ydUS9j2/2wq+wZhjKeQuY3YH5CNswh6BzQDV9iyRKrQEfTxf5GmytvvMEk+74aGkhBmbHeawRLTEmLWW/ZgxK/YptyWPqcCSIqb5ufE8TS6W8C4yhvwIxcqQoh+LWO1bgU8sxl9sCUORzLZkXyU8gdKCs2TTM4KlL3Gn9EHH6WARtHw5LK2VvGj5G3xIy6XM8bVgxIgxY5DGQL6leMOF+JTn6WBI6g22brxgacS3a7mJaQW4sRYAHAvSTPE2sDQuMySsU5XwJNykjwuWdu0r9oD2or/oM9O+ZU67zQbvdIXQnnAK5Fs67necuCysPE+bDn5lv1csy07IAgSSycFDIzCC411uTo6JaxpeSYUlW+VbknGJKPB0FJ7CfrvBlsgRWu54WRXKuYQlYpMYK1+hpUAH764poaMlPIES9CmoI09uYElcndznHgYVRd6QGZaywGPHYiHYFOpLlthk7LuHTCjnKbfvtDRm71p8c+0lN7GRoBQ/RNZA5OVmIWKeCiyNSVuezPQjk6ejkQkHLHFhadq0fSfx1ksO+crSuPZm6bZ8raXZsyVAiJ6l7cFQnDe5upE70rQEXcRbL461WmhyhOd4d1RrJ00CtKBPEvrZk3BmjQKLF3VDS+6LxORrxViOioZELGyPjeZLeO9uZB4WxnUx+1xseMddKTzIpZyHJUIJoZYr31LQ5kJL+aIlaO8KYxaeHTt2EpZMCPqbjInCUSgIzHoeEPeKJQENNU9eSFPnTZ06ddIk7HmoVCUsZZmKBi8y12RXS0INPvmSWCoks+XFntIA8YQai9k52GKgLbgBsiygAzzQKNkIWFL4lgK4/K+HTVsFeKww+hJYsoNICtHZXbuupKSkZpOTG4KiQJCKca1ZgXWF3Akwl1RShIpaAijCykO5jjjWGoRRN2k10hKqqQiI1DwHnRFRkyB5tTGPtxlzeFRUhZbYYXad9daVJXXUd+S6jUVhMHQ4OCCwhBgq6Tfc5aJdXWFWXB2Fv/6tzn3bsGFYkmz0LWmzbb/l4ET8m74jgRfyUCDVjS5zTL5LZzfADBK+WvYoLEOx6jhL+8luZWfbqYQjr+cxaFj6Wv5hSUJOyDfC0WEpTuOr9XSEvtASPPid9mrVLd9RISQtEZSBrMhOPIaiow0btdxj5HMKNEXWFEiCL99S3pAUO0rp0wmBJcTv0rYLdCTU6umxBcdVqNGjvVjS0lc7Kp7sYkuA0yDUJUkvH5Y/b2xMz9tWwOBlYR6NUKDAElvtgLVGuu0cHTkQsBVYmsIlO6LRNgJ6mxhau82nvCpXh7cFhgot5dCdPV/siO32BEsRA6NTtIBRRs5cWL0xc71nLX0GGsnl6Sst3fEcxZo9OuVlM2HpAtI3ahdmbM9GC8tEU/KlPjJPoaVz6XxnSPGa7zlSscH5s71x9elMR4USESvoNC5VGy+fjrGevrzRO83A0gwhoJDjnJKWtL1uNnhKkN9aR3EHhHbkNmUsFctBY1NzACt7BiIfzBEfE3GWpxMnIkGSJ9b3LeVoylPriFgScy2JEAsFWiUnfPAhJI7gRIDFgkYEtQClluAXp6wlR0keFsQ/dujQUzjSE/UtLSc1B4StDi0pr3AqMZ1IUlqaoY056mU8tmYU/vItsa+Bpa/RHOJRlgY8akIcaCGDoo3GomYQjzXETwALezxgx1tkSjJP1hLSgPEDBvAxMrZnaUcBMxARBFwjQLWJ2Kg4JIRiq4HNLYRsLV5iB7Zsf+cQDyIueVlbSwNSS2Rn5aTXjFFLM1I+TbRBJzSjC2Aj2W2UKv1gWNBO2nILpZEpufMtEZUhw80jC4a4anmWODAI7vsDiOTFISrAMFKoYlIYbScTNvJPU2iJAx0HTw0UwvudRvXz1R8vxC8qY4nMX69fwiu4zCLEGHyxpVivOSAQ8i8RsH+KQks/f65dtwPqn2VjaJKQdWcs/ZhIiSz7F4nYiNgxeZau5eFaZtIi/WRQRqyUmuurNGiQfwgsJVNB+J8rcntzEoAXM/OEBaGSyBdqnkpY+kkN91rO8FXKQGNrJDOR00DpgWdP32WJyAl0ONjFIiSpKUdKfPIGD3M09IuW7n8Zny9Cfzs5RETrgMNCxkLM71KtVqmlvclwF4Bmz1SCGrS1gPbHtRgvSYjc93s3Sy11PdM/Su4NtCsoNyVMztRPFKEdOS8gjbyl7t9u29Baatp9+u0z879Zs2YxacCCEEWIv11X70x/0aBDaqnRq5vTS79evHaW+jZa9frVy5mlWi/ff/i0qkFH+y9jGvZZtWrViYcDS7EenFgFNeliLTVv0uifsNQA3w5iSTy1btKr9Ftq1KBZDWepRr1WTVpWLtVq2bJp6xplnaWyNao271SvXpVSq3r16nWuWkM/JLFETzWqVirdShzBUuqJqloaRXRMHS3RE0yVepVPHNESPEGl11hCz//E4jOpC0Q8mUd2gAAAAABJRU5ErkJggg==",
    nextLevelUp: "data:image/png;base64,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",
    rechallengeDown: "data:image/png;base64,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",
    rechallengeUp: "data:image/png;base64,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",
    star: "data:image/png;base64,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",
    starWrap: "data:image/png;base64,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",
    starEmpty: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACAAQMAAAD58POIAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAABhJREFUSMdjGAWjYBSMglEwCkbBKKAzAAAIgAABjZizbgAAAABJRU5ErkJggg=="
};
exports.imageRes = imageRes;
var scoreFont = ["data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,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", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAACMCAYAAACK9Qy7AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAZoSURBVHhe7Z3daxxlGMXbFHLRiJgiiFAQ1IteKNILi1AN1pYSLFhEMBclFUraC/VfEKwIlhLQFirqVRWppkaTkKL9MA1NqkE0hjRtWkUpMTRq7CbRFgS1eTzPzrtkd2Z2szs7O/M0ew782HT23XfS89vZyX7NrKo0i4uLm8Fe0AYOgxEwWOdoB53gebBbRPbh8jFXWfzB5C3gQ6xoATBlBp3Ng/fBZldldcGc2zBZF7jhrYKJGnR4GbS4aisPbrwdXHXzMTEEfd4E3aDV1bx8MPgZ0Af+dvMwMQfdToMdrvLiwdjV4CgG38resljmLotMfSFybVhk4k2RoXaR8x31i/7/Lx72+tBe5n9wRRUPOp4BO1314cGA58Csu01h5iZFvn9d5MR9It1w9xkpivZz4n6RsTdKytGutXNXf2Fwhf4Zm3FjCzN5RKTvboqoFO2rf73I6H6RzIQrcynoW3MMP65xGrxgQSM4roMCuXRIpHcdZVTDcXBmI6TgUcYXCMmANqciK6MBC3bhMvgcY6ITMu6ijDhQKacfFvnjgiu3ILoxNGaFQEYT6PGW52V2TOTUBpFPfBOTaOidWu/ceif3Bf1P4WJtVgh+aMaCmew1+RnHDqn3TpFP8yYl1aF3br2T6529MAvuUapBt5A9IPhMfHCTSJdvQlIdkYX8/q3IyQf5cBU3+mijjzr66OMLHPSAJgpJktJCdLfRrELw1NKXsddEeu7g/qMW6G5Adwe+5AuZ8xblhUJqRyQhA49wh14rdDeguwPdLeQFHm6APRSSNBRiDAoxBoUYg0KMQSHGoBBjUIgxKMQYFGIMCjEGhRiDQoxBIcagEGNQiDEoxBgUYowVIUTf2z/bKvL1S+FfB0iar14U+fyBaB+xXRFC9D/x20n3yxnI/M8ig094n9cN+31LQSE1CIUACvFNlCYUcnsIwe/+IzgNwr7MHwdnHX+6VXqhEBAu5OXsdypqGKzjafCLW6UXCgEU4psoTSiEQnLBOigkAIVQSC5YB4UEoBAKyQXroJAAFEIhuWAdFBKAQigkF6yDQgJQCIXkgnVQSAAKoZBcsA4KCUAhFJIL1kEhASjkthHyAXgW7K4R7WAX+Mmt0guFgBAhqYVCAIX4JkoTCqGQkql7Ifop84sHRH79RmT6y/SZGRE591QdC1lJUIgxKMQYFGIMCjEGhRijDCE8snWSUIgxyhDCg/EnSSQhGp4/pDYsJwQ/8ww7SVLGFhJ+DirNuce5lcRNGVtI8bO06RnF9MxiUV5EI+EsJ0SDfxc/j+F1SPnuFZH+e3n6vDgoR4gGyxqxoPC94/xcHxeZHsC+pdM7rSjlRKNcIRosKH4uXH/0HK96It6w9wtWOrV8P8QfLNwJgn91MUup5TuGxYIrj4D/3HgmP2kI0WDcNgzq0sHezZhs0hKSCwZuBS+Ad8G8m6N+k7aQsODGj2KefbgM+8TfSiH5Ty4ypYOSkv1sL1M6FGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsFGIsZoXgNk/iBvr53rdBxpumTpOmEAw6CP5xt2M0aQjBldvBVTeeyU/SQnDFDjDtxjL+JCkEC/mVtuWSlBAsX4OFk96QkOgXPUdfFRnuwKQP8Zu4UShXCJapjGNg0RuSl7krIgObot0jSCEVCAn/nnoGG8yZjZQRF+UKwT/aQPD5xfBWkY99k5LoVCWExzqJHwoxhh5dSY9F5gu6179sm50OCkkMCjGEHgxODwqnB4fzBd33gCang0ISQfcfpzaIzI65gpdCIWlQXMgCuteDyDU4HRSSCLr/0MMmBkMhiaMdapfaqS/ofQoXa50KL1gQ/kydTwyrR1/z610ncumQK3UpuhHoxuA0LAXXhb+WxZdOqke70w61S19Qt24EjU5DYXBl+CH+MhMio/tF+tfzFd5K0K767hG58p4rsjDatXbu6g8GY0q//K5i9DiL14ZELhzEDqpd5HwH8TOEXsYPSPagodpZSNDzLVwcBatd/eHBQL5BlUC0Y+3a1V46GMi3cGsY7VY7dnWXF9ygFXSDm24epsqgy3/BW67iaMEEW8BH4C83L1NhtDvX4RZXazzBhC1gL9AnkXoY2REwSAJoL+8A/WBhi6uvjKxa9T9EM/ddkk9URgAAAABJRU5ErkJggg=="];
exports.scoreFont = scoreFont;
},{}],14:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/21.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _libEventEmitter = require("../lib/EventEmitter");
var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
var Common = (function (_EventEmitter) {
    _inherits(Common, _EventEmitter);
    function Common(domfn, locals, name) {
        _classCallCheck(this, Common);
        _get(Object.getPrototypeOf(Common.prototype), "constructor", this).call(this);
        if (!locals) locals = {};
        this.name = locals.name = name;
        this.content = Common.str2dom(domfn, locals);
        this.isActive = false;
    }
    _createClass(Common, [{
        key: "prepare",
        value: function prepare() {}
    }, {
        key: "active",
        value: function active(args) {
        }
    }, {
        key: "disactive",
        value: function disactive(args) {}
    }, {
        key: "update",
        value: function update() {}
    }, {
        key: "didMount",
        value: function didMount() {
            this.emit("didMount");
        }
    }, {
        key: "didUnMount",
        value: function didUnMount() {
            this.emit("didUnMount");
        }
    }], [{
        key: "str2dom",
        value: function str2dom(jade) {
            var locals = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var str = "";
            if (typeof jade === "function") {
                var jadeStr = jade(locals);
                jadeStr = jadeStr.replace(/>(\s|\b)+</gm, "\>\<");
            }
            if (typeof jade === "string") {
                str = jade;
            }
            if (typeof jadeStr === "string") {
                str = jadeStr;
            }
            var wrapper = document.createElement("div");
            wrapper.innerHTML = str;
            return wrapper;
        }
    }, {
        key: "getOverPanelSizeStyle",
        value: function getOverPanelSizeStyle() {
            var width = window.innerWidth;
            if (window.innerWidth > window.innerHeight) {
                width = width > window.innerHeight * 0.66 ? window.innerHeight * 0.66 : width;
            } else {
                width = width > window.innerWidth * 0.76 ? window.innerWidth * 0.76 : width;
            }
            var height = Math.round(width * 0.86);
            return "width: " + width + "px;height: " + height + "px;margin-left:" + -width / 2 + "px;margin-top: " + (-height / 2 + 20) + "px;";
        }
    }]);
    return Common;
})(_libEventEmitter2["default"]);
exports["default"] = Common;
module.exports = exports["default"];
},{"../lib/EventEmitter":11}],15:[function(require,module,exports){
/**
 * Created by tommyZZM on 2015/11/12.
 */
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var _coreHookManager = require("../../core/HookManager");
var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
var imageRes = require("../../res/resource").imageRes;
/*配置按钮资源*/
var btnRes = {};
btnRes["restart"] = createBtn(imageRes.replayUp, imageRes.replayDown, function () {
    _coreHookManager2["default"].excuteHook("restart");
});
btnRes["more"] = createBtn(imageRes.moreUp, imageRes.moreDown, function () {
    _coreHookManager2["default"].excuteHook("more");
});
btnRes["share"] = createBtn(imageRes.shareDown, imageRes.shareUp, function () {
    _coreHookManager2["default"].excuteHook("share");
});
btnRes["rank"] = createBtn(imageRes.rankDown, imageRes.rankUp, function () {
    _coreHookManager2["default"].excuteHook("rank");
});
btnRes["revive"] = createBtn(imageRes.reliveUp, imageRes.reliveDown, function () {
    _coreHookManager2["default"].excuteHook("showad");
});
btnRes["recoin"] = createBtn(imageRes.recoinUp, imageRes.recoinDown, function () {
    _coreHookManager2["default"].excuteHook("showad");
});
btnRes["levelnext"] = createBtn(imageRes.nextLevelUp, imageRes.nextLevelDown, function () {
    _coreHookManager2["default"].excuteHook("levelnext");
});
btnRes["rechallenge"] = createBtn(imageRes.rechallengeUp, imageRes.rechallengeDown, function () {
    _coreHookManager2["default"].excuteHook("rechallenge");
});
exports["default"] = btnRes;
function createBtn(upBmp, downBmp, cb) {
    var btn = document.createElement("img");
    btn.setAttribute("src", upBmp);
    btn.style.width = "45%";
    btn.style.margin = "0 2%";
    btn.down = (function () {
        this.setAttribute("src", downBmp);
    }).bind(btn);
    btn.up = (function () {
        this.setAttribute("src", upBmp);
    }).bind(btn);
    if (window.navigator.userAgent.toLowerCase().indexOf("mobile") >= 0) {
        if (window.navigator.msPointerEnabled) {
            btn.addEventListener("MSPointerDown", function (e) {
                e.preventDefault();
                btn.down();
            }, false);
            btn.addEventListener("MSPointerUp", function (e) {
                e.preventDefault();
                btn.up();
            }, false);
        }
        btn.addEventListener("touchstart", function (e) {
            e.preventDefault();
            btn.down();
        }, false);
        btn.addEventListener("touchend", function (e) {
            e.preventDefault();
            btn.up();
        }, false);
    } else {
        btn.addEventListener("mousedown", function (e) {
            e.preventDefault();
            btn.down();
        }, false);
        document.addEventListener("mouseup", function (e) {
            e.preventDefault();
            btn.up();
        }, true);
    }
    if (typeof cb === "function") {
        if (window.navigator.userAgent.toLowerCase().indexOf("mobile") >= 0) {
            if (window.navigator.msPointerEnabled) {
                btn.addEventListener("MSPointerUp", cb, false);
            }
            btn.addEventListener("touchend", cb, false);
        } else {
            btn.addEventListener("click", cb, false);
        }
    }
    return btn;
}
window["meiriq"].lib.createBtn = createBtn;
module.exports = exports["default"];
},{"../../core/HookManager":9,"../../res/resource":13}],16:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/29.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _ComBase2 = require("./../ComBase");
var _ComBase3 = _interopRequireDefault(_ComBase2);
var ComMask = (function (_ComBase) {
    _inherits(ComMask, _ComBase);
    function ComMask() {
        _classCallCheck(this, ComMask);
        _get(Object.getPrototypeOf(ComMask.prototype), "constructor", this).call(this, "<div style=\"position:fixed;top:0;left:0;right:0;bottom:0;z-index:60;\">\n            <div class=\"imgBackgroung\" style=\"position:absolute;width:100%;height:100%;background:#000;opacity:0.5;\"></div>\n            <div class=\"imgWrapper\">\n                 <img/>\n            </div>\n            </div>", null, "commask1");
        this.img = this.content.querySelectorAll("img")[0];
        this.imgBg = this.content.querySelector(".imgBackgroung");
        this.ImgWrapper = this.content.querySelector(".imgWrapper");
    }
    _createClass(ComMask, [{
        key: "active",
        value: function active() {
            var _this = this;
            var arg = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
            this.img.src = arg.picture;
            this.imgBg.style.background = arg.background || "#000";
            this.imgBg.style.opacity = arg.opacity || 0.5;
            this.img.onload = function () {
                var width = _this.img.width;
                var height = _this.img.height;
                var w2h = width / height;
                var size;
                if (window.innerWidth > window.innerHeight) {
                    size = "max-height:" + window.innerHeight * 0.9 + "px;";
                    if (height > window.innerHeight * 0.9) {
                        height = window.innerHeight * 0.9;
                        width = height * w2h;
                    }
                } else {
                    _this.img.style.width = "100%";
                    size = "max-width:" + window.innerWidth * 0.8 + "px;";
                    if (width > window.innerWidth * 0.8) {
                        width = window.innerWidth * 0.8;
                        height = width / w2h;
                    }
                }
                _this.ImgWrapper.setAttribute("style", size + "position: absolute;left: 50%;margin-left: " + -width / 2 + "px;top: 50%;margin-top: " + -height / 2 + "px");
            };
        }
    }, {
        key: "disactive",
        value: function disactive(cb) {
            this.img.src = "";
        }
    }]);
    return ComMask;
})(_ComBase3["default"]);
exports["default"] = new ComMask();
module.exports = exports["default"];
},{"./../ComBase":14}],17:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/21.*/
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _resResource = require("../../res/resource");
var resource = _interopRequireWildcard(_resResource);
var _coreConfigureManager = require("./../../core/ConfigureManager");
var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
var _coreHookManager = require("../../core/HookManager");
var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
var _coreUIManager = require("../../core/UIManager");
var _coreUIManager2 = _interopRequireDefault(_coreUIManager);
var _ComBase2 = require("./../ComBase");
var _ComBase3 = _interopRequireDefault(_ComBase2);
var _ButtonRes = require("./ButtonRes");
var _ButtonRes2 = _interopRequireDefault(_ButtonRes);
var imageRes = require("../../res/resource").imageRes;
var ComOverPanel = (function (_ComBase) {
    _inherits(ComOverPanel, _ComBase);
    function ComOverPanel() {
        _classCallCheck(this, ComOverPanel);
        _get(Object.getPrototypeOf(ComOverPanel.prototype), "constructor", this).call(this, require("./../html/overpanel.jade"), {
            size: _ComBase3["default"].getOverPanelSizeStyle
        }, "overpanel");
        this.root = this.content.querySelector(".common-container");
        this.scoreWrap = this.content.querySelector(".scoreWrap");
        this.imgWrap = this.content.querySelector(".imgWrap");
        this.img = this.imgWrap.querySelector("img");
        this.btnWrap = this.content.querySelector(".btnWrap");
        this.btnRes = _ButtonRes2["default"];
    }
    _createClass(ComOverPanel, [{
        key: "getButton",
        value: function getButton(name) {
            return this.btnRes[name];
        }
    }, {
        key: "active",
        value: function active(args) {
            var _this = this;
            this.root.setAttribute("style", "position:fixed;border-radius: 20px;top: 50%;left: 50%;background:#ffffff;" + _ComBase3["default"].getOverPanelSizeStyle());
            var score = args.score || 0;
            var increment = score / 10;
            var scoreArr = [];
            this.img.setAttribute("src", _coreConfigureManager2["default"].getConfig().gameData.skin.OverPanelMainIcon || imageRes.win);
            _coreHookManager2["default"].excuteHook("gameover", [score, this.img.getAttribute("src")], args.cb);
            this.tempScore = 0;
            this.scoreWrap.innerHTML = "";
            var length = score.toString().length;
            for (var i = 0; i < length; i++) {
                var scoreImg = document.createElement("img");
                scoreArr.push(scoreImg);
                scoreImg["class"] = "score" + i;
                scoreImg.style.width = "20%";
                scoreImg.src = resource.scoreFont[0];
                this.scoreWrap.appendChild(scoreImg);
            }
            this.scoreTimerHandler(score, increment, scoreArr);
            this.btnWrap.innerHTML = "";
            this.buttonLayout = _coreConfigureManager2["default"].getConfig().gameData.buttonLayout;
            if (!Array.isArray(this.buttonLayout)) {
                this.buttonLayout = [];
            }
            if (this.buttonLayout.length > 3) this.buttonLayout.length = 3;
            this.buttonLayout.forEach(function (btn) {
                if (btn in _this.btnRes) {
                    _this.btnWrap.appendChild(_this.btnRes[btn]);
                }
            });
            if (this.buttonLayout.length >= 3) {
                this.btnWrap.style.bottom = "-16%";
            } else {
                    this.btnWrap.style.bottom = "3%";
                }
            /*生成最高分*/
            var highscore = this.content.querySelector(".highscore");
            highscore.innerHTML = "最高分：" + _coreConfigureManager2["default"].getConfig().gameData.gameHighScore;
            highscore.style.display = "inline";
            if (!_coreConfigureManager2["default"].getConfig().gameData.gameName) {
                highscore.style.display = "none";
            }
        }
    }, {
        key: "update",
        value: function update() {
        }
    }, {
        key: "scoreTimerHandler",
        value: function scoreTimerHandler(score, increment, scoreArr) {
            var _this2 = this;
            var length = score.toString().length;
            this.tempScore += increment;
            if (this.tempScore >= score) {
                this.tempScore = score;
            } else {
                setTimeout(function () {
                    _this2.scoreTimerHandler(score, increment, scoreArr);
                }, 50);
            }
            var floorScore = Math.floor(this.tempScore);
            for (var j = 0; j < length - 1; j++) {
                var pow = Math.pow(10, length - j - 1);
                scoreArr[j].src = resource.scoreFont[Math.floor(floorScore / pow)];
                floorScore %= pow;
            }
            scoreArr[j].src = resource.scoreFont[floorScore];
        }
    }]);
    return ComOverPanel;
})(_ComBase3["default"]);
var instance = new ComOverPanel();
window["meiriq"].lib.ComOverPanel = instance;
exports["default"] = instance;
module.exports = exports["default"];
},{"../../core/HookManager":9,"../../core/UIManager":10,"../../res/resource":13,"./../../core/ConfigureManager":8,"./../ComBase":14,"./../html/overpanel.jade":19,"./ButtonRes":15}],18:[function(require,module,exports){
/**
 * Created by tommyZZM on 2015/11/12.
 */
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _coreConfigureManager = require("./../../core/ConfigureManager");
var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
var _coreHookManager = require("../../core/HookManager");
var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
var _coreUIManager = require("../../core/UIManager");
var _coreUIManager2 = _interopRequireDefault(_coreUIManager);
var _ComBase2 = require("./../ComBase");
var _ComBase3 = _interopRequireDefault(_ComBase2);
var _ButtonRes = require("./ButtonRes");
var _ButtonRes2 = _interopRequireDefault(_ButtonRes);
var imageRes = require("../../res/resource").imageRes;
var ComOverPanelStar = (function (_ComBase) {
    _inherits(ComOverPanelStar, _ComBase);
    function ComOverPanelStar() {
        _classCallCheck(this, ComOverPanelStar);
        _get(Object.getPrototypeOf(ComOverPanelStar.prototype), "constructor", this).call(this, require("./../html/overpanelstar.jade"), {
            size: _ComBase3["default"].getOverPanelSizeStyle,
            style: "\n                <style rel=\"stylesheet\">\n                    .overpanelstar .stars-wrapper {\n                          width: 100%;\n                          height: 36%;\n                          display: -webkit-box;\n                          display: -webkit-flex;\n                          display: -moz-flex;\n                          display: -ms-flexbox;\n                          display: flex;\n                          -webkit-box-align: center;\n                          -ms-flex-align: center;\n                          -webkit-align-items: center;\n                          -moz-align-items: center;\n                          align-items: center;\n                          -webkit-box-pack: center;\n                          -ms-flex-pack: center;\n                          -webkit-justify-content: center;\n                          -moz-justify-content: center;\n                          justify-content: center; }\n                          .overpanelstar .stars-wrapper .star {\n                            width: 100%; }\n                            .overpanelstar .stars-wrapper .star .star-bg {\n                              height: 100%;\n                              width: 100%;\n                              background-image: url(\"" + imageRes.starWrap + "\");\n                              background-size: cover; }\n                </style>\n            "
        }, "overpanelstar");
        this.root = this.content.querySelector(".common-container");
        this.starsImgs = this.content.querySelectorAll(".star img.star-bg");
        this.evertStar(function (starImg) {
            starImg.src = imageRes.starEmpty;
        });
        this.btnWrap = this.content.querySelector(".btnWrap");
        this.imgWrap = this.content.querySelector(".imgWrap");
        this.img = this.imgWrap.querySelector("img");
        this.btnRes = _ButtonRes2["default"];
    }
    _createClass(ComOverPanelStar, [{
        key: "getButton",
        value: function getButton(name) {
            return this.btnRes[name];
        }
    }, {
        key: "evertStar",
        value: function evertStar(cb) {
            if (typeof cb !== "function") return;
            for (var i = 0; i < this.starsImgs.length; i++) {
                cb(this.starsImgs[i], i);
            }
        }
    }, {
        key: "active",
        value: function active() {
            var _this = this;
            var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
            this.root.setAttribute("style", "position:fixed;border-radius: 20px;top: 50%;left: 50%;background:#ffffff;" + _ComBase3["default"].getOverPanelSizeStyle());
            this.root.style.transition = "0.6s";
            this.root.style.top = "-50%";
            setTimeout(function () {
                _this.root.style.top = "50%";
            }, 0);
            var star = args.star || 0;
            if (star > 3) star = 3;
            var buttonNext = args.buttonState || "restart";
            this.img.setAttribute("src", _coreConfigureManager2["default"].getConfig().gameData.skin.OverPanelMainIcon || imageRes.win);
            _coreHookManager2["default"].excuteHook("gameover", [star, this.img.getAttribute("src")], args.cb);
            this.evertStar(function (starImg, i) {
                if (i <= star - 1) {
                    starImg.src = imageRes.star;
                } else {
                    starImg.src = imageRes.starEmpty;
                }
            });
            this.btnWrap.innerHTML = "";
            this.buttonLayout = _coreConfigureManager2["default"].getConfig().gameData.buttonLayout;
            if (!Array.isArray(this.buttonLayout)) {
                this.buttonLayout = [];
            }
            if (this.buttonLayout.length > 2) this.buttonLayout.length = 2;
            this.buttonLayout.map(function (btn) {
                if (btn === "restart") {
                    return buttonNext;
                }
                return btn;
            }).forEach(function (btn) {
                if (btn in _this.btnRes) {
                    _this.btnWrap.appendChild(_this.btnRes[btn]);
                }
            });
            if (this.buttonLayout.length >= 3) {
                this.btnWrap.style.bottom = "-15%";
            } else {
                this.btnWrap.style.bottom = "3%";
            }
        }
    }, {
        key: "update",
        value: function update() {
        }
    }]);
    return ComOverPanelStar;
})(_ComBase3["default"]);
var instance = new ComOverPanelStar();
window["meiriq"].lib.ComOverPanelStar = instance;
exports["default"] = instance;
module.exports = exports["default"];
},{"../../core/HookManager":9,"../../core/UIManager":10,"../../res/resource":13,"./../../core/ConfigureManager":8,"./../ComBase":14,"./../html/overpanelstar.jade":20,"./ButtonRes":15}],19:[function(require,module,exports){
var jade = require("jade/runtime");
module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (name, size) {
buf.push("<!--Created by tommyZZM on 2015/10/21.\n--><div><div" + (jade.attr("style", "z-index: 99;position:fixed;border-radius: 20px;top: 50%;left: 50%;background:#ffffff;"+size(), true, false)) + (jade.cls([name+" common-container"], [true])) + "><div style=\"text-align: center;margin-top: -15%;width: 100%;\" class=\"scoreWrap\"></div><div style=\"width:100%;text-align: center;position: relative;\" class=\"highscoreWrap\"><span style=\"font-family: SimHei;color:#565656;font-size: 1em;\" class=\"highscore\"></span></div><div style=\"width:100%;\"><span style=\"font-family: SimHei;color:#565656;font-size: 1em;\"></span></div><div style=\"position:relative;width:100%;margin-top: -5%;text-align: center;top: 6%;padding: 5px 0;height: 48%;\" class=\"imgWrap\"><img style=\"height:100%\"/></div><div style=\"text-align: center;position: absolute;bottom: 3%;width: 100%;\" class=\"btnWrap\"></div></div></div>");}.call(this,"name" in locals_for_with?locals_for_with.name:typeof name!=="undefined"?name:undefined,"size" in locals_for_with?locals_for_with.size:typeof size!=="undefined"?size:undefined));;return buf.join("");
};
},{"jade/runtime":2}],20:[function(require,module,exports){
var jade = require("jade/runtime");
module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (name, size, style) {
buf.push("<!--Created by tommyZZM on 2015/11/12.\n--><div>" + (((jade_interp = style) == null ? '' : jade_interp)) + "<div" + (jade.attr("style", "z-index: 99;position:fixed;border-radius: 20px;top: 50%;left: 50%;background:#ffffff;"+size(), true, false)) + (jade.cls([name+" common-container"], [true])) + "><div style=\"text-align: center;margin-top: -15%;width: 100%;\" class=\"stars-wrapper\"><div style=\"transform:rotate(-20deg);\" class=\"star\"><img class=\"star-bg\"/></div><div style=\"margin-top: -20px;\" class=\"star\"><img class=\"star-bg\"/></div><div style=\"transform:rotate(20deg);\" class=\"star\"><img class=\"star-bg\"/></div></div><div style=\"width:100%;text-align: center;position: absolute;\" class=\"exinfoWrap\"><span style=\"font-family: SimHei;color:#565656;font-size: 1em;\" class=\"exinfo\"></span></div><div style=\"width:100%;\"><span style=\"font-family: SimHei;color:#565656;font-size: 1em;\"></span></div><div style=\"position:relative;width:100%;margin-top: -5%;text-align: center;top: 1%;padding: 10px 0;height: 50%;\" class=\"imgWrap\"><img style=\"height:100%\"/></div><div style=\"text-align: center;position: absolute;bottom: 3%;width: 100%;\" class=\"btnWrap\"></div></div></div>");}.call(this,"name" in locals_for_with?locals_for_with.name:typeof name!=="undefined"?name:undefined,"size" in locals_for_with?locals_for_with.size:typeof size!=="undefined"?size:undefined,"style" in locals_for_with?locals_for_with.style:typeof style!=="undefined"?style:undefined));;return buf.join("");
};
},{"jade/runtime":2}],21:[function(require,module,exports){
/* Created by tommyZZM on 2015/10/19.*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var _srcMain = require("./../src/Main");
var _srcMain2 = _interopRequireDefault(_srcMain);
;
;
cr.plugins_['MeiriqCommon_v2'] = _srcMain2["default"];
},{"./../src/Main":7}]},{},[21]);
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {
	module.exports = __webpack_require__(1);
/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/19.*/
;
;
	if (!window["meiriq"]) {
	    console.error("需要依赖::MeiriqCommon_v2");
	}
	cr.plugins_['MeiriqTvCommon_v2'] = __webpack_require__(2);
/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/19.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	var _Action = __webpack_require__(3);
	var _Action2 = _interopRequireDefault(_Action);
	var _Conditions = __webpack_require__(27);
	var _Conditions2 = _interopRequireDefault(_Conditions);
	var _Expressions = __webpack_require__(28);
	var _Expressions2 = _interopRequireDefault(_Expressions);
	var _coreConfigureManager = __webpack_require__(8);
	var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
	var _coreUIManager = __webpack_require__(5);
	var _coreUIManager2 = _interopRequireDefault(_coreUIManager);
	var plugProtoInstance;
	var Plugin = function Plugin(runtime) {
	    this.runtime = runtime;
	};
	var pluginProto = Plugin.prototype;
	pluginProto.Type = function (plugin) {
	    this.plugin = plugin;
	    this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function () {};
	pluginProto.Instance = function (type) {
	    this.type = type;
	    this.runtime = type.runtime;
	    Plugin.prototype.cnds.activeListeners(this.runtime, this);
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onCreate = function () {
	};
	instanceProto.draw = function (ctx) {};
	instanceProto.drawGL = function (glw) {};
	Plugin.prototype.acts = new _Action2["default"]();
	Plugin.prototype.cnds = new _Conditions2["default"]();
	Plugin.prototype.exps = new _Expressions2["default"]();
	exports["default"] = Plugin;
	if (window.NativeInterface && typeof window.NativeInterface.starGame === "function") {
	    window.NativeInterface.starGame();
	}
	meiriq.CommonComponent.config = {
	    hook: {
	        cb_tvexitgame: function cb_tvexitgame() {
	            if (typeof window["NativeInterface"] !== "undefined") {
	                if (typeof window["NativeInterface"]["exitGame"] === "function") {
	                    window["NativeInterface"]["exitGame"]();
	                }
	            }
	        }
	    }
	};
	module.exports = exports["default"];
/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/19.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	var _coreHookManager = __webpack_require__(4);
	var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
	var _coreUIManager = __webpack_require__(5);
	var _coreUIManager2 = _interopRequireDefault(_coreUIManager);
	var _resDefineJs = __webpack_require__(6);
	var define = _interopRequireWildcard(_resDefineJs);
	var Action = (function () {
	    function Action() {
	        _classCallCheck(this, Action);
	    }
	    _createClass(Action, [{
	        key: "showCurtainMask",
	        value: function showCurtainMask(img) {
	            _coreUIManager2["default"].showPausePanel(img);
	        }
	    }, {
	        key: "hideCurtainMask",
	        value: function hideCurtainMask() {
	            _coreUIManager2["default"].closePausePanel();
	        }
	        /**
	         * 游戏结束
	         * @param score
	         */
	    }, {
	        key: "gameOver",
	        value: function gameOver(score) {
	            _coreUIManager2["default"].enterGameOverStateWithAdv({ score: score });
	        }
	        /**
	         * 离开游戏
	         */
	    }, {
	        key: "tvExitGame",
	        value: function tvExitGame() {
	            console.log("tvExitGame");
	            _coreHookManager2["default"].excuteHook("tvExitGame");
	        }
	        /**
	         * 模拟按键按下
	         * @param checkKeyDefname
	         */
	    }, {
	        key: "simulateControlDown",
	        value: function simulateControlDown(checkKeyDefname) {
	            var keys = checkKeyDefname.split("&");
	            window["onMeiriqTVKeyDown"](define.KeyCode[keys[0].toUpperCase()], -1);
	        }
	        /**
	         * 模拟按键弹起
	         * @param checkKeyDefname
	         */
	    }, {
	        key: "simulateControlUp",
	        value: function simulateControlUp(checkKeyDefname) {
	            var keys = checkKeyDefname.split("&");
	            window["onMeiriqTVKeyUp"](define.KeyCode[keys[0].toUpperCase()], -1);
	        }
	    }]);
	    return Action;
	})();
	exports["default"] = Action;
	module.exports = exports["default"];
/***/ },
/* 4 */
/***/ function(module, exports) {
	/* Created by tommyZZM on 2015/10/20.*/
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var HookManager = window["meiriq"].lib.HookManager;
	exports["default"] = HookManager;
	module.exports = exports["default"];
/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/21.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	var _resDefineJs = __webpack_require__(6);
	var define = _interopRequireWildcard(_resDefineJs);
	var _resDataRepositoryJs = __webpack_require__(7);
	var data = _interopRequireWildcard(_resDataRepositoryJs);
	var _HookManager = __webpack_require__(4);
	var _HookManager2 = _interopRequireDefault(_HookManager);
	var _ConfigureManager = __webpack_require__(8);
	var _ConfigureManager2 = _interopRequireDefault(_ConfigureManager);
	var _uiComBase = __webpack_require__(9);
	var _uiComBase2 = _interopRequireDefault(_uiComBase);
	var _uiComComAdvListKit = __webpack_require__(10);
	var _uiComComAdvListKit2 = _interopRequireDefault(_uiComComAdvListKit);
	var _uiComComFocusUsKit = __webpack_require__(19);
	var _uiComComFocusUsKit2 = _interopRequireDefault(_uiComComFocusUsKit);
	var _uiComComFinger = __webpack_require__(21);
	var _uiComComFinger2 = _interopRequireDefault(_uiComComFinger);
	var _uiComComAdvMask = __webpack_require__(23);
	var _uiComComAdvMask2 = _interopRequireDefault(_uiComComAdvMask);
	var _uiComComLBTipsPanel = __webpack_require__(24);
	var _uiComComLBTipsPanel2 = _interopRequireDefault(_uiComComLBTipsPanel);
	var _libFn_html = __webpack_require__(15);
	var fn_html = _interopRequireWildcard(_libFn_html);
	var _TVKeyEventManager = __webpack_require__(12);
	var _TVKeyEventManager2 = _interopRequireDefault(_TVKeyEventManager);
	var _uiComComTvPausePanel = __webpack_require__(25);
	var _uiComComTvPausePanel2 = _interopRequireDefault(_uiComComTvPausePanel);
	var ComOverPanel = window["meiriq"].lib.ComOverPanel;
	var UIManager = window["meiriq"].lib.UIManager;
	UIManager.once("domready", (function () {
	    var _this = this;
	    console.log("domready");
	    this.shouldShowArray = _ConfigureManager2["default"].getConfig().tvData.adRate;
	    console.log(this.shouldShowArray);
	    this.shouldShowCheck = 0;
	    this.LayerShowState = "";
	    _HookManager2["default"].addListener(_HookManager2["default"].HookExcute, function (hook) {
	        if (hook === "restart") {
	            _this.fingerPointToEle = null;
	            setTimeout(function () {
	                _this.removeCommonFromView(_uiComComAdvListKit2["default"].nameC);
	                _this.removeCommonFromView(_uiComComFocusUsKit2["default"].name);
	                _this.removeCommonFromView(_uiComComFinger2["default"].name);
	                _this.removeCommonFromView(_uiComComAdvMask2["default"].nameC);
	                _this.isOverState = false;
	                _this.isPreventKeyEventToGame = false;
	                _this.closePausePanel();
	                _this.lastFingerState = function () {};
	            }, 200);
	        }
	    });
	    /**
	     * 电视组件交互
	     * 根据不同的面板显示状态响应具体交互
	     */
	    _TVKeyEventManager2["default"].addListener(define.KeyEventType.DOWN, function (keycode, device) {
	        var over2restart = function over2restart() {
	            if (!_this.isOverOnly && _this.shouldShowArray[_this.shouldShowCheck] === 1 && _ConfigureManager2["default"].getConfig().tvData.showAdvertising && data.advertisingBig().length > 0) {
	                _this.LayerShowState = "advmask";
	                _this.isPreventKeyEventToGame = true;
	                _this.addCommonToView(_uiComComAdvMask2["default"].nameC);
	                _this.getACommon(_uiComComAdvMask2["default"].nameC).active();
	                _HookManager2["default"].excuteHook("tv:st:bigadshow");
	            } else {
	                setTimeout(function () {
	                    _HookManager2["default"].excuteHook("restart");
	                    _this.isPreventKeyEventToGame = false;
	                }, 230);
	            }
	            _this.shouldShowCheck++;
	            console.log(_this.shouldShowCheck);
	            console.log(_this.shouldShowArray[_this.shouldShowCheck]);
	        };
	        if (_this.isOverState) {
	            /** 正常结束页面 **/
	            switch (_this.LayerShowState) {
	                case "over":
	                    {
	                        switch (keycode) {
	                            case define.KeyCode.A:
	                            case define.KeyCode.CONFIRM:
	                            case define.KeyCode.CONFIRM_OLD:
	                                {
	                                    over2restart();
	                                    break;
	                                }
	                            case define.KeyCode.B:
	                            case define.KeyCode.BACK:
	                                {
	                                    _this.showPausePanel();
	                                    break;
	                                }
	                            default:
	                                {
	                                    break;
	                                }
	                        }
	                        break;
	                    }
	                case "advmask":
	                    {
	                        switch (keycode) {
	                            case define.KeyCode.A:
	                            case define.KeyCode.CONFIRM:
	                            case define.KeyCode.CONFIRM_OLD:
	                                {
	                                    _this.getACommon(_uiComComAdvMask2["default"].nameC).enter().then(function (img) {
	                                        _this.LayerShowState = "over";
	                                        _this.shouldShowCheck = 100;
	                                        _this.getACommon(_uiComComLBTipsPanel2["default"].name).pushMsg({ img: img, msg: "下载安装中...请稍候..." });
	                                        over2restart();
	                                        _HookManager2["default"].excuteHook("tv:st:bigadconfirm");
	                                    });
	                                    break;
	                                }
	                            case define.KeyCode.B:
	                            case define.KeyCode.BACK:
	                                {
	                                    _this.getACommon(_uiComComAdvMask2["default"].nameC).disactive(function () {
	                                        _this.LayerShowState = "over";
	                                        _this.removeCommonFromView(_uiComComAdvMask2["default"].nameC);
	                                    });
	                                    break;
	                                }
	                        }
	                        break;
	                    }
	            }
	        }
	        /**广告面板**/
	        if (_this.isShowingAd) {
	            if (_this.LayerShowState === "advlist") {
	                switch (keycode) {
	                    case define.KeyCode.UP:
	                        {
	                            _this.updateFingerToElement(_this.getACommon(_uiComComAdvListKit2["default"].nameC).selectItem(1));
	                            break;
	                        }
	                    case define.KeyCode.DOWN:
	                        {
	                            _this.updateFingerToElement(_this.getACommon(_uiComComAdvListKit2["default"].nameC).selectItem(-1));
	                            break;
	                        }
	                    case define.KeyCode.A:
	                    case define.KeyCode.CONFIRM_OLD:
	                    case define.KeyCode.CONFIRM:
	                        {
	                            if (_this.getACommon(_uiComComAdvListKit2["default"].nameC).items.length <= 0) {
	                                over2restart();
	                                break;
	                            }
	                            _this.getACommon(_uiComComAdvListKit2["default"].nameC).enterItem().then(function (img, length) {
	                                _HookManager2["default"].excuteHook("tv:st:listadconfirm");
	                                _this.updateFingerToElement(_this.getACommon(_uiComComAdvListKit2["default"].nameC).selectItem(1));
	                                _this.getACommon(_uiComComLBTipsPanel2["default"].name).pushMsg({ img: img, msg: "下载安装中...请稍候..." });
	                                if (length <= 0) {
	                                    _this.LayerShowState = "over";
	                                    _this.getACommon(_uiComComAdvListKit2["default"].nameC).disactive();
	                                    _this.updateFingerToElement(_this.getACommon(ComOverPanel.name).getButton("restart"));
	                                }
	                            });
	                            break;
	                        }
	                    case define.KeyCode.MENU:
	                    case define.KeyCode.BACK:
	                    case define.KeyCode.B:
	                        {
	                            _this.getACommon(_uiComComAdvListKit2["default"].nameC).disactive();
	                            _this.getACommon(_uiComComFocusUsKit2["default"].name).disactive();
	                            setTimeout(function () {
	                                _this.lastFingerState();
	                            }, 10);
	                            break;
	                        }
	                }
	                return;
	            }
	            if (!_this.isOverOnly && _this.LayerShowState === "over" && _ConfigureManager2["default"].getConfig().tvData.showAdvertising) {
	                switch (keycode) {
	                    case define.KeyCode.MENU:
	                        {
	                            _HookManager2["default"].excuteHook("tv:st:listadshow");
	                            _this.LayerShowState = "advlist";
	                            _this.getACommon(_uiComComAdvListKit2["default"].nameC).acitve();
	                            _this.getACommon(_uiComComFocusUsKit2["default"].name).acitve();
	                            _this.updateFingerToElement(_this.getACommon(_uiComComAdvListKit2["default"].nameC).selectItem());
	                            _this.isPreventKeyEventToGame = true;
	                            _this.lastFingerState = function () {
	                                _this.updateFingerToElement(_this.getACommon(ComOverPanel.name).getButton("restart"));
	                                _this.getACommon(_uiComComFinger2["default"].name).setStyle(1.1, 0.3);
	                                setTimeout(function () {
	                                    _this.LayerShowState = "over";
	                                }, 10);
	                            };
	                            break;
	                        }
	                }
	                return;
	            }
	            if (_this.LayerShowState === "pausemaskpanel" && _ConfigureManager2["default"].getConfig().tvData.enPauseAdvertising && _ConfigureManager2["default"].getConfig().tvData.showAdvertising) {
	                switch (keycode) {
	                    case define.KeyCode.MENU:
	                        {
	                            _this.LayerShowState = "advlist";
	                            _this.getACommon(_uiComComAdvListKit2["default"].nameC).acitve();
	                            _this.getACommon(_uiComComFocusUsKit2["default"].name).acitve();
	                            _this.updateFingerToElement(_this.getACommon(_uiComComAdvListKit2["default"].nameC).selectItem());
	                            _this.getACommon(_uiComComFinger2["default"].name).setStyle(1.1, 0.3);
	                            _this.isPreventKeyEventToGame = true;
	                            _this.lastFingerState = function () {
	                                _HookManager2["default"].excuteHook("tv:st:listadshow");
	                                setTimeout(function () {
	                                    _this.LayerShowState = "pausemaskpanel";
	                                }, 10);
	                                _this.updateFingerToElement(_this.getACommon(_uiComComTvPausePanel2["default"].name).selectItem(0));
	                                _this.getACommon(_uiComComFinger2["default"].name).setStyle(0.5, 1, "-webkit-transform: rotate(90deg);");
	                            };
	                            break;
	                        }
	                }
	            }
	            if (_this.LayerShowState === "pausemaskpanel" && !_ConfigureManager2["default"].getConfig().tvData.enPauseAdvertising && _ConfigureManager2["default"].getConfig().tvData.showAdvertising) {
	                setTimeout(function () {
	                    _this.removeCommonFromView(_uiComComFinger2["default"].name);
	                    _this.hideAdUIGroup();
	                }, 10);
	            }
	        }
	        /**暂停面板**/
	        if (_this.LayerShowState === "pausemaskpanel") {
	            switch (keycode) {
	                case define.KeyCode.RIGHT:
	                    {
	                        _this.updateFingerToElement(_this.getACommon(_uiComComTvPausePanel2["default"].name).selectItem(1));
	                        break;
	                    }
	                case define.KeyCode.LEFT:
	                    {
	                        _this.updateFingerToElement(_this.getACommon(_uiComComTvPausePanel2["default"].name).selectItem(-1));
	                        break;
	                    }
	                case define.KeyCode.A:
	                case define.KeyCode.CONFIRM_OLD:
	                case define.KeyCode.CONFIRM:
	                    {
	                        _this.getACommon(_uiComComTvPausePanel2["default"].name).enterItem();
	                        if (!_ConfigureManager2["default"].getConfig().tvData.enPauseAdvertising && !_this.isOverOnly && _this.isOverState) {
	                            _this.showAdUIGroup();
	                        }
	                        break;
	                    }
	                case define.KeyCode.B:
	                case define.KeyCode.BACK:
	                    {
	                        break;
	                    }
	                default:
	                    {
	                        break;
	                    }
	            }
	        }
	    });
	    _TVKeyEventManager2["default"].addListener(define.KeyEventType.DOWN, function (keycode, device) {
	        if (UIManager.LayerShowState === "over") {
	            switch (keycode) {
	                case define.KeyCode.A:
	                case define.KeyCode.CONFIRM:
	                case define.KeyCode.CONFIRM_OLD:
	                    {
	                        ComOverPanel.lastDownKey = keycode;
	                        ComOverPanel.btnRes["restart"].down();
	                        break;
	                    }
	                default:
	                    {
	                        break;
	                    }
	            }
	        }
	    });
	    _TVKeyEventManager2["default"].addListener(define.KeyEventType.UP, function (keycode, device) {
	        if (keycode === ComOverPanel.lastDownKey) {
	            ComOverPanel.btnRes["restart"].up();
	        }
	    });
	    this.registerACommon(_uiComComFinger2["default"].name, _uiComComFinger2["default"]);
	    this.registerACommon(_uiComComTvPausePanel2["default"].name, _uiComComTvPausePanel2["default"]);
	    if (_ConfigureManager2["default"].getConfig().tvData.showAdvertising) {
	        data.onlistDataReady(function () {
	            _this.registerACommon(_uiComComAdvListKit2["default"].nameC, new _uiComComAdvListKit2["default"]());
	            _this.registerACommon(_uiComComFocusUsKit2["default"].name, _uiComComFocusUsKit2["default"]);
	            _this.registerACommon(_uiComComAdvMask2["default"].nameC, new _uiComComAdvMask2["default"]());
	            _this.registerACommon(_uiComComLBTipsPanel2["default"].name, _uiComComLBTipsPanel2["default"]);
	            _this.addCommonToView(_uiComComLBTipsPanel2["default"].name);
	        });
	    }
	}).bind(UIManager));
	UIManager.addListener("clear", function () {
	    this.fingerPointToEle = null;
	}, undefined);
	UIManager.isPreventKeyEventToGame = false;
	UIManager.showPausePanel = (function (img) {
	    if (UIManager.LayerShowState !== "pausemaskpanel") {
	        window["meiriq"].CommonComponent["?config"].tvData.isPausing = true;
	        this.isPreventKeyEventToGame = true;
	        this.addCommonToView(_uiComComFinger2["default"].name);
	        UIManager.addCommonToView("pausemaskpanel");
	        UIManager.getACommon("pausemaskpanel").active(img);
	        this.updateFingerToElement(this.getACommon(_uiComComTvPausePanel2["default"].name).selectItem());
	        this.getACommon(_uiComComFinger2["default"].name).setStyle(0.5, 1, "-webkit-transform: rotate(90deg);");
	        UIManager.LastLayerShowState = "over";
	        UIManager.LayerShowState = "pausemaskpanel";
	        if (_ConfigureManager2["default"].getConfig().tvData.enPauseAdvertising) {
	            this.showAdUIGroup();
	        } else {
	            this.hideAdUIGroup();
	        }
	    }
	    if (!this.isEveryTickUpdateFinger) {
	        this._everyTickUpdateFinger();
	        this.isEveryTickUpdateFinger = true;
	    }
	}).bind(UIManager);
	UIManager.closePausePanel = (function () {
	    if (UIManager.LayerShowState === "pausemaskpanel") {
	        window["meiriq"].CommonComponent["?config"].tvData.isPausing = false;
	        UIManager.removeCommonFromView("pausemaskpanel");
	        UIManager.LayerShowState = "over";
	        if (this.isOverState) {
	            this.getACommon(_uiComComFinger2["default"].name).setStyle(1.1, 0.3);
	            this.updateFingerToElement(this.getACommon(ComOverPanel.name).getButton("restart"));
	        } else {
	            this.isPreventKeyEventToGame = false;
	            this.removeCommonFromView(_uiComComFinger2["default"].name);
	            this.hideAdUIGroup();
	        }
	    }
	}).bind(UIManager);
	UIManager.enterGameOverStateOrigin = UIManager.enterGameOverState;
	UIManager.enterGameOverState = (function () {
	    var $data = arguments.length <= 0 || arguments[0] === undefined ? { score: 0 } : arguments[0];
	    UIManager.enterGameOverStateOrigin($data);
	    this.isOverState = true;
	    this.isOverOnly = true;
	    this.LayerShowState = "over";
	    this.addCommonToView(_uiComComFinger2["default"].name);
	    this.updateFingerToElement(this.getACommon(ComOverPanel.name).getButton("restart"));
	    this.getACommon(_uiComComFinger2["default"].name).setStyle(1.1, 0.3);
	    if (!this.isEveryTickUpdateFinger) {
	        this._everyTickUpdateFinger();
	        this.isEveryTickUpdateFinger = true;
	    }
	}).bind(UIManager);
	UIManager.enterGameOverStateWithAdv = (function () {
	    var $data = arguments.length <= 0 || arguments[0] === undefined ? { score: 0 } : arguments[0];
	    UIManager.enterGameOverState($data);
	    this.isOverOnly = !this.showAdUIGroup();
	}).bind(UIManager);
	UIManager.showAdUIGroup = (function () {
	    if (!_ConfigureManager2["default"].getConfig().tvData.showAdvertising || !data.isDataReady) {
	        console.log("return");
	        this.isShowingAd = false;
	        return false;
	    }
	    this.addCommonToView(_uiComComAdvListKit2["default"].nameC);
	    this.getACommon(_uiComComAdvListKit2["default"].nameC).disactive();
	    this.addCommonToView(_uiComComFocusUsKit2["default"].name);
	    this.getACommon(_uiComComFocusUsKit2["default"].name).disactive();
	    this.isShowingAd = true;
	    return true;
	}).bind(UIManager);
	UIManager.hideAdUIGroup = (function () {
	    this.removeCommonFromView(_uiComComAdvListKit2["default"].nameC);
	    this.removeCommonFromView(_uiComComFocusUsKit2["default"].name);
	    this.isShowingAd = false;
	}).bind(UIManager);
	UIManager.updateFingerToElement = (function (ele) {
	    this.fingerPointToEle = ele;
	}).bind(UIManager);
	UIManager._everyTickUpdateFinger = (function () {
	    var finger = this.getACommon(_uiComComFinger2["default"].name);
	    if (this.fingerPointToEle) {
	        var pos = fn_html.getElementAbsolute(this.fingerPointToEle);
	        finger.update({ left: pos.left, top: pos.top });
	        finger.fingerImg.style.marginTop = +this.fingerPointToEle.offsetHeight * finger.offsetPos.y - 10 + "px";
	        finger.fingerImg.style.marginLeft = +this.fingerPointToEle.offsetWidth * finger.offsetPos.x - 38 + "px";
	    } else {
	        finger.update({ left: -100, top: -100 });
	    }
	    if (typeof requestAnimationFrame !== "function") return;
	    requestAnimationFrame(this._everyTickUpdateFinger.bind(this));
	}).bind(UIManager);
	exports["default"] = UIManager;
	module.exports = exports["default"];
/***/ },
/* 6 */
/***/ function(module, exports) {
	/* Created by tommyZZM on 2015/10/20.*/
	/**
	 * 按键相关
	 */
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var KeyCode = {
	    BACK: 4, //（返回键）
	    POWER: 26, //（电源键）
	    CONFIRM: 23, //（确认键）
	    CONFIRM_OLD: 66, //（旧版本盒子确认键【需要注意兼容】）
	    DOWN: 20, //（向下）
	    LEFT: 21, //（向左）
	    RIGHT: 22, //（向右）
	    UP: 19, //（向上）
	    VOLUME_DOWN: 25, //（音量-）
	    VOLUME_UP: 24, //（音量+）
	    MENU: 82, //（菜单）
	    HOME: 3, //(房子键)
	    A: 96, //（A键）【一般充当确认键操作】
	    B: 97, //（B键）【一般充当返回操作】
	    V: 99, //（X键）【小游戏中比较少用】
	    D: 100 //（Y键）【小游戏中较少用】
	};
	exports.KeyCode = KeyCode;
	var KeyCode2Name = {};
	exports.KeyCode2Name = KeyCode2Name;
	for (var keyname in KeyCode) {
	    var result = keyname.toLowerCase();
	    if (keyname === "CONFIRM_OLD") result = "confirm";
	    if (keyname === "A") result = "confirm";
	    KeyCode2Name[KeyCode[keyname]] = result;
	}
	var KeyCodeUsualDef = {
	    Back: "Back&B",
	    Confirm: "Confirm&Confirm_old&A",
	    Home: "Home",
	    Menu: "Menu",
	    Up: "Up",
	    Left: "Left",
	    Down: "Down",
	    Right: "Right"
	};
	exports.KeyCodeUsualDef = KeyCodeUsualDef;
	var KeyCodeUsualDefArr = (function () {
	    var result = [];
	    for (var keydef in KeyCodeUsualDef) {
	        result.push(KeyCodeUsualDef[keydef].toLowerCase());
	    }
	    return result;
	})();
	exports.KeyCodeUsualDefArr = KeyCodeUsualDefArr;
	var KeyEventType = {
	    DOWN: "down",
	    UP: "up"
	};
	exports.KeyEventType = KeyEventType;
	var KeyState = {
	    RELEASED: "released",
	    TOUCHING: "touching"
	};
	exports.KeyState = KeyState;
	var DeviceIdentity = -1;
	exports.DeviceIdentity = DeviceIdentity;
/***/ },
/* 7 */
/***/ function(module, exports) {
	/* Created by tommyZZM on 2015/10/22.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var virtualDebugData = [{ "picture": "http://meiriq-static.b0.upaiyun.com/gameslibrary/storage/uploads/20151022/82dcf0a2.png", "channel": "znds", "link": "http://meiriq-static.b0.upaiyun.com/static/TV/ad_1.0/penguin_v1.1.1_2015-10-07_advertise.apk", "summary": "chaping1", "name": "com.meiriq.game.androidtv.penguin", "type": 1 }, { "picture": "http://meiriq-static.b0.upaiyun.com/gameslibrary/storage/uploads/20151021/1e2728b2.png", "channel": "znds", "link": "http://meiriq-static.b0.upaiyun.com/static/TV/ad_1.0/third_app/dangbeishichang.apk", "summary": "tuijian1", "name": "com.tv.zhuangjibibei", "type": 0 }, { "picture": "http://meiriq-static.b0.upaiyun.com/gameslibrary/storage/uploads/20151021/08e0692a.png", "channel": "znds", "link": "http://meiriq-static.b0.upaiyun.com/static/TV/ad_1.0/PandaOne_v1.0.1_2015-10-07_advertise.apk", "summary": "tuijian2", "name": "com.meiriq.game.androidtv.pandaone", "type": 0 }, { "picture": "http://meiriq-static.b0.upaiyun.com/gameslibrary/storage/uploads/20151021/ed764283.png", "channel": "znds", "link": "http://meiriq-static.b0.upaiyun.com/static/TV/ad_1.0/flashingman_v1.0.1_2015-10-07_advertise.apk", "summary": "tuijian3", "name": "com.meiriq.game.androidtv.flashingman", "type": 0 }];
	virtualDebugData = [];
	var advertisingData = [];
	exports.advertisingData = advertisingData;
	var isDataReady = false;
	exports.isDataReady = isDataReady;
	window["setMeiriqAdvListData"] = function (data) {
	    exports.advertisingData = advertisingData = (function () {
	        var result = virtualDebugData;
	        try {
	            result = JSON.parse(data);
	        } catch (e) {
	            alert(e, data);
	        } finally {}
	        return result;
	    })();
	    _onlistDataReady(advertisingData);
	    exports.isDataReady = isDataReady = true;
	};
	var _onlistDataReady = function _onlistDataReady() {};
	var onlistDataReady = function onlistDataReady(cb) {
	    if (typeof cb === "function") {
	        _onlistDataReady = cb;
	    }
	};
	exports.onlistDataReady = onlistDataReady;
	var advertisingList = function advertisingList() {
	    return advertisingData.filter(function (ele) {
	        return +ele.type === 0;
	    });
	};
	exports.advertisingList = advertisingList;
	var advertisingBig = function advertisingBig() {
	    return advertisingData.filter(function (ele) {
	        return +ele.type === 1;
	    });
	};
	exports.advertisingBig = advertisingBig;
/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/21.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	var _HookManager = __webpack_require__(4);
	var _HookManager2 = _interopRequireDefault(_HookManager);
	var ConfigureManager = window["meiriq"].CommonComponent;
	ConfigureManager["?config"].tvData = {
	    showAdvertising: true,
	    isPausing: false,
	    enPauseAdvertising: false,
	    adRate: [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0]
	};
	exports["default"] = {
	    getConfig: function getConfig() {
	        return ConfigureManager["?config"];
	    }
	};
	module.exports = exports["default"];
/***/ },
/* 9 */
/***/ function(module, exports) {
	/* Created by tommyZZM on 2015/10/21.*/
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var ComBase = window["meiriq"].lib.ComBase;
	exports["default"] = ComBase;
	module.exports = exports["default"];
/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/22.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	var _resDefine = __webpack_require__(6);
	var define = _interopRequireWildcard(_resDefine);
	var _resResource = __webpack_require__(11);
	var resource = _interopRequireWildcard(_resResource);
	var _resDataRepository = __webpack_require__(7);
	var _coreTVKeyEventManager = __webpack_require__(12);
	var _coreTVKeyEventManager2 = _interopRequireDefault(_coreTVKeyEventManager);
	var _coreHookManager = __webpack_require__(4);
	var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
	var _ComBase2 = __webpack_require__(9);
	var _ComBase3 = _interopRequireDefault(_ComBase2);
	var _libFn_html = __webpack_require__(15);
	var fn_html = _interopRequireWildcard(_libFn_html);
	var imageRes = __webpack_require__(11).imageRes;
	var ComAdvListKit = (function (_ComBase) {
	    _inherits(ComAdvListKit, _ComBase);
	    function ComAdvListKit(data) {
	        _classCallCheck(this, ComAdvListKit);
	        _get(Object.getPrototypeOf(ComAdvListKit.prototype), "constructor", this).call(this, __webpack_require__(16), {
	            style: "<style rel=\"stylesheet\" scoped=\"scoped\">\n            .advlistkit.common-container{\n                top: -280px;\n                -webkit-transition: 0.82s;\n            }\n            .advlistkit .item{\n                border-radius: 5px;\n                width: 240px;\n                height: 80px;\n                margin: 5px 10px;\n            }\n            .advlistkit .item img{\n                width: 100%;\n                height: 100%;\n            }\n            .advlistkit .tips-wrapper{\n                -webkit-transition: 0.6s;\n            }\n            .advlistkit .item.downloaded{\n                transition: 0.6s;\n                height: 0;\n                margin-top: 0;\n                margin-bottom: 0;\n                opacity: 0;\n            }\n            </style>",
	            data: (0, _resDataRepository.advertisingList)(),
	            tipsImage: resource.TVAdvRes.listPanelMore
	        }, "advlistkit");
	        this.container = this.content.querySelector(".common-container");
	        this.tips = this.content.querySelector(".tips");
	        this.tipsWrapper = this.content.querySelector(".tips-wrapper");
	        var items = this.content.querySelectorAll(".item");
	        this.items = [];
	        for (var i = 0; i < items.length; i++) {
	            this.items.push(items[i]);
	        }
	        this.items.reverse();
	        this.currSelectItem = 0;
	        this.disactivePosTop = 280;
	    }
	    _createClass(ComAdvListKit, [{
	        key: "acitve",
	        value: function acitve() {
	            if (this.items.length <= 0) return;
	            this.container.style.top = "0px";
	            this.tipsWrapper.style.top = "-16px";
	            this.tips.innerText = "按返回键收回";
	            this.isActive = true;
	        }
	    }, {
	        key: "disactive",
	        value: function disactive() {
	            this.container.style.top = "-" + this.disactivePosTop + "px";
	            this.tipsWrapper.style.top = "0px";
	            this.tips.innerText = "按菜单键有惊喜!";
	            this.isActive = false;
	        }
	    }, {
	        key: "selectItem",
	        value: function selectItem() {
	            var count = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            if (typeof count !== "number") count = 0;
	            this.currSelectItem += count;
	            if (this.currSelectItem > this.items.length - 1) {
	                this.currSelectItem = 0;
	            }
	            if (this.currSelectItem < 0) {
	                this.currSelectItem = this.items.length - 1;
	            }
	            return this.items[this.currSelectItem];
	        }
	    }, {
	        key: "enterItem",
	        value: function enterItem() {
	            var _this = this;
	            var item = this.items[this.currSelectItem];
	            item.setAttribute("class", "item downloaded");
	            if (window.NativeInterface && typeof window.NativeInterface.downloadApk === "function") {
	                window.NativeInterface.downloadApk(item.getAttribute("data-meiriq-adv"));
	            } else {
	                console.warn("try enter:", item.getAttribute("data-meiriq-adv"));
	            }
	            var _cb = function _cb() {};
	            setTimeout(function () {
	                _this.items.splice(_this.currSelectItem, 1);
	                _this.disactivePosTop -= 72;
	                if (_this.items.length <= 0) {
	                    _this.disactivePosTop = 280;
	                }
	                _cb(item.getElementsByTagName("img")[0].getAttribute("src"), _this.items.length);
	            }, 100);
	            return {
	                then: function then(cb) {
	                    if (typeof cb === "function") _cb = cb;
	                }
	            };
	        }
	    }, {
	        key: "didMount",
	        value: function didMount() {
	        }
	    }], [{
	        key: "nameC",
	        get: function get() {
	            return "advlistkit";
	        }
	    }]);
	    return ComAdvListKit;
	})(_ComBase3["default"]);
	exports["default"] = ComAdvListKit;
	module.exports = exports["default"];
/***/ },
/* 11 */
/***/ function(module, exports) {
	/* Created by tommyZZM on 2015/10/21.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var imageRes = {
	    resumeUp: "data:image/png;base64,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",
	    resumeDown: "data:image/png;base64,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",
	    exitUp: "data:image/png;base64,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",
	    exitDown: "data:image/png;base64,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",
	    backToMeunUp: "data:image/png;base64,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",
	    backToMeunDown: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABWCAMAAACNZji+AAACFlBMVEUAAAAAAAABAAAAAAAAAAC8VQifPgZxKQCYNwAAAACdOQCbOADZfC7YeS3bci7XdC7Ydi5tJwDbdC6vRQmsRwOhPAHHVhPFYhaZNwCaNwCYNwCTNQAAAADbeTf0ixngeBOeOQCdOQCcOACdOACaOACONACSNACDLwB7LADwhxm+UA/LczjTbA+4Swz7kRr////2cBr2chqqThn7jhr1bRr6ixr7kBr3dxr2bxr6iRr3eRr4fRr4gRr5hRr3cxr5ghr3dRr3dhr6jRr6jhr8vYT5iBrhmGD4fBr94tP5hBr4ehr5fxr4jET6iBr6jxr7wKH2bhr4jkT8wqH6pHP+5NP6p3P/+fT6hxr8xKH6pnP8xqH+8er7q3P7qnP7rXPOWxb9y6H5hyb+6t/+5dH91bv7pGL7v6H5jzj80rv6lSX8ya76kBr+49P9z6L7qHP8tGv5mmL5nWH7oUj4hTj6kCX4giX80Lv6kzr4iSX6kyT//Pn92sf9yJT5jSX2eiX+5cz8zK791Kz8wIn8toT7nU73fSWxUBjGWBf/9Or+6tb82cf7vqH8vpP7uZP6rYT6oGL6mU76ljj7mDP5iyD+8uX+7Nv+4cL927j7t5P6roT8rmL7p2L5kU35ijj6ky/+69/93sf6tZPyp2vpl1r7plT3fzL/9u/93Lz9zq78xZr9ypX8uXv7tXn7qV75nFbjh0fUZyP4j0aAfPJ4AAAALnRSTlMACgMHDtvaOjkRz5ry8vLy8hny4NTT+OdujX5gEP388ce8rZd3UUUxJvzt6+jnsp0ZeAAAC8VJREFUeNrsk1tqwzAQRZsOheCkHwaB0xbSQkofUPQj0AbyP/soWkHX0Q1XdzokE2MIeRFb+ESaGax83OPHzcjINbktgLZQ/T4dNh/WKo9vK3c3cFy1IDip0cI9+8GzbKoaTmI0dUtfAl+vWeZf6aGAZwSSq+GUN718+iKIzROJElH168ugedwo/fgyuF8RidKk+vZlMJ+JEo1KfWY+mwxQKZoxykZVoEQ9V0JiTa7R5UKbfijF3eBAg2tokz7EfYRwKSWEMtiYmDAeTJC8KOgYAmYOHVils7zXGhvrFIIU/NSAE2oLtjNrP1ApAjRTsI++73knlN1gUapMuLTWI1YH1rLGQW7bKdP1lBDUfphoSQYUA0J1k5L9iywOsMigsCxhE5NRpCt6+sdJ2bU2EURh+BcI/pNzIXsRyBIwLuwS1osQJyEbe1ESIloNBCEaU/qRXrRQaVOtgqL1oqgo/kff85Fk1s1a8c3uOWdmon3eM5OpY6autaEj4IOI5y4X/kLeUmlHrZNF3fHA7ysNqk3HwmgNMzdfkO0KGzF+e2zI0XyJo7uYucu6I9mz9FJOg0oonxglXp1c8mJBT/cKM995IzIybah+x0hslqNUUnPLlVfw8PAaijqCQteVXIogqKMMggDVWhj5lqyB+pobG2uJ/gmW1Ku+GbuBGjayLllPuYCkpcym3QUdj6RW3FXPbSlADAKdYWALpqIlyLck0EwkWfdaOQRUpby6qryQOrMSbDwhkHgU2qixKOIvqiUQCaaSalwjr5Y9S0WVW/JMSPBkA+0zcI0RlSBLts7mFCyzyOD/Rx8//n29UsGLBypaUm6FFGwpi8I0PsgCbn2UeeuvqtzCnK58ZnJHqwVX+DJRn3kFHpoTbWFUKShv6Tn/3HzkVfXyx96PlyjG76CRMAq+snxpbVZ/wcvfiwtdpewSecxbgERiTl4QeE+O6HQ9mmRER5US3fIsqYElLlvSbl+cENHJRRCMCHoa5JVRmfq8fEUFOXJG7mGzJSuxUOAc4J8NVqM+0ff8ehQhpOmfloLNGh8T63i82RLR1VFQ1CCjFrdajwsYJih8ZEtHjsq1vWbueqNTomwSpbDAQo7SNIokYHizpdGUiN7jnY5WluRQGy9RF5k/ebVgSQVubBk63WpNjC7SpO0vl2Nu7j7CKxy9SJhlx2BDRvq0McCozfFGSzP+nz8EHxzynljyudWSFgVLO/5BGcjZ6ud3iWkAw4kPHhKrQ4RZWRPS9mm2cQsHWIpUqNp4C5ak0d7xRv2ct+ft+OLgYvwWVZmlqDLp+uLN2FFLEY4FNilGTjNggxTIjGrkqRL1eA1QtjCcdzoDHuEZ0mZlUTvcoJylguRi2Ps8PsYv6fOeWbJfowicsIS0Tb766DEsIeLDJQ1SCDuxk7YZ2cgxECGdx/G5GBr0OrGTbelEYYgnhNu+4aK0ahhzeYOl3YKja74YDt6MpvJLenOglvSsSHe5wJ9OOW7Pt3pbrFNHMeZ3EJUX7PtyKtrA6ImXKJQEYghulsr1Zbj20fMsmTr/YilF6/UuTAVWrBxWZqSaVQ6JLfJSGy9TInM3LdqZVjOxRLAPHG0Ppds9YMQK09ZknDnFcb8z7zl8c6OlJEygMME/51SUb8luQXAItF4Mz7/RUt925ZKYCbgGsxRyDJeCGYusYUbkPOJz8yLJQGGg04M65M6SMAToPlFzSfwQ9UNVkwhR9IioVktqUIKYIJh8S3qqLe7qxbC49GguF3JJvN8NPamZEkv+Hji0v48z6FnShuNDlHF5RthQc+FQQKDGYLNqeRUtvQgj/T3yPbLQi+H6K/n6ei2XxMniHy0l8lN5yGgYIg4dElqNUhJaKw/qJnd7H5ZBNcx4vNQzokdN1SPMm2KiarWKZX5RcC0Tt31Lni7lYvg5pbymP+WSuAxZSeJbaias0OgtmmyIljfjfeYHhSYTrLqheTmr1YAbGyseWHqGxNAoJWO6aaWoKlJrZZbuEd2LnlJRT2XJY4UZizU7KaDHX5Fo0qHwqRdLGBrTa90W4CNjL9wnYZSAuQdV1QMio682uWygMNUamvOWEk+Hv5IZbdIs+XVYE3qFAYNGnx5wiIJrjeQhSv4IjCQFEqsZOVTs7BkW3JnQNXiRbb72LJker8oGvw3NKHxLv1kvl9W2gSgMv0ELfZFpVgU75AIBDfLCUGGB0CZJQQQvioyJszB0EegmIe7WgQSSZd6y/7nIZyR54pT6i3TOzMgh3z8eFdqkOSZZtHO3jfPjkMNepEMJQ1XPOJBICpS18cM/k8nk52TqSnR8P1y+T5jZITFDxKvxWN8lDHDRyMG/RztSxzUaafMqYsCRMEOllSaSBgPPS8/gZZHBlUXi9uDe4YEll24r0+FwOJIL94Z2JHFqdnsT6fbs7Ow2iCSJtHIkqnoIJMzomOsIR6XL4Rg3HiES+c68UTpw6Y0ZPgDdoigmE7rwq0XDbBgQiaT/YsgdfksXmF5sItnbSGIaBiaThtJ5PEEkPB2NdPGy+cBsBC8SRZPtHXEDj7kDJVxjFPidLSQJXwD1s0WCeJt4pBBEgmDpQpZYoUgCfHk6VJDFGrB1IV+Hq09FAD6SFVlRoNCV1UmPeCTssEWClkUatcELC+nZlTemz1DhDMbOSM8eYe6cW9OWzG3bvXuPNE2TtE0Yic5JSCQSHxUDkVD7xCPVfkm6HAkDYZ3j7NZYSzKM8rEup8njOGCBv9YiZQaDoIaR5EzzxVgkTIJIyu5ICYA11USmIaQPaJuTjL6LxTwd077Pl5iU67TNgJwz5wY7CCNdd6XetkZ60xdSKkdiZ8BNCTOkuDBFe8qw6TUrsr7AgcpHWNMaWlbSQjXv2qb/G+nm5YdwDdNrHb/cJG1wSqbjPlOHDA3zLLt0uc8d4+GGP41P0OCpusRaLv5Vo/xaOnD32tHtR/omV0AYSTZet7pPqvvNt7FwMSr8xfrO+/b/76ZVXUG2muaiZ1+IRlJWdw6wMFBrRELtE4tk4iED+hlQDZAVgFEWQx1B6X1VrbKa9hNuKycsBmDqFysSZuf7UHn+en9vs26kU1zcAQoN+pFIGrcqc6VbQN8NtLTAUJpEs6ciu7pf+AV8u9R+YZNTuhU1rvOSHwDKccLr6Cco2k++hJE+hGqhvhuJQN0FjLSKua33I53AmKsWNLAjklmKjw4kRyuSpvooao0ig1gk0WXjPmEkcISbOwbBFUb6LfvaivSP1kYzaQLIgGRO+byoDq8onUiwO4KtKgvoOrNIRwdHBwfyGB13O1IcsaKikqpt4jxTITS72ZDHFqnZ31PRA6Kr9lyaSAe0aM46MnhZajSS+XFrYnQiQYwKkIpuxzuMxL4mqU3XwkgqbeahNtCBlDifgkh2aLXZjqLGgQxXBaMYLMPbKQ03+p4JI+mOx7DXcae87TSr75+v+EHdSjuSOn8c8d2/sHYCNSa/M9KvrcZU1Fz7/oH2Hgkj/e3ebHYSBqIwGrSRuDKkaeU3UeJfNCbEdNEHIK5YjE8wKx/Al4CXcEXDjgC+oV/vve1gA+mgE5PhlN7pwOacSbfIe+0ePuwKjjJSWVK5K0l/gy2x0u0eo46Jex+WSSNxFlssrkUBeRpr+liRJPKgVKqSapKoUoTzEy6HqBtxK2exxk4lOXgCKXa4+Cs8/UhydODmyEnakoR0aXBCQpMsFSubQdBG9oZfJbGySFdebEt7clUpjARjJvqyMz/WoNSupMVufb5Y+nBzgClHzWcOFDb1qIqwJRedMulDXu4aUVXZM6JqHCxt3bN46hZJV/PVaI85HTAfN8DcNlYiaBZlZm2B+6LlZbtIuh6Ml6uvt0OZTHiRMQGYOZj/zuf7eB7elknxenwEzDcmaRjrzTp79ZosG2gd3hX/jGk/a61n0xePmc40iFpFUiuKjyIpvMF7h6S8qRc9+p8Uh92GSWo0O9GZ50TDXrCdFASt+6bfPARchKSiKeife0y/L0VIkiZEeU4DRZzETYjynlMp4iQ0AX/DxP6Eir4B9TCAJgryqG4AAAAASUVORK5CYII=",
	    adReceiveUp: "data:image/png;base64,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",
	    adReceiveDown: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABWCAMAAACNZji+AAACK1BMVEUAAAAAAAAAAAAAAQEvaZw4iLkAAAEgR2kvaZwuaJovaZ0AAABSqdRQoNlQpNMwap5Qn9JBltktZpgzdagiTHJBlsg2erIuaZstZZcrYZEhSm1esuo7isBEst1CqNU5gLz///9LyfI7muYwa588nudKx/JJxfFIwfA9oOhJw/FDsu07nOdCsOxAq+tBrOtHv/BGuu9AqOo+pOmW5f9FuO5fuPA+o+l0vN89ouhEtO1Gve88neZDtOxBrus/p+pFue5Etu0+pulHvO48n+hLxvJHvO+y3Pb3+/5IwfGz4Pjc8Puy3feDy/La7Ppjsuzt9v3H4/iy3vfS7fvR5/mAwPDk9P3k8fux2vY8nuZFneOw1vWQ1fXg9P3b7vuE0vRSyvPv+v7H5/m83vd2yfJHquv7/v/y+/5zvu9NuO5GpOo8n+dQxfFXwvFOwPDu9/2d1vV4zvSZy/KCx/Jxue5Kr+zE5/mL0fRWvu/N7ft80vWW0PSQz/RZy/Now/H9/v/5/f7r+f7m9f3I6vqc0fNXxvFkue5KtO1SrutQq+rN5vm95fmM3PnB4viz4vin3Ped2faB2faG1PZu0vWl0POBxPGMxPBlvu9VuO5ZrOvb8vzb7/u/5vmn1PWOyvJ1xPFTsuxIruxNpuhDoejU8fy66fqp4PiFzvNqy/Nnv/Cz6Pqj4/ic4Ph11PVfz/SDzPN/ve8/j9A1dq4zc6rW6/qu5vljy/OHxfF3uu6V2/ZdwtnjAAAAIHRSTlMAEhYIN9oEPtqa0A7y8vLN8vxx1R/p3biHVzr95fLv4lGcQW0AAArhSURBVHja7JbLa1NBFMaFakARBd+CysnChGZjF24qhZQQe3NjRXslbhLTRzAUmqalUNvSVGstLlrsa9FSqytb63ul4J/nNzN3MnOf3ohQFX8398w5Z86czMcJ1kP/+c9/fi9th/9yzrgEHT56+shfzrmTp2KaolOnL8f/epJnT55RMzqdjP8LnD0lFcUuXIn/G5w+YyuKnc/E/w0uXYwJRbGTI62ebWwsf13Ynq9WqwPb0++XNz7H/wjOnorFbEn9LR3sX3u/bZDOk9LuWn/84Dl+FGqYoraWJH3+WHpIXh4XPhz8qH5JUuNjgYKY/9CIHyiQ1MYltbUgaa1EYTxdjh8orUvqf08/Y/dABwVJbeGSrjrDjTf0c0qf9JPwriII6qrveIvwhu7rAQysknSsX78D9vARr8iL9dM8RaG6ZvdRXyVDIBbZEkbuwIhHiVFnGVqdrFa+fUyXJHTIpvy1w6a3VqVoGGvylOojteio5s5v0h8gNWmI2QNlOFJSG5fkS1bzNwYoKtUZ1SDr7ZeQYUK6Kh0S4zhvmA2p0yUlUJrAV4gDcOGjln2Qw/INiqJr2kAntGSH8XAQoifgJos8ux8P5X3ZCWbtevayQygVZ0QaAXu4yco+CFgzTdIIauUh4Imy/W+oFUqNrLeJ0Cc/ajfrKnOGsjKrrNqW2iW6pHaV5q6KRPiVWmM3EUC728J4t7CoXbxhVgYeSTaJppPQM5+oVZblcWllmFh/sb7eSHAftrGzL/JuErofZN0HHZJCGdmmVnm6GNSsiN1xGezXabs9GuOrCzs+6UBJyWSyHU+A/U5RmJ+ZJsUHnMsl25nNSZtjtky0Y/uwC0R7wg+05fKeaeWJsYBGngdXRCXI5RySBDlfu1iiCAzMJBctTWAj6Q8kmVqYJ2PRVbGUV5CTsm/LnLyuQ1IYxWh/jJh4bU4fg9oRFdmC+y6YpokxWSYDsV2wTw4K+SWzXEZzSA8nuqQ3UWY0zktrlrrJaKCkMl+8yIqFfN5krJbLK2qiprHagqTRayFsPIwyI7t4ZPqxzCHlCySxxTIFxXK5aJpL8AZVTTFfEytGaqdqBvPDiSppL8qMVHlzprveVqu4+QrRIK5fQbi02pRgrNS0ugqGzONagQx7A/NHeTgnNEk3ghm1IihS5esDMluqeXqZ1OTtjRtjRGP2xiB0ckfFee5UDLKwyOIAMvaqS7p5A0/G1/78f3fVcVZ5M8NsUf1Kjf1MM58Rto/q7B+xQr5Ob5HBxWd5fo7IqmX0SqaR+31Qjwyk9aldZdEeLwxfdUkdINPha2cek4N574xU/aMnpCj69yT6Iv1BMirMf4nfmavSwlSYX6tTvaMDil76dgMdCoekYFbIwYvRafeMVC1mpJf69uOSbKbqVMAyRsacTGlbfdyZHUR5pWBMdYThlZQO5oVTUSY9ZTlnpEofQZHGpH9Dol7Y3t7eSjpdsaZgDFpJp+eQQQCnj2Ot9ErGEA6K7Fg6DF3S9WAmScNkmalpfUaqsuj6iVr+DSGJWy/YAL0UwsvrYWiShruDy0r6jERKzWmgogoxIyelEElTJCg84BhOSbcCqNMDd7du9nZj8Ujq7u4M+BRIYuzJ5LA9p/mKqsSMXBT8G+LmWz3GhAhnZ7Wtd1vMQlLQZR7QA1cG8EWEuqTOrk7Q5WfVlEoqP2wReDqnMmpG7nq3JRrCUCZE5h7dn3XVTBAJ32shyZXByxAJh6QukEr5WjWlh0vPm3nMCYpUJRR5KPj23CLG3U2e2YT7zFUDSamuZz0eJrpSkOTq1tmZArbrkJQKpkSKSWiyGbYG5lQR/h55KaW8bA4ZXJAd3mWKXDBJqdvkYSKVetaD6hAiSpokjR2laWszVBGw3K22Xt0nxmto6eEYdKdH425KMnQbpSiyGSK6LTYiS/rRvfm8NhFEcZx4UDGIv38LPmIOwUShFbWwWJAcFpTdjWyMdkHBqAQ9KDF6sKIgUttiL1KrRfr7IN78Bfrv+Z1fmcnu7DY5SfrZnffevHnzdr5M21sr4EzFaq8TMO7JUmP+1Jn645WfA2RxMU8rZ8iOWR+Q142xqZV6Qk1MUhpPKK4pDu7Iys1E5TJ5UxWij5WKdxOERE04EFAAW4MGzVOiJRl+FM3s2CU9uwwqeCx25XVcU6zm5QOy8zXZbRkDkmQmoFDkp3Dk5NebuBoeT7nUEHmrhYFl7DUknWNcttoLAfVyd62nZjJNkfvJ3hOSRBwRTYm8R+5qsnK1QW4LMffWs4kAkZwmJNlZCynGc7N8ktL48s7ekEsCH4kayzxaIopslbidYPVcK5CKsolLOpvBE0poWusuvqRUrqX0I6pz7xFwa8tn20Q1e2nLJXceo3W2P/qVNJX87Z9TmiYpnVamJDC9UAuYKtzW9NlUTcQVDS5pJItZSlC7z1eyFF1FiRVI0pNOQMBr20unIyapgfr+MCWNj4zgxbDZp5Rk7n6mIvByZHNJfhQwQRhu008UdpquXG20p1OaqXPjxdMj6co4gLHZNY9s9zSeqejG9LgdH5KY77Sb4oY6436NQIh0l+kFueqP1z0Cjahu66hPCUxJ969k8ocszGUqoklbIz+MogYkXenAcmp1vjDTJBDxuFOPanI5FKv1kDiB14yQSceUNJpNSIPyxd7SI+D6o6M15sP2THfFDykQszYJgsjXq/NSpIuadAaQhD96A9KyN5pnR11A4HvR99jaQoc7Ideb92PLMwtNj2h+NIvdhqSLm/CWBmMppY/f/t6By8aPvqcuzRiTUTk0PZLGLo6NjV2UhqNCPh7WaBB+o2H8GZNeIL83oFVbBbF2wJRUYokSgEHAYxHJ1MxV6p9gsSQZM43uKZvygCeyLYywwpudRQ/1sR5Jm7L4hvrlsV/6P5iSHpaKxW6+yIacV4UrVksl/02/ijrFou5VraILHoSwwomZySOLfVTEkLYorTgQBkL+iubq1KakIqjKoan2zBdvUz80/Cr2YTCjm7Cc6grMkJcnrFnAvZEGOtDnjklCNhOsr8/R5swuFgciqU/PB8AiKY6TiGE33rqUzeulDb3jVtFxdB/MjdBi4VEtrS52EBkbHZbCw71K4uXelFQuypqyU5bHKCNwWN7Byxfg/ZCy+N3hfXgxYFtguXeY419AZ96fFcBhxkJYR3xLddBNkEEZ2ypj1hWIfXgKInJMSagqlMsFVsYGEEY6+aLkVj1dlLewwc4NUMgsYoB+uqtMlWWKK8JQJaJINMAcka5HPxxSFfO8KlTHNSUJRXgLsmEBIAnvsKgsojLYqM+6lMQN/6xDA98KBxwWCMc7CIks5OuOwwvQVPXnWV7BN5hJ3omviAMK+NfUjFWbkjDlJDzQ+1Xeb8++IZMgnPcdsSa+LM8pjM7DIKHBhD+iSpfCGzqZB1oJQ1XpDTFJsfW4jsSKs/i3Hc3NhmE4Oxe1/y5umFVlY2hB8QodG95+BjuQFlvvlbQ10JL2bEFJq4Wtwd6jXUn3CluCZ4akOyvlwtBTXn9/aL+SdOTE+fevLgw5316c/3D4WFfSvm/ntwAf1k1JE+vfVi4NNSsrJyYmDu9QkvafnJiY2Pfz9BDz6weTsCunJB3ctW9LSDq1P6/+jSR/bNeh4Ze07/DRvJaUO35014GdQ82BA0f256BIScrncgeP7xhqjh/M5bQkaMJ027ADRXkoUpKGX1NOXRIkKU1DTz6vJElNQy9KKdr+D/qCdCL/AE1DAAAAAElFTkSuQmCC",
	    adRejectUP: "data:image/png;base64,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",
	    adRejectDown: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABWCAMAAACNZji+AAACH1BMVEUBAAAAAAAAAAAAAAAAAABxKQCYNwC8VQifPgadOQCbOADYdS7ZfC7bcy7YeS3GVxWXNwCsRwOhPAFmJQCuRQmZNwDzihnNZxCaNwCSNQCRNAB/LgDbeTfGazC2SQueOQCcOADlfBTadBO+UA/CXQ2bOAD7kRr////7jxr2cBqqThn2chr7jhr1bhr6jBr6ihr4fRr5hhr3dBr3dhr5ghr5hBr4gBr4eBr6iBr4ehr1bRr8vYT4fxrhmGD4jET4jkT/+PL6hxr/9+/9xo3+4cb938f4exv+8eP+4Mb6oFT7lCX4fBr//fv+6NX9xI38vo38qVP6nlP6kjj8wY38sWL7olP/+vf7plP4fyb5mlPOWxX+48b8mjb5jSj/+vX8x5v7snD927j90Kv8tXD4fCr6kCf5iiX8wo37n0T7mSr6jR3+1Kr9zJr9vX78oDr6jyj3eiX6pWP5lkX/9Or+7eD9t3D4hST7kyD3eiD5ghv8uX/7tHf6m034hDj6kCn7khz91rj90KD9xpb7tYH8pEr8okT3fSL/9uz/8ub+6tX+5dD+48v+4MD+3bn90bH9w4f7rGH4hSj2diCxUBj+2rf8voj7uIT9wYL9u3X6qmr6nEX5ijL5jyr4iCj5iSH92b/+16/906b8x6H6rXf7rm/8tWf4nVv5kUf5hB7//Pj+7Nryp2v6pV7pl1r8q1b5ijn4gzD6uYvjh0f5lEDUZyNlzC0YAAAAJnRSTlMBEAsJBzo529rPmvLy8vL9bdTTGN99/OiNWkkj/erlwrby8O3kpyzYEnsAAAvBSURBVHja7JVLSwJRGIZDD8ZIhIOoXRZRxHfOwh8R40IYClpIm2SgpRHuZJYHobCL4ibIZS1c1K+s1290hsFFp0bUwUf9Lrv3OcdhtjZs2JAsxdyacxgTOsjb22uObRVExKhgH9PaU65Y4U3l7DKlgUppprR3QqlA2cXASByl45KITvcFGwnrltJBpRQoZS2X/oA/cMCLSyvDbl6I/yi1PAnO27Qy7OSzAkaGSg8dn4eWI8FVoKTHy3ebKWUMlJrdTzkkEFd6k95di5ZJqJT9vZIePf5IeJCIKzWx1UeaFoyKjGryQw2AkjBS8l/lhBtW8nhjpQ9eBj4lCRIHyafRUeYDpYyp0pdkGtj0e89xnF7fxXIpmbprfNpIGnaFD3d8zTBXooZknjXfE6AJfcl0KMY0JiaMZixeiQYcvKtjJz39311rk9NdtpICbTw/Fw2MsTMfP+Edda8SpsolSrWKwpWZDXOUkDLyYHLnOYhfk87QV/Nwa2eym5ADejQ/NxXGB9+kk01rE1EUhn+A4N94XZQMAx0ZqIvbdmCgJKHI1CwyqR1DbWwSs9AguFAqDVo/aBcVixTRhRsX/kbPOzenma98FB/mzjvn3Ds3eTKTmg2lqHRvVV79fj537vmwsA8/f3mu5VIoZjU1PdWIzdsonbSj5b/vmubu559vZy/I7bJWSpJLjhqHYuvbKUUALp/br109BM34F4ArrSszak+0XiG/jIt9asyMVM8pK/GGytz5A2Fre0e/fkUS5qvhCwgvntmalLMPJFovzQg4y/dp4DgchMmjoLS2kG1Yvk2f+NqCjGD5tWBdDJzFWi/NL8Ck0HfmsLJSbJBSP9XnvCBvFvfmr+sDk7n7jKNdZbzLDYHt0rrlSoeUr83jNyyD45oS7+ZWnPZskm+wDGvzmADhdpFBu21n25gRWX+RjOwq/djUyefwOXgidzNKtUUcDvYhfNh5NW0cn4ZoSqriEOaipvXxGYT6yY7Ol7KNSs44TwXTbhuEbdlHDGJkmdzsQ4c8qyuRXgKge/P7nL7gH0subN2tA/t/Ha3/Avh8WtO6lEOgLz94M7TPCgia8pCkaeebCByx3nZaqVICEwRtIWgA7cw+vsWVw01PZSWn5nD9nIyCvtY0IudS8LiqszJ0svMnH8dM1hXZMwiYh8BYcgJE0m8Bw3TeKgVTJScCENv7m6xn+9CGx6bv0mmT56yScwtiGlkncgWL6TmrcBjCxLxoImQMYBhdYHo/lZwATSq1xB9SkzcGCVPxXWVzk+N/lFpQ+O6N61pF+lmalUaN6cLYoMs06DP6gFNQ2gUik44h+wlMXK2kVCv5q+QRlHN/DGVw7Pt2fkHGYtRM6wQhk0+H2RARZqrk61NKIDkEuj4f4zC/n7Xw5OBIySpx1epsQPlS16t3/io0DRKfDIGWxCgUASZNLU12Ain54nX7PgvT6xm2c3g5ykqCK6Mqr98I2b7rn6PIIO0LNkdyy3XVhqPhiNkF+swmzVjbLCn5ZNSAMQiz+y1XeurKQg5SyGRLeP/Tzitfi0ZujpP3vOmzOw8xaIwk+W655Amgc0cIXDfAkUsl2+oZwPTcAt76+rrnyeDJklMSNl17LuQjEDPK9zeQ5V3+vh8fQB5pXczXNJLsGN3XINH5I8xo2fUXBsBglN+HSso8JdUq5BbI1nWhv1GHUn9XuO/HS3uP1vnsJIDp8KIB7LFLx67OZ5X20vUDwBgg7Ob2qVK6U1byXK+UqjTrex4zgfKJNfuaqqR1LvmTh9+lftgQkbS/Z+ho5/nieR5fvD1R4vqQ6zsBJA46mf1U6T5hrN/PKnnzmSp1Cu2DfSj1jfxURqnMXgg0ZDN64MDzHjYC6eDIU1TJo5J3QZVLrn9tIDwRqym0sOjFqkr7IKZTMKojQ8Fp+l/a9yo54DfsPAaNBF7QokrpkrbhhZ3oPIFgvutCijzgeMBML6qU1v/RYoatTQNhHP8Efo5D+iY0NaUQMIhpEzSUtkzaN2sR8bWNInWrUByoTCl0sMEsZaLDTRlM8Qv6/O8ud5clPavT35L88zx3OZ5/7nKDkvcr+u4Bsf3+XOVx7MKRwaHMy/aP23hoX8VF3UrIEY8/3I2ikdHeY1HtVsR6NbLEF5t+rkumdtQ4Nb+Aaam2nuddcJ7L7bKrHObaz7uARrUw3Kp96JXkYakmLe20RjMWRAJsJt2eMajj+HTQqbBYsuPpVfdOrz3+gRIFfVGio52t1YtVwqKuzAuVlrzMUozQIM6N40jKLVEnHBudnp6jV+f6/1P7RdZu115MGtEMeI9njAVjnh+xh6qdRWjvebG0lGzFcUznDmJzPKul594fMNWOKDpS0YW3CV3GZii5hWAUMDbETcLgCeQtyRDIWOP/O0s/AyYY+ggPZfR16lMMrEpfeMenkiMep/BEuorIEym3pJCWkDctIYY0Gk4jj2mJevlWOvO2uo8D4cgRofB0/9hHDF6dXECy2DOVJikkbbNQxGmQrKCrBN5Am2k6CNEfxBSrcQBMWCzxnUMcJbr8RBvCVMXxNladaj/ijlR/LMx5Vz/vmxoylpKiUJFPF76Tdh1/0WLs1BFNoj8sONySjs3xzCmq13HJWXJseLtv+e7mqUx8h+ZI02YPjnXEd8Ggrcb0DW1jLriGRn4YtBdOSg+lFD6kJsAtiJ5mjP6SeoGNLZ0ywa5O/Rw7JhdTfZ/th0flI7UW4iUERpomaMHt7lEQZh7SMEyRTTqCPWHpHtqg965haXqfcZ4uxVjNexZdPmWCaUk79gYoyj+Fgs6Mtga0zzoIh+FQPwdLBujQrDcoD5W4rosLDsNS3wENnIJmTh8ywTFirFmLjplgrvNNqf1mozMWusdAEiYQrDjZ3iwozWfIQd8B5esu2eBaxLTUsLK8w/e04SL7Fi3a720z4s5S5ydSH/WVXraYQWuc5YtK35KI3QFZoiFdABVUq1qrOUt4p3UBf715xUsNpzwGdr09w5dk5F2pqETp2UDR1/mizlhIiuh2GJ5VMyPcRMHSjZylOiyt43X47HOzvjHj/fA1VK91qeAP9fbgDFIyJUVMS7IAi6e+vJmML9e+0+/jiYybEyOvqF7nLLVQqVYqVUCK07Qk9wwJiilXd4+9OZqUvtP656fsh5t3gCvBK1Kl/aWKwnHRIJCHxZKd79ii97+oJa11EOI3oUu9QnBW/xWoX1laS95SRlWKMdlmYXI7HyJn4rbvM3Cyvii5TsTFrsDUcuyWnsjl8TsGVDhIRNeDCSEshUwwzt6lcPAfuEl/dC0lZ2kzssKPecWfnoH5QYX4wgTfDq5Z8FW1s7kl/SlCgdA544Q89SgQ0cuK0XRy8Pduro9p6Vf3ZrCaMBCEYVwVCj0kRAVt1QqlSBr2BSKN0HNfoDkWH8CeJScPLT3qAxQULEWEVnzAZtzZndUuJQYsrL/JzG5c4v/NjuAhBtmaZDJ/hZ8RfYGET00KpAQAX8YTg89fZgNDzi/O8dxDyqqv2Wd3Fuwjgavv7sNT4sP4qOLbkxMPCKl4RiQfAnhGt9F4KO6mkLDU8yivRzSn5lxlTvuAl2SQHBDxMCChtSBjqQf4nHhygG/dvkTAKdXap4xmaSeARcGIRTTeQfJzKHi/B70NDc0Nh94nmrD30R55FMEgeovg6D66wjxI3FRoJEBRNanYREBYu56pgySozhqGZBuTEvdprCElJvcUsDH0PkgDkRl8kqg1IOJys8g6bUd4iM7rCmmhyitbmz4a58oOHnqVMdD6vzz7kOAFMxEgySGEvBq0agppuSAUiIQirpDdfRbJLR3jqp1GQZ8QjqrBqOVKpKtmb/TYP1hRJBKGKBVESNH/6+O5t6w2JFLHWfdOQMtN9aKISDdOvFmv7qzWatWMY0ASf/Zx23EcO9NbizV14lReBZGKFc85CaS2ywBp23kN79p+JKdaY6wkkVi57p1ZLq/jMlZEJGAqVMqW67JQEJtETNaLMfFNIibLqQAI204yFZnlAiAgIqaUymqVFNAP5QKX38YmULgAAAAASUVORK5CYII="
	};
	exports.imageRes = imageRes;
	var TVAdvRes = {
	    listPanelMore: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAACZCAMAAACc/w0XAAABGlBMVEUAAAD/////////////////////////////////////////////////////////////////////////////////////////////////////4c7/////////jUD/////////////////////////////k0v/m1n/////oGH/////p2z/rnf/qnH/q3P/ZgD/////lWb/u6L/3tP/9/T/bQz/eR//chT/1bj/fSX/qYf/8+r/+fX/7un/7eD/uIj/0LD/qG3/oWL/ilT/+/j/5t7/yqb/s5X/m1f/jkL/gS3/cyT/dhv/xa//zbv/yKP/kUf/1sf/vI//6dv/5tb/vpP/pGf/fz7/iTn/hzf/vpL/n3f/9O3/kUj/kEZCrmCFAAAALnRSTlMABQPz7cuDMuXEit0tXPytpHhlUCnZu3BXIArgzeLSr2IioqGH07ifnoBxN1pZOfKHPQAABNdJREFUaN7tmWlb2kAQgBcErAcWBK1aj6q9j9mQhFMKSBGFQq09tLXt//8bzWwKGzIJBAjP0w/7fkFM8rpuZmd3Z1lwuAULjBIrsRIrsRIrsRIrsRIrsRIrsRIrsRIrsRIrsRIrsRIr8YxE13cSqZWtGIrXDldSiZ316PzW5fT2EicsbaeX57Eev1rjvqy9Op7NGkmu8AmsJCPTazdlYyvFb42rUgF/zHeuGt+KFdnszenU0ScPuM1ZvdEBG/wKNp1G/YzbPHgSneKN7XOb4qWJHpdYYF4Wuc3+ctBeWN3giHGTBwfP8HfPwEH+xuDIxmqg/tiN231QK4CTA3uAHICTQs3ukfjuZG8mxpGLPIzyli1Z8cvewSj5C47EMpO8CY68/w1u9tgR50dsj1y4fs+RxPhoOOXIJxMIb1h2bS3L3gDB/MSR0zHREXmId3w4Bw+eM8Fz8OD8Az73MOLbXuGt3IEX5mu85bUJXtxVhNmvzSeie0vgw8HLlwfgQ0l09MmY9/b1I8zEx6/49FMv7w5e+YLe2cxf8Pkd6s0uYf+WYGZK2M9LWRIQhxgPP2AOfmBsHLpDY5VbnMNcnKNj1ZXPNnBcwJzgSNlYHongOAaaOa/YxKCLO6N5k1tcw9xco2dTevceYD6DELjAOWVvKH6E+TcfhjiP+fnRMNSwwTUIhRo2eRBySZyHCuGICzhbJZkNhsRPCImfGBhMsC4WDGGJ82hbHw66IoRGcTj8Hls/XYYnvrR0jwc9cSYHXVfzBf7R1y1ufYcfvj4c12nrsw5DNO4L2LT9Lwrq1re0Jd62Pr8HFVvt7vEJ4u/Wt23GopjgHfm9qQ+p4gO6BNdvflSloYQJP8qyOHGAJznREokU97UhZY4YTZBURMAlMdiIzgttIP6sQVMTWLoWR8rugEuKubkWUCzRqlyg98VHj+SLBEvhlDSVmN6m0ykqxXCjceV+oqUhfaETUDE0W8MX14URrnB7wrZkUEhxNYfo+FROMBDnnBgDcU/XyzAaFlsMl8OF4C/PjxxICrhgZhjGZrhiEwOZkVhFseEeILIrXJS1tvjU3NHONrxarLsHiPPldcUfvNdGoGLRx5Na3HKK+9wL0hWYjfOB+ziX61W9r5KXh4vBThCxIf5JX0i4kQFS1gcYIqIH3Eqx0XbebycLMkBeuIa0yC9yuLVyuXuQ5JB2syX9GvGKIf2Cpd1JSCd90ARC27DzXLdpCC9JQmmWwbRJxU5aXWq+tW8zqNdOmxmS6IkYGwYelIWTeu1En2XRmMhCFE0ob8XjbS9z9zMX6BoyGhSxKGNH4ybTMtzLrCsvTpxMj3ANO2767wL0phXX7ZWs6GTDJGI55bT8xdV+uadLsVywrNMlVleTNEHwL4GVp1hiLWxRuLhlbPgL7xtceC96qxD+5mbB27HwN5Dhb3n/oGdzQZv0/egiywqLL4SwSDyc0k08QoqwsTCKTbFdRsiEUR7LMA+ehlTQo6RECbIzi7cjSpCpsUXTX3fTe+9+kaKpV5m3Ma23Qcq8xHzKkXphqkxZ58hJJEgpPVDeoKX04MV/ykzFf3pcQZn5uIIesFDoAcs8R0KCuY6E6CEWgRxizXXsZgKYhRI5dvtfDgoFx4lxR5uJ4//vMHb0+BhPx2JbQY+P/wIS1YhIWsL7BwAAAABJRU5ErkJggg==",
	    focusPanel: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPEAAABCCAMAAACxS8DgAAAA4VBMVEUAAAD/////////////////////////cRL/////llD/////////rXb/////////gS3//////////////////////////////////////////Pr/cBH/////////////////////////ZgD/////lWb/u6L/3tP/9/T/xa//zbv/fz7/ilT/cyT/5t7/qYf/7un/n3f/rXX/cRL/1sf/s5X/bg3/aQX/hDL/eyP//fz/8ur/wpr/nVr/+fX/7+P/6dr/5NL/4c3/2sH/1rr/0bL/yaX/t4b/sn7/pGf/jUD/iTlbvVbtAAAAInRSTlMA9bev6MIW6KpxXykX2r27opiNhoN7UUpHC/vo4MV1QiAUr8fDkgAAA/hJREFUaN7U2Olu2kAUhuGhhOxp2mZt0/V8YxvjYNYA6b5v939BPXPAjERlYssT5Hl+MA7IEm/G5iCUuDxtNVBzjdbppXJkexee2N1WLpxvwRtb5y522KNgTnawy02wwZBqbzgAa6qqLsCm5IUp2IWq6MTsMHnC7PKJqqgF4IY8cQOgpSoyc5i8YeayqugBgN/kCzBV0RnYT/KEFLvYZPwgPzgpfv0Q7OuEfCDFlT2VXf7kxQe2FDuwC/bWg69dTorFY7BnM6o9KXbiCYw/VHdS7MZLGO+p5qTYkf0G2C+qNyl25dUR2DuqNSl25kAG87cJ5WmHLCGrEzBNLNFad0jYP1e15fSUH9uk5UxDDtPFmmyu2A7mzzmDOdFdsJG2RmCxeeMxH7R5vdaiK88LKZ2LAGgK+DGUx4AMOTfmtT9fQ8yF910smmsGc4g8RDTmpcurxqqVM7PiNgwyenyQEouAaJPF4hHYh1npYiktUtxZFMfL4gTM3AaJbHa6wWI7mG//li0msH5OsVzVXakY06JYR9mZY1572jzZBwtTvp3DDRWLs7zBnAaZGCwOloh1IbT97wRk2asgK87My2Mppih7KdhUsdiHMaB8etlmjfKLr7UxlpdZzGtXz2UXRTovTjdbbJOfy2AuV6zzizVyZS9qbRP/L97ZOzzcu7LF7h28APs+KVNMHW1cly1Owuiu4mMljm2xe29kMH+ZFC8OWIdYyWIW3lF8pRZ2coodDuaPw8KfXD2bWOY+LlK8xxddswFn1g7maFZ0OsX2LRb9rDbfLYsUHyp1BIfW/0hwOy1YnIKZm9h+n+zJUdsWS1myrDGLx8X/2DODJAdBKIguc4+QPyDgYJXe/2xT9gBdYEhMNrCwN6hsfOWnbT52H4NS4KL43n6K9wXx2FWd1zEywypUCseqTWxn9S3xrZNzUbCguX4qkfh5VS9atYlH/ztZvPyRepNdtnIuAkAiv58RM4HcuiWQFTUN7OxKbA+4IzF56dVBxLSIR0uZCyzKY1ALn0e7bhMHEv9rHOKXOwmvY94ycDZbfXx9bxGbxxNiGYK4uVuEplzNc72U9V7tJTETtysTiIariR+BmB2BZqIOng5myqntfOaCBiBudn0gH1DTeUXzJpa5s4fOnqcBkHgehrjd2UPvJn9WMmojgnCpQCSqVt71n3QuTnbv3oIJNR3lZ3IoaH1DHD4hnrp36H8yAZErYtcm5t/MhnPEj+6nMAah0Rbreku5GqODL1NpHXteQnnOpbxubdo73iXKXSdt12nqdWL+174dCAAAAAAI8rcepD1qFbF8kXWTJ9g4pehJVE8be6LcWwPeDPH2jze8wMXnTU1w42LjOoWe/omYk51sAAAAAElFTkSuQmCC",
	    defaultQR2: "data:image/png;base64,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6s0ztzlo2wPPOvSxc6qAMsrCoCErF6FsRsjWzILWBNkbFdDXli8w2BWRI07Zc6c9Dj5920Me2n2bPR59eMMdHjn9wD3OemyPE7nvyop6nF50HQKZKs6z2cwgjNlKmUiRrVzMEtn0guu3PHDbHXbY4aBHD9j9jAPOOH3/HXbYdtuzdtpQmB602aaLKdstA6XWRrEwjVLczC2eSomYd82jNwBMSagIsoLIYTtds83M6tUn7HDqKQeccvhpM/vfv3pmm2t22opl/LlKDzEn1AlIJ6GUAUIEMDO3sot7Ta+3w02JrCCy4XXbHHzLrUedunrm1B0POOXB1fvTnd23ue5wKLMTsuSlbCwKVV4vS8zUANVebxHP+7bwejGRYEErGJwzmXTBpqZgEECg8Fy4FEWaNtzy4FumA+TSK2Zmdr3y/pnTXlk4hty6/9VPBpfRhE0UtwG6TCbCReroJheppJtMpIunS32AKA5ZTy+XRE66SYeNeu641VddMXPs8wVwGyF777ZhEHyEU41WxlABjPHNaTYZJZGlWHM1NKCI2NNMWUeE7WLaJEnEYlYmctBuN11ypOnX5FH3XXnV6pn7bopryGX251GkvbycdsxgubEKE4nWgYGB8g4ATfmAnVBssVgRF0F8kgi4uDtZn3CYyFYn7WEid156+QXHXrnv6iuO24rgzsW7bdi0LGWQDl4kGVcmiZooAIS5mddQb6CI6ImMAzbdassT9r686LW9j129774zM/set/fld7729a5Xb1jF58kcULQs1ICY7Z8GyqV3zikvjcU2AqGnORZrvhCghZjyYrn0fKx5eL9NH9ny5Jn9L97wuH13PeS8887YdebY0y4+aGabLQ9fvrF8oLwvFuvH7oo2xxbKB1JCfTk9WF4Ra5O7S8GVOVexqshcrBkoTQdfve2e55x8wupTz3v62WefPu+01bsedM6hu215JqyBk4Gv9CgDhHhhjufiQRZXWniOjtBBCwaXBbEqGKR2DDBhSqYwXWuju8ub7n793hede+07F739ycufv/DCR75nnrn2iYv23mlXYR96az+AldiHgxRqVTXBeYKsAzUmkzEYpCaMvsuLdBLP2m468yvdlH4Q6RxaRpHk2m73bcIFRzmg+tvSfb7/6fef77775R+PvuS7t+D8o57aNDXi9VajiMmN0HDodtu5SNDrXc/tHvV6sbVK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",
	    defaultQR1: "data:image/png;base64,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"
	};
	exports.TVAdvRes = TVAdvRes;
/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/20.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	var _libEventEmitter = __webpack_require__(13);
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	var _resDefineJs = __webpack_require__(6);
	var define = _interopRequireWildcard(_resDefineJs);
	var _keypressJs = __webpack_require__(14);
	var _keypressJs2 = _interopRequireDefault(_keypressJs);
	var KeyEventType = define.KeyEventType;
	var TVKeyEventManager = (function (_EventEmitter) {
	    _inherits(TVKeyEventManager, _EventEmitter);
	    function TVKeyEventManager() {
	        _classCallCheck(this, TVKeyEventManager);
	        _get(Object.getPrototypeOf(TVKeyEventManager.prototype), "constructor", this).call(this);
	        this.addListener(KeyEventType.DOWN, this.handelKeyDown, this);
	        this.addListener(KeyEventType.UP, this.handelKeyUp, this);
	        this.deviceObserver = {};
	        this.keyObserver = {};
	    }
	    _createClass(TVKeyEventManager, [{
	        key: "checkDevice",
	        value: function checkDevice(device) {
	            if (device === define.DeviceIdentity || typeof device !== "number") {
	                return false;
	            }
	            if (!this.deviceObserver[device]) {
	                this.deviceObserver[device] = {};
	            }
	            return true;
	        }
	    }, {
	        key: "handelKeyDown",
	        value: function handelKeyDown(keycode, device) {
	            if (this.checkDevice(device)) {
	                this.deviceObserver[device][keycode] = define.KeyState.TOUCHING;
	            }
	            this.keyObserver[keycode] = define.KeyState.TOUCHING;
	        }
	    }, {
	        key: "handelKeyUp",
	        value: function handelKeyUp(keycode, device) {
	            if (this.checkDevice(device)) {
	                this.deviceObserver[device][keycode] = define.KeyState.RELEASED;
	            }
	            this.keyObserver[keycode] = define.KeyState.RELEASED;
	        }
	    }, {
	        key: "isKeyTouching",
	        value: function isKeyTouching(keycode, device) {
	            if (this.checkDevice(device)) {
	                return this.deviceObserver[device][keycode] === define.KeyState.TOUCHING;
	            }
	            return this.keyObserver[keycode] === define.KeyState.TOUCHING;
	        }
	    }, {
	        key: "isKeyNameTouching",
	        value: function isKeyNameTouching(keyname, device) {
	            var _this = this;
	            var keydefs = define.KeyCodeUsualDef[keyname.substring(0, 1).toUpperCase() + keyname.substring(1)];
	            if (!keydefs) return false;
	            keydefs = keydefs.split("&");
	            var result = keydefs.some(function (keydef) {
	                var keycode = define.KeyCode[keydef.toUpperCase()];
	                return _this.isKeyTouching(keycode, device);
	            });
	            return result;
	        }
	    }]);
	    return TVKeyEventManager;
	})(_libEventEmitter2["default"]);
	var instance = new TVKeyEventManager();
	window["onMeiriqTVKeyDown"] = function (keycode, device) {
	    if (!keycode) return;
	    if (instance.keyObserver[keycode] !== define.KeyState.TOUCHING) {
	        instance.emit(KeyEventType.DOWN, keycode, device);
	    }
	};
	window["onMeiriqTVKeyUp"] = function (keycode, device) {
	    if (!keycode) return;
	    instance.emit(KeyEventType.UP, keycode, device);
	};
	var listener = new _keypressJs2["default"].Listener(document.documentElement);
	listener.register_many([{
	    "keys": ["w"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](19, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](19, -1);
	    }
	}, {
	    "keys": ["up"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](19, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](19, -1);
	    }
	}, {
	    "keys": ["a"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](21, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](21, -1);
	    }
	}, {
	    "keys": ["left"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](21, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](21, -1);
	    }
	}, {
	    "keys": ["s"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](20, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](20, -1);
	    }
	}, {
	    "keys": ["down"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](20, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](20, -1);
	    }
	}, {
	    "keys": ["d"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](22, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](22, -1);
	    }
	}, {
	    "keys": ["right"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](22, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](22, -1);
	    }
	}, {
	    "keys": ["space"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](23, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](23, -1);
	    }
	}, {
	    "keys": ["enter"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](23, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](23, -1);
	    }
	}, {
	    "keys": ["m"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](82, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](82, -1);
	    }
	}, {
	    "keys": ["b"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](4, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](4, -1);
	    }
	}, {
	    "keys": ["esc"],
	    "on_keydown": function on_keydown() {
	        window["onMeiriqTVKeyDown"](4, -1);
	    },
	    "on_keyup": function on_keyup() {
	        window["onMeiriqTVKeyUp"](4, -1);
	    }
	}]);
	exports["default"] = instance;
	module.exports = exports["default"];
/***/ },
/* 13 */
/***/ function(module, exports) {
	/* Created by tommyZZM on 2015/10/18.*/
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var EventEmitter = window["meiriq"].lib.EventEmitter;
	exports["default"] = EventEmitter;
	module.exports = exports["default"];
/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
	/*
	Copyright 2014 David Mauro
	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at
	http://www.apache.org/licenses/LICENSE-2.0
	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
	Keypress is a robust keyboard input capturing Javascript utility
	focused on input for games.
	version 2.1.0
	 */
	/*
	Combo options available and their defaults:
	    keys            : []            - An array of the keys pressed together to activate combo.
	    count           : 0             - The number of times a counting combo has been pressed. Reset on release.
	    is_unordered    : false         - Unless this is set to true, the keys can be pressed down in any order.
	    is_counting     : false         - Makes this a counting combo (see documentation).
	    is_exclusive    : false         - This combo will replace other exclusive combos when true.
	    is_solitary     : false         - This combo will only fire if ONLY it's keys are pressed down.
	    is_sequence     : false         - Rather than a key combo, this is an ordered key sequence.
	    prevent_default : false         - Prevent default behavior for all component key keypresses.
	    prevent_repeat  : false         - Prevent the combo from repeating when keydown is held.
	    on_keydown      : null          - A function that is called when the combo is pressed.
	    on_keyup        : null          - A function that is called when the combo is released.
	    on_release      : null          - A function that is called when all keys in the combo are released.
	    this            : undefined     - Defines the scope for your callback functions.
	 */
	(function() {
	  var Combo, keypress, _change_keycodes_by_browser, _compare_arrays, _compare_arrays_sorted, _convert_key_to_readable, _convert_to_shifted_key, _decide_meta_key, _factory_defaults, _filter_array, _index_of_in_array, _is_array_in_array, _is_array_in_array_sorted, _key_is_valid, _keycode_alternate_names, _keycode_dictionary, _keycode_shifted_keys, _log_error, _metakey, _modifier_event_mapping, _modifier_keys, _validate_combo,
	    __hasProp = {}.hasOwnProperty,
	    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	  _factory_defaults = {
	    is_unordered: false,
	    is_counting: false,
	    is_exclusive: false,
	    is_solitary: false,
	    prevent_default: false,
	    prevent_repeat: false
	  };
	  _modifier_keys = ["meta", "alt", "option", "ctrl", "shift", "cmd"];
	  _metakey = "ctrl";
	  keypress = {};
	  keypress.debug = false;
	  Combo = (function() {
	    function Combo(dictionary) {
	      var property, value;
	      for (property in dictionary) {
	        if (!__hasProp.call(dictionary, property)) continue;
	        value = dictionary[property];
	        if (value !== false) {
	          this[property] = value;
	        }
	      }
	      this.keys = this.keys || [];
	      this.count = this.count || 0;
	    }
	    Combo.prototype.allows_key_repeat = function() {
	      return !this.prevent_repeat && typeof this.on_keydown === "function";
	    };
	    Combo.prototype.reset = function() {
	      this.count = 0;
	      return this.keyup_fired = null;
	    };
	    return Combo;
	  })();
	  keypress.Listener = (function() {
	    function Listener(element, defaults) {
	      var attach_handler, property, value;
	      this.should_suppress_event_defaults = false;
	      this.should_force_event_defaults = false;
	      this.sequence_delay = 800;
	      this._registered_combos = [];
	      this._keys_down = [];
	      this._active_combos = [];
	      this._sequence = [];
	      this._sequence_timer = null;
	      this._prevent_capture = false;
	      this._defaults = defaults || {};
	      for (property in _factory_defaults) {
	        if (!__hasProp.call(_factory_defaults, property)) continue;
	        value = _factory_defaults[property];
	        this._defaults[property] = this._defaults[property] || value;
	      }
	      this.element = element || document.body;
	      attach_handler = function(target, event, handler) {
	        if (target.addEventListener) {
	          target.addEventListener(event, handler);
	        } else if (target.attachEvent) {
	          target.attachEvent("on" + event, handler);
	        }
	        return handler;
	      };
	      this.keydown_event = attach_handler(this.element, "keydown", (function(_this) {
	        return function(e) {
	          e = e || window.event;
	          _this._receive_input(e, true);
	          return _this._bug_catcher(e);
	        };
	      })(this));
	      this.keyup_event = attach_handler(this.element, "keyup", (function(_this) {
	        return function(e) {
	          e = e || window.event;
	          return _this._receive_input(e, false);
	        };
	      })(this));
	      this.blur_event = attach_handler(window, "blur", (function(_this) {
	        return function() {
	          var key, _i, _len, _ref;
	          _ref = _this._keys_down;
	          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	            key = _ref[_i];
	            _this._key_up(key, {});
	          }
	          return _this._keys_down = [];
	        };
	      })(this));
	    }
	    Listener.prototype.destroy = function() {
	      var remove_handler;
	      remove_handler = function(target, event, handler) {
	        if (target.removeEventListener != null) {
	          return target.removeEventListener(event, handler);
	        } else if (target.removeEvent != null) {
	          return target.removeEvent("on" + event, handler);
	        }
	      };
	      remove_handler(this.element, "keydown", this.keydown_event);
	      remove_handler(this.element, "keyup", this.keyup_event);
	      return remove_handler(window, "blur", this.blur_event);
	    };
	    Listener.prototype._bug_catcher = function(e) {
	      var _ref;
	      if (_metakey === "cmd" && __indexOf.call(this._keys_down, "cmd") >= 0 && ((_ref = _convert_key_to_readable(e.keyCode)) !== "cmd" && _ref !== "shift" && _ref !== "alt" && _ref !== "caps" && _ref !== "tab")) {
	        return this._receive_input(e, false);
	      }
	    };
	    Listener.prototype._cmd_bug_check = function(combo_keys) {
	      if (_metakey === "cmd" && __indexOf.call(this._keys_down, "cmd") >= 0 && __indexOf.call(combo_keys, "cmd") < 0) {
	        return false;
	      }
	      return true;
	    };
	    Listener.prototype._prevent_default = function(e, should_prevent) {
	      if ((should_prevent || this.should_suppress_event_defaults) && !this.should_force_event_defaults) {
	        if (e.preventDefault) {
	          e.preventDefault();
	        } else {
	          e.returnValue = false;
	        }
	        if (e.stopPropagation) {
	          return e.stopPropagation();
	        }
	      }
	    };
	    Listener.prototype._get_active_combos = function(key) {
	      var active_combos, keys_down;
	      active_combos = [];
	      keys_down = _filter_array(this._keys_down, function(down_key) {
	        return down_key !== key;
	      });
	      keys_down.push(key);
	      this._match_combo_arrays(keys_down, (function(_this) {
	        return function(match) {
	          if (_this._cmd_bug_check(match.keys)) {
	            return active_combos.push(match);
	          }
	        };
	      })(this));
	      this._fuzzy_match_combo_arrays(keys_down, (function(_this) {
	        return function(match) {
	          if (__indexOf.call(active_combos, match) >= 0) {
	            return;
	          }
	          if (!(match.is_solitary || !_this._cmd_bug_check(match.keys))) {
	            return active_combos.push(match);
	          }
	        };
	      })(this));
	      return active_combos;
	    };
	    Listener.prototype._get_potential_combos = function(key) {
	      var combo, potentials, _i, _len, _ref;
	      potentials = [];
	      _ref = this._registered_combos;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        combo = _ref[_i];
	        if (combo.is_sequence) {
	          continue;
	        }
	        if (__indexOf.call(combo.keys, key) >= 0 && this._cmd_bug_check(combo.keys)) {
	          potentials.push(combo);
	        }
	      }
	      return potentials;
	    };
	    Listener.prototype._add_to_active_combos = function(combo) {
	      var active_combo, active_key, active_keys, already_replaced, combo_key, i, should_prepend, should_replace, _i, _j, _k, _len, _len1, _ref, _ref1;
	      should_replace = false;
	      should_prepend = true;
	      already_replaced = false;
	      if (__indexOf.call(this._active_combos, combo) >= 0) {
	        return true;
	      } else if (this._active_combos.length) {
	        for (i = _i = 0, _ref = this._active_combos.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	          active_combo = this._active_combos[i];
	          if (!(active_combo && active_combo.is_exclusive && combo.is_exclusive)) {
	            continue;
	          }
	          active_keys = active_combo.keys;
	          if (!should_replace) {
	            for (_j = 0, _len = active_keys.length; _j < _len; _j++) {
	              active_key = active_keys[_j];
	              should_replace = true;
	              if (__indexOf.call(combo.keys, active_key) < 0) {
	                should_replace = false;
	                break;
	              }
	            }
	          }
	          if (should_prepend && !should_replace) {
	            _ref1 = combo.keys;
	            for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
	              combo_key = _ref1[_k];
	              should_prepend = false;
	              if (__indexOf.call(active_keys, combo_key) < 0) {
	                should_prepend = true;
	                break;
	              }
	            }
	          }
	          if (should_replace) {
	            if (already_replaced) {
	              active_combo = this._active_combos.splice(i, 1)[0];
	              if (active_combo != null) {
	                active_combo.reset();
	              }
	            } else {
	              active_combo = this._active_combos.splice(i, 1, combo)[0];
	              if (active_combo != null) {
	                active_combo.reset();
	              }
	              already_replaced = true;
	            }
	            should_prepend = false;
	          }
	        }
	      }
	      if (should_prepend) {
	        this._active_combos.unshift(combo);
	      }
	      return should_replace || should_prepend;
	    };
	    Listener.prototype._remove_from_active_combos = function(combo) {
	      var active_combo, i, _i, _ref;
	      for (i = _i = 0, _ref = this._active_combos.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	        active_combo = this._active_combos[i];
	        if (active_combo === combo) {
	          combo = this._active_combos.splice(i, 1)[0];
	          combo.reset();
	          break;
	        }
	      }
	    };
	    Listener.prototype._get_possible_sequences = function() {
	      var combo, i, j, match, matches, sequence, _i, _j, _k, _len, _ref, _ref1, _ref2;
	      matches = [];
	      _ref = this._registered_combos;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        combo = _ref[_i];
	        for (j = _j = 1, _ref1 = this._sequence.length; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
	          sequence = this._sequence.slice(-j);
	          if (!combo.is_sequence) {
	            continue;
	          }
	          if (__indexOf.call(combo.keys, "shift") < 0) {
	            sequence = _filter_array(sequence, function(key) {
	              return key !== "shift";
	            });
	            if (!sequence.length) {
	              continue;
	            }
	          }
	          for (i = _k = 0, _ref2 = sequence.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
	            if (combo.keys[i] === sequence[i]) {
	              match = true;
	            } else {
	              match = false;
	              break;
	            }
	          }
	          if (match) {
	            matches.push(combo);
	          }
	        }
	      }
	      return matches;
	    };
	    Listener.prototype._add_key_to_sequence = function(key, e) {
	      var combo, sequence_combos, _i, _len;
	      this._sequence.push(key);
	      sequence_combos = this._get_possible_sequences();
	      if (sequence_combos.length) {
	        for (_i = 0, _len = sequence_combos.length; _i < _len; _i++) {
	          combo = sequence_combos[_i];
	          this._prevent_default(e, combo.prevent_default);
	        }
	        if (this._sequence_timer) {
	          clearTimeout(this._sequence_timer);
	        }
	        if (this.sequence_delay > -1) {
	          this._sequence_timer = setTimeout(function() {
	            return this._sequence = [];
	          }, this.sequence_delay);
	        }
	      } else {
	        this._sequence = [];
	      }
	    };
	    Listener.prototype._get_sequence = function(key) {
	      var combo, i, j, match, seq_key, sequence, _i, _j, _k, _len, _ref, _ref1, _ref2;
	      _ref = this._registered_combos;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        combo = _ref[_i];
	        if (!combo.is_sequence) {
	          continue;
	        }
	        for (j = _j = 1, _ref1 = this._sequence.length; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
	          sequence = (_filter_array(this._sequence, function(seq_key) {
	            if (__indexOf.call(combo.keys, "shift") >= 0) {
	              return true;
	            }
	            return seq_key !== "shift";
	          })).slice(-j);
	          if (combo.keys.length !== sequence.length) {
	            continue;
	          }
	          for (i = _k = 0, _ref2 = sequence.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
	            seq_key = sequence[i];
	            if (__indexOf.call(combo.keys, "shift") < 0) {
	              if (seq_key === "shift") {
	                continue;
	              }
	            }
	            if (key === "shift" && __indexOf.call(combo.keys, "shift") < 0) {
	              continue;
	            }
	            if (combo.keys[i] === seq_key) {
	              match = true;
	            } else {
	              match = false;
	              break;
	            }
	          }
	        }
	        if (match) {
	          return combo;
	        }
	      }
	      return false;
	    };
	    Listener.prototype._receive_input = function(e, is_keydown) {
	      var key;
	      if (this._prevent_capture) {
	        if (this._keys_down.length) {
	          this._keys_down = [];
	        }
	        return;
	      }
	      key = _convert_key_to_readable(e.keyCode);
	      if (!is_keydown && !this._keys_down.length && (key === "alt" || key === _metakey)) {
	        return;
	      }
	      if (!key) {
	        return;
	      }
	      if (is_keydown) {
	        return this._key_down(key, e);
	      } else {
	        return this._key_up(key, e);
	      }
	    };
	    Listener.prototype._fire = function(event, combo, key_event, is_autorepeat) {
	      if (typeof combo["on_" + event] === "function") {
	        this._prevent_default(key_event, combo["on_" + event].call(combo["this"], key_event, combo.count, is_autorepeat) !== true);
	      }
	      if (event === "release") {
	        combo.count = 0;
	      }
	      if (event === "keyup") {
	        return combo.keyup_fired = true;
	      }
	    };
	    Listener.prototype._match_combo_arrays = function(potential_match, match_handler) {
	      var source_combo, _i, _len, _ref;
	      _ref = this._registered_combos;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        source_combo = _ref[_i];
	        if ((!source_combo.is_unordered && _compare_arrays_sorted(potential_match, source_combo.keys)) || (source_combo.is_unordered && _compare_arrays(potential_match, source_combo.keys))) {
	          match_handler(source_combo);
	        }
	      }
	    };
	    Listener.prototype._fuzzy_match_combo_arrays = function(potential_match, match_handler) {
	      var source_combo, _i, _len, _ref;
	      _ref = this._registered_combos;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        source_combo = _ref[_i];
	        if ((!source_combo.is_unordered && _is_array_in_array_sorted(source_combo.keys, potential_match)) || (source_combo.is_unordered && _is_array_in_array(source_combo.keys, potential_match))) {
	          match_handler(source_combo);
	        }
	      }
	    };
	    Listener.prototype._keys_remain = function(combo) {
	      var key, keys_remain, _i, _len, _ref;
	      _ref = combo.keys;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        key = _ref[_i];
	        if (__indexOf.call(this._keys_down, key) >= 0) {
	          keys_remain = true;
	          break;
	        }
	      }
	      return keys_remain;
	    };
	    Listener.prototype._key_down = function(key, e) {
	      var combo, combos, event_mod, i, mod, potential, potential_combos, sequence_combo, shifted_key, _i, _j, _k, _len, _len1, _ref;
	      shifted_key = _convert_to_shifted_key(key, e);
	      if (shifted_key) {
	        key = shifted_key;
	      }
	      this._add_key_to_sequence(key, e);
	      sequence_combo = this._get_sequence(key);
	      if (sequence_combo) {
	        this._fire("keydown", sequence_combo, e);
	      }
	      for (mod in _modifier_event_mapping) {
	        event_mod = _modifier_event_mapping[mod];
	        if (!e[event_mod]) {
	          continue;
	        }
	        if (mod === key || __indexOf.call(this._keys_down, mod) >= 0) {
	          continue;
	        }
	        this._keys_down.push(mod);
	      }
	      for (mod in _modifier_event_mapping) {
	        event_mod = _modifier_event_mapping[mod];
	        if (mod === key) {
	          continue;
	        }
	        if (__indexOf.call(this._keys_down, mod) >= 0 && !e[event_mod]) {
	          if (mod === "cmd" && _metakey !== "cmd") {
	            continue;
	          }
	          for (i = _i = 0, _ref = this._keys_down.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	            if (this._keys_down[i] === mod) {
	              this._keys_down.splice(i, 1);
	            }
	          }
	        }
	      }
	      combos = this._get_active_combos(key);
	      potential_combos = this._get_potential_combos(key);
	      for (_j = 0, _len = combos.length; _j < _len; _j++) {
	        combo = combos[_j];
	        this._handle_combo_down(combo, potential_combos, key, e);
	      }
	      if (potential_combos.length) {
	        for (_k = 0, _len1 = potential_combos.length; _k < _len1; _k++) {
	          potential = potential_combos[_k];
	          this._prevent_default(e, potential.prevent_default);
	        }
	      }
	      if (__indexOf.call(this._keys_down, key) < 0) {
	        this._keys_down.push(key);
	      }
	    };
	    Listener.prototype._handle_combo_down = function(combo, potential_combos, key, e) {
	      var is_autorepeat, is_other_exclusive, potential_combo, result, _i, _len;
	      if (__indexOf.call(combo.keys, key) < 0) {
	        return false;
	      }
	      this._prevent_default(e, combo && combo.prevent_default);
	      is_autorepeat = false;
	      if (__indexOf.call(this._keys_down, key) >= 0) {
	        is_autorepeat = true;
	        if (!combo.allows_key_repeat()) {
	          return false;
	        }
	      }
	      result = this._add_to_active_combos(combo, key);
	      combo.keyup_fired = false;
	      is_other_exclusive = false;
	      if (combo.is_exclusive) {
	        for (_i = 0, _len = potential_combos.length; _i < _len; _i++) {
	          potential_combo = potential_combos[_i];
	          if (potential_combo.is_exclusive && potential_combo.keys.length > combo.keys.length) {
	            is_other_exclusive = true;
	            break;
	          }
	        }
	      }
	      if (!is_other_exclusive) {
	        if (combo.is_counting && typeof combo.on_keydown === "function") {
	          combo.count += 1;
	        }
	        if (result) {
	          return this._fire("keydown", combo, e, is_autorepeat);
	        }
	      }
	    };
	    Listener.prototype._key_up = function(key, e) {
	      var active_combo, active_combos_length, combo, combos, i, sequence_combo, shifted_key, unshifted_key, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
	      unshifted_key = key;
	      shifted_key = _convert_to_shifted_key(key, e);
	      if (shifted_key) {
	        key = shifted_key;
	      }
	      shifted_key = _keycode_shifted_keys[unshifted_key];
	      if (e.shiftKey) {
	        if (!(shifted_key && __indexOf.call(this._keys_down, shifted_key) >= 0)) {
	          key = unshifted_key;
	        }
	      } else {
	        if (!(unshifted_key && __indexOf.call(this._keys_down, unshifted_key) >= 0)) {
	          key = shifted_key;
	        }
	      }
	      sequence_combo = this._get_sequence(key);
	      if (sequence_combo) {
	        this._fire("keyup", sequence_combo, e);
	      }
	      if (__indexOf.call(this._keys_down, key) < 0) {
	        return false;
	      }
	      for (i = _i = 0, _ref = this._keys_down.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	        if ((_ref1 = this._keys_down[i]) === key || _ref1 === shifted_key || _ref1 === unshifted_key) {
	          this._keys_down.splice(i, 1);
	          break;
	        }
	      }
	      active_combos_length = this._active_combos.length;
	      combos = [];
	      _ref2 = this._active_combos;
	      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
	        active_combo = _ref2[_j];
	        if (__indexOf.call(active_combo.keys, key) >= 0) {
	          combos.push(active_combo);
	        }
	      }
	      for (_k = 0, _len1 = combos.length; _k < _len1; _k++) {
	        combo = combos[_k];
	        this._handle_combo_up(combo, e, key);
	      }
	      if (active_combos_length > 1) {
	        _ref3 = this._active_combos;
	        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
	          active_combo = _ref3[_l];
	          if (active_combo === void 0 || __indexOf.call(combos, active_combo) >= 0) {
	            continue;
	          }
	          if (!this._keys_remain(active_combo)) {
	            this._remove_from_active_combos(active_combo);
	          }
	        }
	      }
	    };
	    Listener.prototype._handle_combo_up = function(combo, e, key) {
	      var keys_down, keys_remaining;
	      this._prevent_default(e, combo && combo.prevent_default);
	      keys_remaining = this._keys_remain(combo);
	      if (!combo.keyup_fired) {
	        keys_down = this._keys_down.slice();
	        keys_down.push(key);
	        if (!combo.is_solitary || _compare_arrays(keys_down, combo.keys)) {
	          this._fire("keyup", combo, e);
	          if (combo.is_counting && typeof combo.on_keyup === "function" && typeof combo.on_keydown !== "function") {
	            combo.count += 1;
	          }
	        }
	      }
	      if (!keys_remaining) {
	        this._fire("release", combo, e);
	        this._remove_from_active_combos(combo);
	      }
	    };
	    Listener.prototype.simple_combo = function(keys, callback) {
	      return this.register_combo({
	        keys: keys,
	        on_keydown: callback
	      });
	    };
	    Listener.prototype.counting_combo = function(keys, count_callback) {
	      return this.register_combo({
	        keys: keys,
	        is_counting: true,
	        is_unordered: false,
	        on_keydown: count_callback
	      });
	    };
	    Listener.prototype.sequence_combo = function(keys, callback) {
	      return this.register_combo({
	        keys: keys,
	        on_keydown: callback,
	        is_sequence: true
	      });
	    };
	    Listener.prototype.register_combo = function(combo_dictionary) {
	      var combo, property, value, _ref;
	      if (typeof combo_dictionary["keys"] === "string") {
	        combo_dictionary["keys"] = combo_dictionary["keys"].split(" ");
	      }
	      _ref = this._defaults;
	      for (property in _ref) {
	        if (!__hasProp.call(_ref, property)) continue;
	        value = _ref[property];
	        if (combo_dictionary[property] === void 0) {
	          combo_dictionary[property] = value;
	        }
	      }
	      combo = new Combo(combo_dictionary);
	      if (_validate_combo(combo)) {
	        this._registered_combos.push(combo);
	        return combo;
	      }
	    };
	    Listener.prototype.register_many = function(combo_array) {
	      var combo, _i, _len, _results;
	      _results = [];
	      for (_i = 0, _len = combo_array.length; _i < _len; _i++) {
	        combo = combo_array[_i];
	        _results.push(this.register_combo(combo));
	      }
	      return _results;
	    };
	    Listener.prototype.unregister_combo = function(keys_or_combo) {
	      var combo, unregister_combo, _i, _len, _ref, _results;
	      if (!keys_or_combo) {
	        return false;
	      }
	      unregister_combo = (function(_this) {
	        return function(combo) {
	          var i, _i, _ref, _results;
	          _results = [];
	          for (i = _i = 0, _ref = _this._registered_combos.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	            if (combo === _this._registered_combos[i]) {
	              _this._registered_combos.splice(i, 1);
	              break;
	            } else {
	              _results.push(void 0);
	            }
	          }
	          return _results;
	        };
	      })(this);
	      if (keys_or_combo instanceof Combo) {
	        return unregister_combo(keys_or_combo);
	      } else {
	        if (typeof keys_or_combo === "string") {
	          keys_or_combo = keys_or_combo.split(" ");
	        }
	        _ref = this._registered_combos;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          combo = _ref[_i];
	          if (combo == null) {
	            continue;
	          }
	          if ((combo.is_unordered && _compare_arrays(keys_or_combo, combo.keys)) || (!combo.is_unordered && _compare_arrays_sorted(keys_or_combo, combo.keys))) {
	            _results.push(unregister_combo(combo));
	          } else {
	            _results.push(void 0);
	          }
	        }
	        return _results;
	      }
	    };
	    Listener.prototype.unregister_many = function(combo_array) {
	      var combo, _i, _len, _results;
	      _results = [];
	      for (_i = 0, _len = combo_array.length; _i < _len; _i++) {
	        combo = combo_array[_i];
	        _results.push(this.unregister_combo(combo));
	      }
	      return _results;
	    };
	    Listener.prototype.get_registered_combos = function() {
	      return this._registered_combos;
	    };
	    Listener.prototype.reset = function() {
	      return this._registered_combos = [];
	    };
	    Listener.prototype.listen = function() {
	      return this._prevent_capture = false;
	    };
	    Listener.prototype.stop_listening = function() {
	      return this._prevent_capture = true;
	    };
	    Listener.prototype.get_meta_key = function() {
	      return _metakey;
	    };
	    return Listener;
	  })();
	  _decide_meta_key = function() {
	    if (navigator.userAgent.indexOf("Mac OS X") !== -1) {
	      _metakey = "cmd";
	    }
	  };
	  _change_keycodes_by_browser = function() {
	    if (navigator.userAgent.indexOf("Opera") !== -1) {
	      _keycode_dictionary["17"] = "cmd";
	    }
	  };
	  _convert_key_to_readable = function(k) {
	    return _keycode_dictionary[k];
	  };
	  _filter_array = function(array, callback) {
	    var element;
	    if (array.filter) {
	      return array.filter(callback);
	    } else {
	      return (function() {
	        var _i, _len, _results;
	        _results = [];
	        for (_i = 0, _len = array.length; _i < _len; _i++) {
	          element = array[_i];
	          if (callback(element)) {
	            _results.push(element);
	          }
	        }
	        return _results;
	      })();
	    }
	  };
	  _compare_arrays = function(a1, a2) {
	    var item, _i, _len;
	    if (a1.length !== a2.length) {
	      return false;
	    }
	    for (_i = 0, _len = a1.length; _i < _len; _i++) {
	      item = a1[_i];
	      if (__indexOf.call(a2, item) >= 0) {
	        continue;
	      }
	      return false;
	    }
	    return true;
	  };
	  _compare_arrays_sorted = function(a1, a2) {
	    var i, _i, _ref;
	    if (a1.length !== a2.length) {
	      return false;
	    }
	    for (i = _i = 0, _ref = a1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	      if (a1[i] !== a2[i]) {
	        return false;
	      }
	    }
	    return true;
	  };
	  _is_array_in_array = function(a1, a2) {
	    var item, _i, _len;
	    for (_i = 0, _len = a1.length; _i < _len; _i++) {
	      item = a1[_i];
	      if (__indexOf.call(a2, item) < 0) {
	        return false;
	      }
	    }
	    return true;
	  };
	  _index_of_in_array = Array.prototype.indexOf || function(a, item) {
	    var i, _i, _ref;
	    for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
	      if (a[i] === item) {
	        return i;
	      }
	    }
	    return -1;
	  };
	  _is_array_in_array_sorted = function(a1, a2) {
	    var index, item, prev, _i, _len;
	    prev = 0;
	    for (_i = 0, _len = a1.length; _i < _len; _i++) {
	      item = a1[_i];
	      index = _index_of_in_array.call(a2, item);
	      if (index >= prev) {
	        prev = index;
	      } else {
	        return false;
	      }
	    }
	    return true;
	  };
	  _log_error = function() {
	    if (keypress.debug) {
	      return console.log.apply(console, arguments);
	    }
	  };
	  _key_is_valid = function(key) {
	    var valid, valid_key, _;
	    valid = false;
	    for (_ in _keycode_dictionary) {
	      valid_key = _keycode_dictionary[_];
	      if (key === valid_key) {
	        valid = true;
	        break;
	      }
	    }
	    if (!valid) {
	      for (_ in _keycode_shifted_keys) {
	        valid_key = _keycode_shifted_keys[_];
	        if (key === valid_key) {
	          valid = true;
	          break;
	        }
	      }
	    }
	    return valid;
	  };
	  _validate_combo = function(combo) {
	    var alt_name, i, key, mod_key, non_modifier_keys, property, validated, value, _i, _j, _k, _len, _len1, _ref, _ref1;
	    validated = true;
	    if (!combo.keys.length) {
	      _log_error("You're trying to bind a combo with no keys:", combo);
	    }
	    for (i = _i = 0, _ref = combo.keys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	      key = combo.keys[i];
	      alt_name = _keycode_alternate_names[key];
	      if (alt_name) {
	        key = combo.keys[i] = alt_name;
	      }
	      if (key === "meta") {
	        combo.keys.splice(i, 1, _metakey);
	      }
	      if (key === "cmd") {
	        _log_error("Warning: use the \"meta\" key rather than \"cmd\" for Windows compatibility");
	      }
	    }
	    _ref1 = combo.keys;
	    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
	      key = _ref1[_j];
	      if (!_key_is_valid(key)) {
	        _log_error("Do not recognize the key \"" + key + "\"");
	        validated = false;
	      }
	    }
	    if (__indexOf.call(combo.keys, "meta") >= 0 || __indexOf.call(combo.keys, "cmd") >= 0) {
	      non_modifier_keys = combo.keys.slice();
	      for (_k = 0, _len1 = _modifier_keys.length; _k < _len1; _k++) {
	        mod_key = _modifier_keys[_k];
	        if ((i = _index_of_in_array.call(non_modifier_keys, mod_key)) > -1) {
	          non_modifier_keys.splice(i, 1);
	        }
	      }
	      if (non_modifier_keys.length > 1) {
	        _log_error("META and CMD key combos cannot have more than 1 non-modifier keys", combo, non_modifier_keys);
	        validated = false;
	      }
	    }
	    for (property in combo) {
	      value = combo[property];
	      if (_factory_defaults[property] === "undefined") {
	        _log_error("The property " + property + " is not a valid combo property. Your combo has still been registered.");
	      }
	    }
	    return validated;
	  };
	  _convert_to_shifted_key = function(key, e) {
	    var k;
	    if (!e.shiftKey) {
	      return false;
	    }
	    k = _keycode_shifted_keys[key];
	    if (k != null) {
	      return k;
	    }
	    return false;
	  };
	  _modifier_event_mapping = {
	    "cmd": "metaKey",
	    "ctrl": "ctrlKey",
	    "shift": "shiftKey",
	    "alt": "altKey"
	  };
	  _keycode_alternate_names = {
	    "escape": "esc",
	    "control": "ctrl",
	    "command": "cmd",
	    "break": "pause",
	    "windows": "cmd",
	    "option": "alt",
	    "caps_lock": "caps",
	    "apostrophe": "\'",
	    "semicolon": ";",
	    "tilde": "~",
	    "accent": "`",
	    "scroll_lock": "scroll",
	    "num_lock": "num"
	  };
	  _keycode_shifted_keys = {
	    "/": "?",
	    ".": ">",
	    ",": "<",
	    "\'": "\"",
	    ";": ":",
	    "[": "{",
	    "]": "}",
	    "\\": "|",
	    "`": "~",
	    "=": "+",
	    "-": "_",
	    "1": "!",
	    "2": "@",
	    "3": "#",
	    "4": "$",
	    "5": "%",
	    "6": "^",
	    "7": "&",
	    "8": "*",
	    "9": "(",
	    "0": ")"
	  };
	  _keycode_dictionary = {
	    0: "\\",
	    8: "backspace",
	    9: "tab",
	    12: "num",
	    13: "enter",
	    16: "shift",
	    17: "ctrl",
	    18: "alt",
	    19: "pause",
	    20: "caps",
	    27: "esc",
	    32: "space",
	    33: "pageup",
	    34: "pagedown",
	    35: "end",
	    36: "home",
	    37: "left",
	    38: "up",
	    39: "right",
	    40: "down",
	    44: "print",
	    45: "insert",
	    46: "delete",
	    48: "0",
	    49: "1",
	    50: "2",
	    51: "3",
	    52: "4",
	    53: "5",
	    54: "6",
	    55: "7",
	    56: "8",
	    57: "9",
	    65: "a",
	    66: "b",
	    67: "c",
	    68: "d",
	    69: "e",
	    70: "f",
	    71: "g",
	    72: "h",
	    73: "i",
	    74: "j",
	    75: "k",
	    76: "l",
	    77: "m",
	    78: "n",
	    79: "o",
	    80: "p",
	    81: "q",
	    82: "r",
	    83: "s",
	    84: "t",
	    85: "u",
	    86: "v",
	    87: "w",
	    88: "x",
	    89: "y",
	    90: "z",
	    91: "cmd",
	    92: "cmd",
	    93: "cmd",
	    96: "num_0",
	    97: "num_1",
	    98: "num_2",
	    99: "num_3",
	    100: "num_4",
	    101: "num_5",
	    102: "num_6",
	    103: "num_7",
	    104: "num_8",
	    105: "num_9",
	    106: "num_multiply",
	    107: "num_add",
	    108: "num_enter",
	    109: "num_subtract",
	    110: "num_decimal",
	    111: "num_divide",
	    112: "f1",
	    113: "f2",
	    114: "f3",
	    115: "f4",
	    116: "f5",
	    117: "f6",
	    118: "f7",
	    119: "f8",
	    120: "f9",
	    121: "f10",
	    122: "f11",
	    123: "f12",
	    124: "print",
	    144: "num",
	    145: "scroll",
	    186: ";",
	    187: "=",
	    188: ",",
	    189: "-",
	    190: ".",
	    191: "/",
	    192: "`",
	    219: "[",
	    220: "\\",
	    221: "]",
	    222: "\'",
	    223: "`",
	    224: "cmd",
	    225: "alt",
	    57392: "ctrl",
	    63289: "num",
	    59: ";",
	    61: "-",
	    173: "="
	  };
	  keypress._keycode_dictionary = _keycode_dictionary;
	  keypress._is_array_in_array_sorted = _is_array_in_array_sorted;
	  _decide_meta_key();
	  _change_keycodes_by_browser();
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return keypress;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined" && exports !== null) {
	    exports.keypress = keypress;
	  } else {
	    window.keypress = keypress;
	  }
	}).call(this);
/***/ },
/* 15 */
/***/ function(module, exports) {
	/* Created by tommyZZM on 2015/10/24.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getElementAbsolute = getElementAbsolute;
	function getElementAbsolute(element) {
	    if (!element) {
	        return 0;
	    }
	    var actualLeft = element.offsetLeft;
	    var actualTop = element.offsetTop;
	    var current = element.offsetParent;
	    while (current !== null) {
	        actualLeft += current.offsetLeft;
	        actualTop += current.offsetTop;
	        current = current.offsetParent;
	    }
	    return { left: actualLeft, top: actualTop };
	}
/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {
	var jade = __webpack_require__(17);
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (JSON, data, name, style, tipsImage) {
	buf.push("<!--Created by tommyZZM on 2015/10/22.\n推荐位广告面板\n--><div>" + (((jade_interp = style) == null ? '' : jade_interp)) + "<div style=\"position:fixed;left:3%;\"" + (jade.cls([name+" common-container"], [true])) + "><div style=\"position:relative;border-radius: 16px;background:#ffffff;padding: 5px 0;z-index: 2;\">");
	for(var i=0;i<data.length;i++){
	buf.push("<div" + (jade.attr("data-meiriq-adv", JSON.stringify({url: data[i].link, packageName: data[i].name}), true, false)) + " class=\"item\"><img" + (jade.attr("src", data[i].picture, true, false)) + "/></div>");
	}
	buf.push("</div><div style=\"position: relative;width: 100%;text-align: center;z-index: 1;\" class=\"tips-wrapper\"><img style=\"width:60px\"" + (jade.attr("src", tipsImage, true, false)) + "/><p class=\"tips\">" + (jade.escape(null == (jade_interp = "") ? "" : jade_interp)) + "</p></div></div></div>");}.call(this,"JSON" in locals_for_with?locals_for_with.JSON:typeof JSON!=="undefined"?JSON:undefined,"data" in locals_for_with?locals_for_with.data:typeof data!=="undefined"?data:undefined,"name" in locals_for_with?locals_for_with.name:typeof name!=="undefined"?name:undefined,"style" in locals_for_with?locals_for_with.style:typeof style!=="undefined"?style:undefined,"tipsImage" in locals_for_with?locals_for_with.tipsImage:typeof tipsImage!=="undefined"?tipsImage:undefined));;return buf.join("");
	}
/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {
	'use strict';
	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */
	exports.merge = function merge(a, b) {
	  if (arguments.length === 1) {
	    var attrs = a[0];
	    for (var i = 1; i < a.length; i++) {
	      attrs = merge(attrs, a[i]);
	    }
	    return attrs;
	  }
	  var ac = a['class'];
	  var bc = b['class'];
	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    a['class'] = ac.concat(bc).filter(nulls);
	  }
	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }
	  return a;
	};
	/**
	 * Filter null `val`s.
	 *
	 * @param {*} val
	 * @return {Boolean}
	 * @api private
	 */
	function nulls(val) {
	  return val != null && val !== '';
	}
	/**
	 * join array as classes.
	 *
	 * @param {*} val
	 * @return {String}
	 */
	exports.joinClasses = joinClasses;
	function joinClasses(val) {
	  return (Array.isArray(val) ? val.map(joinClasses) :
	    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
	    [val]).filter(nulls).join(' ');
	}
	/**
	 * Render the given classes.
	 *
	 * @param {Array} classes
	 * @param {Array.<Boolean>} escaped
	 * @return {String}
	 */
	exports.cls = function cls(classes, escaped) {
	  var buf = [];
	  for (var i = 0; i < classes.length; i++) {
	    if (escaped && escaped[i]) {
	      buf.push(exports.escape(joinClasses([classes[i]])));
	    } else {
	      buf.push(joinClasses(classes[i]));
	    }
	  }
	  var text = joinClasses(buf);
	  if (text.length) {
	    return ' class="' + text + '"';
	  } else {
	    return '';
	  }
	};
	exports.style = function (val) {
	  if (val && typeof val === 'object') {
	    return Object.keys(val).map(function (style) {
	      return style + ':' + val[style];
	    }).join(';');
	  } else {
	    return val;
	  }
	};
	/**
	 * Render the given attribute.
	 *
	 * @param {String} key
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @param {Boolean} terse
	 * @return {String}
	 */
	exports.attr = function attr(key, val, escaped, terse) {
	  if (key === 'style') {
	    val = exports.style(val);
	  }
	  if ('boolean' == typeof val || null == val) {
	    if (val) {
	      return ' ' + (terse ? key : key + '="' + key + '"');
	    } else {
	      return '';
	    }
	  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	    if (JSON.stringify(val).indexOf('&') !== -1) {
	      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
	                   'will be escaped to `&amp;`');
	    };
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will eliminate the double quotes around dates in ' +
	                   'ISO form after 2.0.0');
	    }
	    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
	  } else if (escaped) {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + exports.escape(val) + '"';
	  } else {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + val + '"';
	  }
	};
	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 */
	exports.attrs = function attrs(obj, terse){
	  var buf = [];
	  var keys = Object.keys(obj);
	  if (keys.length) {
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i]
	        , val = obj[key];
	      if ('class' == key) {
	        if (val = joinClasses(val)) {
	          buf.push(' ' + key + '="' + val + '"');
	        }
	      } else {
	        buf.push(exports.attr(key, val, false, terse));
	      }
	    }
	  }
	  return buf.join('');
	};
	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */
	var jade_encode_html_rules = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	var jade_match_html = /[&<>"]/g;
	function jade_encode_char(c) {
	  return jade_encode_html_rules[c] || c;
	}
	exports.escape = jade_escape;
	function jade_escape(html){
	  var result = String(html).replace(jade_match_html, jade_encode_char);
	  if (result === '' + html) return html;
	  else return result;
	};
	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */
	exports.rethrow = function rethrow(err, filename, lineno, str){
	  if (!(err instanceof Error)) throw err;
	  if ((typeof window != 'undefined' || !filename) && !str) {
	    err.message += ' on line ' + lineno;
	    throw err;
	  }
	  try {
	    str = str || __webpack_require__(18).readFileSync(filename, 'utf8')
	  } catch (ex) {
	    rethrow(err, null, lineno)
	  }
	  var context = 3
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};
	exports.DebugItem = function DebugItem(lineno, filename) {
	  this.lineno = lineno;
	  this.filename = filename;
	}
/***/ },
/* 18 */
/***/ function(module, exports) {
	/* (ignored) */
/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/22.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	var _resDefine = __webpack_require__(6);
	var define = _interopRequireWildcard(_resDefine);
	var _resResource = __webpack_require__(11);
	var resource = _interopRequireWildcard(_resResource);
	var _resDataRepository = __webpack_require__(7);
	var _coreTVKeyEventManager = __webpack_require__(12);
	var _coreTVKeyEventManager2 = _interopRequireDefault(_coreTVKeyEventManager);
	var _coreHookManager = __webpack_require__(4);
	var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
	var _ComBase2 = __webpack_require__(9);
	var _ComBase3 = _interopRequireDefault(_ComBase2);
	var imageRes = __webpack_require__(11).imageRes;
	var ComFocusUsKit = (function (_ComBase) {
	    _inherits(ComFocusUsKit, _ComBase);
	    function ComFocusUsKit() {
	        _classCallCheck(this, ComFocusUsKit);
	        _get(Object.getPrototypeOf(ComFocusUsKit.prototype), "constructor", this).call(this, __webpack_require__(20), {
	            style: "<style rel=\"stylesheet\">\n                .focususkit.common-container{\n                    right: -310px;\n                    -webkit-transition: 0.82s;\n                }\n                .focususkit .item.QR-code{\n                    display: inline-block;\n                    padding: 2px;\n                    text-align: center;\n                }\n                .focususkit .item-wrapper p{\n                    color: #FF6600;\n                    white-space: pre-line;\n                    font-weight: bold;\n                    padding-bottom: 10px;\n                }\n                .focususkit .item.QR-code img{\n                    width: 112px;\n                }\n            </style>",
	            qr1: resource.TVAdvRes.defaultQR1,
	            qr2: resource.TVAdvRes.defaultQR2,
	            tipsImage: resource.TVAdvRes.focusPanel
	        }, "focususkit");
	        this.container = this.content.querySelector(".common-container");
	        this.tips = this.content.querySelector(".tips");
	        this.tipsWrapper = this.content.querySelector(".tips-wrapper");
	    }
	    _createClass(ComFocusUsKit, [{
	        key: "acitve",
	        value: function acitve() {
	            this.container.style.right = "0px";
	            this.tips.innerText = "按返回键收回";
	            this.isActive = true;
	        }
	    }, {
	        key: "disactive",
	        value: function disactive() {
	            this.container.style.right = "-310px";
	            this.tips.innerText = "按菜单键展开!";
	            this.isActive = false;
	        }
	    }]);
	    return ComFocusUsKit;
	})(_ComBase3["default"]);
	exports["default"] = new ComFocusUsKit();
	module.exports = exports["default"];
/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {
	var jade = __webpack_require__(17);
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (name, qr1, qr2, style, tipsImage) {
	buf.push("<!--Created by tommyZZM on 2015/10/22. 关注我们\n--><div>" + (((jade_interp = style) == null ? '' : jade_interp)) + "<div style=\"position:fixed;bottom:0;\"" + (jade.cls([name+" common-container"], [true])) + "><div style=\"top: -55px;position: relative;text-align: center;z-index: 1;display:inline-block\" class=\"tips-wrapper\"><p style=\"width: 130px;padding-bottom: 6px;\" class=\"tips\">" + (jade.escape(null == (jade_interp = "按返回键收回") ? "" : jade_interp)) + "</p><img style=\"width:160px\"" + (jade.attr("src", tipsImage, true, false)) + "/></div><div style=\"position:relative;border-radius: 16px;background:#ffffff;padding: 10px 20px;z-index: 2;display:inline-block\" class=\"item-wrapper\"><div style=\"padding-right: 30px;\" class=\"item QR-code\"><p>" + (jade.escape(null == (jade_interp = "每日Q\n电视游戏玩家群") ? "" : jade_interp)) + "</p><img" + (jade.attr("src", qr1, true, false)) + "/></div><div class=\"item QR-code\"><p>" + (jade.escape(null == (jade_interp = "每日Q\n公众微信号") ? "" : jade_interp)) + "</p><img" + (jade.attr("src", qr2, true, false)) + "/></div></div></div></div>");}.call(this,"name" in locals_for_with?locals_for_with.name:typeof name!=="undefined"?name:undefined,"qr1" in locals_for_with?locals_for_with.qr1:typeof qr1!=="undefined"?qr1:undefined,"qr2" in locals_for_with?locals_for_with.qr2:typeof qr2!=="undefined"?qr2:undefined,"style" in locals_for_with?locals_for_with.style:typeof style!=="undefined"?style:undefined,"tipsImage" in locals_for_with?locals_for_with.tipsImage:typeof tipsImage!=="undefined"?tipsImage:undefined));;return buf.join("");
	}
/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/24.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	var _ComBase2 = __webpack_require__(9);
	var _ComBase3 = _interopRequireDefault(_ComBase2);
	var ComFinger = (function (_ComBase) {
	    _inherits(ComFinger, _ComBase);
	    function ComFinger() {
	        _classCallCheck(this, ComFinger);
	        _get(Object.getPrototypeOf(ComFinger.prototype), "constructor", this).call(this, __webpack_require__(22), {
	            style: "<style rel=\"stylesheet\">\n            @keyframes meiriqTvFinger-hoz{\n                0%   {margin-left:-6px;}\n                50%  {margin-left:6px;}\n                100% {margin-left:-6px;}\n            }\n             @keyframes meiriqTvFinger-vert{\n                0%   {margin-top:-6px;}\n                50%  {margin-top:6px;}\n                100% {margin-top:-6px;}\n            }\n            </style>"
	        }, "finger");
	        this.content = this.content.children[0];
	        this.content.style.top = "-100px";
	        this.content.style.left = "-100px";
	        this.fingerImg = this.content.querySelector("img");
	        this.offsetPos = { x: 0, y: 0 };
	    }
	    _createClass(ComFinger, [{
	        key: "update",
	        value: function update() {
	            var args = arguments.length <= 0 || arguments[0] === undefined ? { top: -100, left: -100 } : arguments[0];
	            this.content.style.top = args.top + "px";
	            this.content.style.left = args.left + "px";
	        }
	    }, {
	        key: "setStyle",
	        value: function setStyle(offsetx, offsety, style) {
	            if (offsetx === undefined) offsetx = 0;
	            if (offsety === undefined) offsety = 0;
	            if (typeof style !== "string") {
	                this.fingerImg.setAttribute("style", "width:76px ; margin-top: 10px;");
	            } else {
	                this.fingerImg.setAttribute("style", style + " width:76px;");
	            }
	            if (offsety >= 1) {
	                this.content.style["-webkit-animation"] = "meiriqTvFinger-vert 0.66s infinite ease-in-out";
	            }
	            if (offsetx >= 1) {
	                this.content.style["-webkit-animation"] = "meiriqTvFinger-hoz 0.66s infinite ease-in-out";
	            }
	            this.offsetPos = { x: offsetx, y: offsety };
	        }
	    }]);
	    return ComFinger;
	})(_ComBase3["default"]);
	exports["default"] = new ComFinger();
	module.exports = exports["default"];
/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {
	var jade = __webpack_require__(17);
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (style) {
	buf.push("<div style=\"position:fixed;z-index: 10;pointer-events:none;\">" + (((jade_interp = style) == null ? '' : jade_interp)) + "<img style=\"width:76px;margin-top: 10px;\" src=\"data:image/png;base64,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\" class=\"meiriq-finger\"/></div>");}.call(this,"style" in locals_for_with?locals_for_with.style:typeof style!=="undefined"?style:undefined));;return buf.join("");
	}
/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/26.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	var _resDataRepository = __webpack_require__(7);
	var _ComBase2 = __webpack_require__(9);
	var _ComBase3 = _interopRequireDefault(_ComBase2);
	var ComAdvMask = (function (_ComBase) {
	    _inherits(ComAdvMask, _ComBase);
	    function ComAdvMask() {
	        _classCallCheck(this, ComAdvMask);
	        _get(Object.getPrototypeOf(ComAdvMask.prototype), "constructor", this).call(this, "<div style=\"position:fixed;top:0;left:0;right:0;bottom:0;z-index:20;\">\n        <style rel=\"stylesheet\">\n            @keyframes meiriqTvAdvMask-in{\n                0%\t{transform: rotate(0deg) scale(0.2,0.2);opacity: 0}\n                100%{transform: rotate(360deg) scale(1,1);opacity: 1}\n\t        }\n\t         @keyframes meiriqTvAdvMask-out{\n\t            0%\t{transform: scale(1,1);}\n                100%{transform: scale(0.2,0.2);opacity: 0}\n\t         }\n        </style>\n        <div style=\"position:absolute;width:100%;height:100%;background:#000;opacity:0.5;\"></div>\n        <div class=\"imgWrapper\">\n        <img style=\"position: relative;display: none\"/>\n        <img style=\"display: none;position: absolute;top: -60px;right: -160px;\" src=\"data:image/png;base64,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\">\n        </div>\n        </div>", null, "comadvmask");
	        this.img = this.content.querySelectorAll("img")[0];
	        this.imgTips = this.content.querySelectorAll("img")[1];
	        this.ImgWrapper = this.content.querySelector(".imgWrapper");
	        this.content["-webkit-transition"] = "0.2s";
	        this.content.style.opacity = 0;
	    }
	    _createClass(ComAdvMask, [{
	        key: "active",
	        value: function active() {
	            var _this = this;
	            this.img.src = (0, _resDataRepository.advertisingBig)()[0].picture;
	            this.img.setAttribute("data-meiriq-adv", JSON.stringify({ url: (0, _resDataRepository.advertisingBig)()[0].link, packageName: (0, _resDataRepository.advertisingBig)()[0].name }));
	            this.content.style.opacity = 1;
	            this.img.onload = function () {
	                _this.imgTips.style.display = "inline";
	                _this.img.style.display = "inline";
	                var width = _this.img.width;
	                var height = _this.img.height;
	                _this.ImgWrapper.setAttribute("style", "position: absolute;left: 50%;margin-left: " + (-width / 2 - 20) + "px;top: 50%;margin-top: " + -height / 2 + "px");
	                _this.img.style["-webkit-animation"] = "meiriqTvAdvMask-in 0.26s 1 ease-in-out";
	            };
	        }
	    }, {
	        key: "disactive",
	        value: function disactive(cb) {
	            var _this2 = this;
	            this.img.style["-webkit-animation"] = "meiriqTvAdvMask-out 0.26s 1 ease-in-out";
	            setTimeout(function () {
	                _this2.content.style.opacity = 0;
	                if (typeof cb === "function") {
	                    cb();
	                }
	            }, 230);
	        }
	    }, {
	        key: "enter",
	        value: function enter() {
	            var _this3 = this;
	            if (window.NativeInterface && typeof window.NativeInterface.downloadApk === "function") {
	                window.NativeInterface.downloadApk(this.img.getAttribute("data-meiriq-adv"));
	            } else {
	                console.warn("try enter:", this.img.getAttribute("data-meiriq-adv"));
	            }
	            var _cb = function _cb() {};
	            setTimeout(function () {
	                _cb(_this3.img.getAttribute("src"));
	            }, 300);
	            return {
	                then: function then(cb) {
	                    if (typeof cb === "function") _cb = cb;
	                }
	            };
	        }
	    }], [{
	        key: "nameC",
	        get: function get() {
	            return "comadvmask";
	        }
	    }]);
	    return ComAdvMask;
	})(_ComBase3["default"]);
	exports["default"] = ComAdvMask;
	module.exports = exports["default"];
/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/27.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	var _ComBase2 = __webpack_require__(9);
	var _ComBase3 = _interopRequireDefault(_ComBase2);
	var ComLBTipsPanel = (function (_ComBase) {
	    _inherits(ComLBTipsPanel, _ComBase);
	    function ComLBTipsPanel() {
	        _classCallCheck(this, ComLBTipsPanel);
	        _get(Object.getPrototypeOf(ComLBTipsPanel.prototype), "constructor", this).call(this, "\n        <style rel=\"stylesheet\">\n        .mrq-com-lbtipspanel ul.tips-wrapper{\n            list-style: none;\n        }\n        .mrq-com-lbtipspanel .tips-wrapper li{\n            padding: 6px;\n            color: #FF6600;\n            background: #fff;\n            border-radius: 6px;\n            margin-top: 5px;\n            opacity: 0.99;\n            font-size: 14px;\n            display: block;\n            overflow: hidden;\n        }\n        .mrq-com-lbtipspanel .tips-wrapper li img{\n            height: 60px;\n        }\n        </style>\n        <div style=\"position:fixed;left:0;bottom:0;z-index:23;\" class=\"mrq-com-lbtipspanel\">\n            <ul class=\"tips-wrapper\">\n\n            </ul>\n        </div>\n        ", {}, "lbtipspanel");
	        this.tipsWrapper = this.content.querySelector(".tips-wrapper");
	    }
	    _createClass(ComLBTipsPanel, [{
	        key: "pushMsg",
	        value: function pushMsg($arg) {
	            var _this = this;
	            var arg = $arg || " ";
	            if (typeof $arg === "string") {
	                arg = { msg: $arg };
	            }
	            var li = document.createElement("li");
	            var licontent = "<p>" + arg.msg + "</p>";
	            if (typeof arg.img === "string") {
	                licontent = "<img src=\"" + arg.img + "\"/>" + licontent;
	            }
	            li.innerHTML = licontent;
	            li.style.marginLeft = "-160px";
	            li.style.opacity = "0.1";
	            li.style["-webkit-transition"] = "0.6s";
	            setTimeout(function () {
	                li.style.opacity = "1";
	                li.style.marginLeft = "0";
	                setTimeout(function () {
	                    li.style.opacity = "0";
	                    li.style.marginLeft = "-200px";
	                    setTimeout(function () {
	                        _this.tipsWrapper.removeChild(li);
	                    }, 601);
	                }, 10000);
	            }, 200);
	            this.tipsWrapper.appendChild(li);
	        }
	    }]);
	    return ComLBTipsPanel;
	})(_ComBase3["default"]);
	exports["default"] = new ComLBTipsPanel();
	module.exports = exports["default"];
/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {
	/**
	 * Created by tommyZZM on 2015/11/19.
	 */
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	var _resResource = __webpack_require__(11);
	var resource = _interopRequireWildcard(_resResource);
	var _coreConfigureManager = __webpack_require__(8);
	var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
	var _coreHookManager = __webpack_require__(4);
	var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
	var _coreUIManager = __webpack_require__(5);
	var _coreUIManager2 = _interopRequireDefault(_coreUIManager);
	var _ComBase2 = __webpack_require__(9);
	var _ComBase3 = _interopRequireDefault(_ComBase2);
	var imageRes = resource.imageRes;
	var createBtn = window["meiriq"].lib.createBtn;
	var ComTvPausePanel = (function (_ComBase) {
	    _inherits(ComTvPausePanel, _ComBase);
	    function ComTvPausePanel() {
	        _classCallCheck(this, ComTvPausePanel);
	        _get(Object.getPrototypeOf(ComTvPausePanel.prototype), "constructor", this).call(this, __webpack_require__(26), {
	            size: _ComBase3["default"].getOverPanelSizeStyle,
	            mainicon: window["meiriq"].lib.defaultImageRes.win
	        }, "pausemaskpanel");
	        this.btnRes = {
	            resume: createBtn(imageRes.resumeUp, imageRes.resumeDown, function () {
	                _coreHookManager2["default"].excuteHook("tv:resume");
	            }),
	            exit: createBtn(imageRes.exitUp, imageRes.exitDown, function () {
	                _coreHookManager2["default"].excuteHook("tvExitGame");
	            }),
	            back2meun: createBtn(imageRes.backToMeunUp, imageRes.backToMeunDown, function () {
	                _coreHookManager2["default"].excuteHook("tv:back2meun"), adreceivecreateBtn();
	            })
	        };
	        this.currSelectItem;
	        this.currSelectItemName = 0;
	        this.buttonLayout = ["resume", "exit"];
	        this.currButtonLayout = [];
	        this.root = this.content.querySelector(".common-container");
	        this.btnWrap = this.content.querySelector(".btnWrap");
	    }
	    _createClass(ComTvPausePanel, [{
	        key: "getButton",
	        value: function getButton(name) {
	            return this.btnRes[name];
	        }
	    }, {
	        key: "active",
	        value: function active(img) {
	            var _this = this;
	            this.root.setAttribute("style", "position:fixed;border-radius: 20px;top: 46%;left: 50%;background:#ffffff;" + _ComBase3["default"].getOverPanelSizeStyle());
	            this.btnWrap.innerHTML = "";
	            this.currButtonLayout = [];
	            this.buttonLayout.forEach(function (btn) {
	                _this.btnWrap.appendChild(_this.btnRes[btn]);
	                _this.currButtonLayout.push(btn);
	            });
	            this.btnWrap.style.bottom = "3%";
	            if (typeof img === "string" && this.btnRes[img]) {
	                this.btnWrap.appendChild(this.btnRes[img]);
	                this.currButtonLayout.push(img);
	                this.btnWrap.style.bottom = "-20%";
	            }
	        }
	    }, {
	        key: "selectItem",
	        value: function selectItem() {
	            var count = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	            if (typeof count !== "number") count = 0;
	            this.currSelectItemName += count;
	            if (this.currSelectItemName > this.currButtonLayout.length - 1) {
	                this.currSelectItemName = 0;
	            }
	            if (this.currSelectItemName < 0) {
	                this.currSelectItemName = this.currButtonLayout.length - 1;
	            }
	            this.currSelectItem = this.btnRes[this.currButtonLayout[this.currSelectItemName]];
	            return this.currSelectItem;
	        }
	    }, {
	        key: "enterItem",
	        value: function enterItem() {
	            var _this2 = this;
	            var btnname = this.currButtonLayout[this.currSelectItemName];
	            switch (btnname) {
	                case "resume":
	                    {
	                        setTimeout(function () {
	                            _coreHookManager2["default"].excuteHook("tv:resume");
	                            _this2.currSelectItem.up();
	                        }, 200);
	                        this.currSelectItem.down();
	                        break;
	                    }
	                case "exit":
	                    {
	                        setTimeout(function () {
	                            _coreHookManager2["default"].excuteHook("tv:exit");
	                            _this2.currSelectItem.up();
	                        }, 200);
	                        this.currSelectItem.down();
	                        break;
	                    }
	                case "back2meun":
	                    {
	                        setTimeout(function () {
	                            _coreHookManager2["default"].excuteHook("tv:back2meun");
	                            _this2.currSelectItem.up();
	                        }, 200);
	                        this.currSelectItem.down();
	                        break;
	                    }
	                case "adreceive":
	                    {
	                        setTimeout(function () {
	                            _coreHookManager2["default"].excuteHook("tv:adreceive");
	                            _this2.currSelectItem.up();
	                        }, 200);
	                        this.currSelectItem.down();
	                        break;
	                    }
	                case "adreject":
	                    {
	                        setTimeout(function () {
	                            _coreHookManager2["default"].excuteHook("tv:adreject");
	                            _this2.currSelectItem.up();
	                        }, 200);
	                        this.currSelectItem.down();
	                    }
	            }
	        }
	    }, {
	        key: "update",
	        value: function update() {
	        }
	    }]);
	    return ComTvPausePanel;
	})(_ComBase3["default"]);
	exports["default"] = new ComTvPausePanel();
	module.exports = exports["default"];
/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {
	var jade = __webpack_require__(17);
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (mainicon, name, size) {
	buf.push("<!--Created by tommyZZM on 2015/11/19.\n--><div><div style=\"position:fixed;background-color:black;width:100%;height:100%;opacity:0.6\"></div><div" + (jade.attr("style", "position:fixed;border-radius: 20px;top: 50%;left: 50%;background:#ffffff;"+size(), true, false)) + (jade.cls([name+" common-container"], [true])) + "><div style=\"width:100%;text-align: center;position: relative;padding: 20px 0;padding-top: 23px;\"><span style=\"font-family: SimHei;color:#565656;font-size: 1.5em;\">" + (jade.escape(null == (jade_interp = "暂停游戏") ? "" : jade_interp)) + "</span></div><div style=\"width:100%;\"><span style=\"font-family: SimHei;color:#565656;font-size: 1em;\"></span></div><div style=\"position:relative;width:100%;margin-top: 0%;text-align: center;top: 0%;\" class=\"imgWrap\"><img style=\"width:50%\"" + (jade.attr("src", mainicon, true, false)) + "/></div><div style=\"text-align: center;position: absolute;bottom: 3%;width: 100%;\" class=\"btnWrap\"></div></div></div>");}.call(this,"mainicon" in locals_for_with?locals_for_with.mainicon:typeof mainicon!=="undefined"?mainicon:undefined,"name" in locals_for_with?locals_for_with.name:typeof name!=="undefined"?name:undefined,"size" in locals_for_with?locals_for_with.size:typeof size!=="undefined"?size:undefined));;return buf.join("");
	}
/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/19.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	var _coreHookManager = __webpack_require__(4);
	var _coreHookManager2 = _interopRequireDefault(_coreHookManager);
	var _coreTVKeyEventManager = __webpack_require__(12);
	var _coreTVKeyEventManager2 = _interopRequireDefault(_coreTVKeyEventManager);
	var _coreUIManager = __webpack_require__(5);
	var _coreUIManager2 = _interopRequireDefault(_coreUIManager);
	var _resDefineJs = __webpack_require__(6);
	var define = _interopRequireWildcard(_resDefineJs);
	var KeyCodeUsualDefArr = define.KeyCodeUsualDefArr;
	var tmpkeyparam = { keyname: null, device: null };
	var _thatConditions;
	var Conditions = (function () {
	    function Conditions() {
	        var _this = this;
	        _classCallCheck(this, Conditions);
	        KeyCodeUsualDefArr.forEach(function (keydef) {
	            keydef = keydef.toLowerCase();
	            keydef = keydef.split("&");
	            _thatConditions = _this;
	            _this["on" + keydef[0] + "Down"] = function (checkDevice) {
	                if (keydef.length >= 0) {
	                    return keydef.some(function (key) {
	                        return _coreTVKeyEventManager2["default"].isKeyNameTouching(key, checkDevice);
	                    });
	                }
	                return _coreTVKeyEventManager2["default"].isKeyNameTouching(keydef[0], checkDevice);
	            };
	            _this["on" + keydef[0] + "Up"] = function (checkDevice) {
	                if (keydef.length >= 0) {
	                    return keydef.every(function (key) {
	                        return !_coreTVKeyEventManager2["default"].isKeyNameTouching(key, checkDevice);
	                    });
	                }
	                return !_coreTVKeyEventManager2["default"].isKeyNameTouching(keydef[0], checkDevice);
	            };
	            _this["is" + keydef[0] + "Touching"] = _this["on" + keydef[0] + "Down"];
	        });
	    }
	    _createClass(Conditions, [{
	        key: "activeListeners",
	        value: function activeListeners(runtime, thisObject) {
	            var _this2 = this;
	            this.tmpkeyparam = tmpkeyparam;
	            _coreTVKeyEventManager2["default"].addListener(define.KeyEventType.DOWN, function (keycode, device) {
	                console.log(_coreUIManager2["default"].isPreventKeyEventToGame);
	                if (_coreUIManager2["default"].isPreventKeyEventToGame) return;
	                _this2.tmpkeyparam.keyname = define.KeyCode2Name[keycode];
	                _this2.tmpkeyparam.device = device;
	                runtime.trigger(_this2.onSomeKeyDownByName, thisObject);
	                _this2.tmpkeyparam.keyname = null;
	                _this2.tmpkeyparam.device = null;
	            });
	            _coreTVKeyEventManager2["default"].addListener(define.KeyEventType.UP, function (keycode, device) {
	                if (_coreUIManager2["default"].isPreventKeyEventToGame) return;
	                _this2.tmpkeyparam.keyname = define.KeyCode2Name[keycode];
	                _this2.tmpkeyparam.device = device;
	                runtime.trigger(_this2.onSomeKeyUpByName, thisObject);
	                _this2.tmpkeyparam.keyname = null;
	                _this2.tmpkeyparam.device = null;
	            }, this, -10);
	        }
	    }, {
	        key: "isSomeKeyTouchingByName",
	        value: function isSomeKeyTouchingByName(checkKeyDefname, checkDevice) {
	            if (_coreUIManager2["default"].isPreventKeyEventToGame) return false;
	            return _coreTVKeyEventManager2["default"].isKeyNameTouching(checkKeyDefname, checkDevice);
	        }
	    }, {
	        key: "onSomeKeyDownByName",
	        value: function onSomeKeyDownByName(checkKeyDefname, checkDevice) {
	            if (checkKeyDefname !== tmpkeyparam.keyname) {
	                return;
	            }
	            var that = _thatConditions;
	            if (typeof that["on" + checkKeyDefname + "Down"] === "function") {
	                return that["on" + checkKeyDefname + "Down"](checkDevice);
	            }
	            return false;
	        }
	    }, {
	        key: "onSomeKeyUpByName",
	        value: function onSomeKeyUpByName(checkKeyDefname, checkDevice) {
	            if (checkKeyDefname !== tmpkeyparam.keyname) {
	                return;
	            }
	            var that = _thatConditions;
	            if (typeof that["on" + checkKeyDefname + "Up"] === "function") {
	                return that["on" + checkKeyDefname + "Up"](checkDevice);
	            }
	            return false;
	        }
	    }]);
	    return Conditions;
	})();
	exports["default"] = Conditions;
	module.exports = exports["default"];
/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {
	/* Created by tommyZZM on 2015/10/20.*/
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	var _coreConfigureManager = __webpack_require__(8);
	var _coreConfigureManager2 = _interopRequireDefault(_coreConfigureManager);
	var _resDefineJs = __webpack_require__(6);
	var define = _interopRequireWildcard(_resDefineJs);
	var Expressions = (function () {
	    function Expressions() {
	        _classCallCheck(this, Expressions);
	        for (var keydef in define.KeyCodeUsualDef) {
	            this.defAExpression("Key_" + keydef, keydef.toLowerCase());
	        }
	    }
	    _createClass(Expressions, [{
	        key: "defAExpression",
	        value: function defAExpression(name, value) {
	            var type = arguments.length <= 2 || arguments[2] === undefined ? "string" : arguments[2];
	            this[name] = function (ret) {
	                ret["set_" + type](value);
	            };
	        }
	    }, {
	        key: "isPausing",
	        value: function isPausing(ret) {
	            ret["set_int"](_coreConfigureManager2["default"].getConfig().tvData.isPausing ? 1 : 0);
	        }
	    }]);
	    return Expressions;
	})();
	exports["default"] = Expressions;
	module.exports = exports["default"];
/***/ }
/******/ ]);
;
;
cr.plugins_.Particles = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Particles.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
		if (this.is_family)
			return;
		this.texture_img = new Image();
		this.texture_img.cr_filesize = this.texture_filesize;
		this.webGL_texture = null;
		this.runtime.waitForImageLoad(this.texture_img, this.texture_file);
	};
	typeProto.onLostWebGLContext = function ()
	{
		if (this.is_family)
			return;
		this.webGL_texture = null;
	};
	typeProto.onRestoreWebGLContext = function ()
	{
		if (this.is_family || !this.instances.length)
			return;
		if (!this.webGL_texture)
		{
			this.webGL_texture = this.runtime.glwrap.loadTexture(this.texture_img, true, this.runtime.linearSampling, this.texture_pixelformat);
		}
	};
	typeProto.loadTextures = function ()
	{
		if (this.is_family || this.webGL_texture || !this.runtime.glwrap)
			return;
		this.webGL_texture = this.runtime.glwrap.loadTexture(this.texture_img, true, this.runtime.linearSampling, this.texture_pixelformat);
	};
	typeProto.unloadTextures = function ()
	{
		if (this.is_family || this.instances.length || !this.webGL_texture)
			return;
		this.runtime.glwrap.deleteTexture(this.webGL_texture);
		this.webGL_texture = null;
	};
	typeProto.preloadCanvas2D = function (ctx)
	{
		ctx.drawImage(this.texture_img, 0, 0);
	};
	function Particle(owner)
	{
		this.owner = owner;
		this.active = false;
		this.x = 0;
		this.y = 0;
		this.speed = 0;
		this.angle = 0;
		this.opacity = 1;
		this.grow = 0;
		this.size = 0;
		this.gs = 0;			// gravity speed
		this.age = 0;
		cr.seal(this);
	};
	Particle.prototype.init = function ()
	{
		var owner = this.owner;
		this.x = owner.x - (owner.xrandom / 2) + (Math.random() * owner.xrandom);
		this.y = owner.y - (owner.yrandom / 2) + (Math.random() * owner.yrandom);
		this.speed = owner.initspeed - (owner.speedrandom / 2) + (Math.random() * owner.speedrandom);
		this.angle = owner.angle - (owner.spraycone / 2) + (Math.random() * owner.spraycone);
		this.opacity = owner.initopacity;
		this.size = owner.initsize - (owner.sizerandom / 2) + (Math.random() * owner.sizerandom);
		this.grow = owner.growrate - (owner.growrandom / 2) + (Math.random() * owner.growrandom);
		this.gs = 0;
		this.age = 0;
	};
	Particle.prototype.tick = function (dt)
	{
		var owner = this.owner;
		this.x += Math.cos(this.angle) * this.speed * dt;
		this.y += Math.sin(this.angle) * this.speed * dt;
		this.y += this.gs * dt;
		this.speed += owner.acc * dt;
		this.size += this.grow * dt;
		this.gs += owner.g * dt;
		this.age += dt;
		if (this.size < 1)
		{
			this.active = false;
			return;
		}
		if (owner.lifeanglerandom !== 0)
			this.angle += (Math.random() * owner.lifeanglerandom * dt) - (owner.lifeanglerandom * dt / 2);
		if (owner.lifespeedrandom !== 0)
			this.speed += (Math.random() * owner.lifespeedrandom * dt) - (owner.lifespeedrandom * dt / 2);
		if (owner.lifeopacityrandom !== 0)
		{
			this.opacity += (Math.random() * owner.lifeopacityrandom * dt) - (owner.lifeopacityrandom * dt / 2);
			if (this.opacity < 0)
				this.opacity = 0;
			else if (this.opacity > 1)
				this.opacity = 1;
		}
		if (owner.destroymode <= 1 && this.age >= owner.timeout)
		{
			this.active = false;
		}
		if (owner.destroymode === 2 && this.speed <= 0)
		{
			this.active = false;
		}
	};
	Particle.prototype.draw = function (ctx)
	{
		var curopacity = this.owner.opacity * this.opacity;
		if (curopacity === 0)
			return;
		if (this.owner.destroymode === 0)
			curopacity *= 1 - (this.age / this.owner.timeout);
		ctx.globalAlpha = curopacity;
		var drawx = this.x - this.size / 2;
		var drawy = this.y - this.size / 2;
		if (this.owner.runtime.pixel_rounding)
		{
			drawx = (drawx + 0.5) | 0;
			drawy = (drawy + 0.5) | 0;
		}
		ctx.drawImage(this.owner.type.texture_img, drawx, drawy, this.size, this.size);
	};
	Particle.prototype.drawGL = function (glw)
	{
		var curopacity = this.owner.opacity * this.opacity;
		if (this.owner.destroymode === 0)
			curopacity *= 1 - (this.age / this.owner.timeout);
		var drawsize = this.size;
		var scaleddrawsize = drawsize * this.owner.particlescale;
		var drawx = this.x - drawsize / 2;
		var drawy = this.y - drawsize / 2;
		if (this.owner.runtime.pixel_rounding)
		{
			drawx = (drawx + 0.5) | 0;
			drawy = (drawy + 0.5) | 0;
		}
		if (scaleddrawsize < 1 || curopacity === 0)
			return;
		if (scaleddrawsize < glw.minPointSize || scaleddrawsize > glw.maxPointSize)
		{
			glw.setOpacity(curopacity);
			glw.quad(drawx, drawy, drawx + drawsize, drawy, drawx + drawsize, drawy + drawsize, drawx, drawy + drawsize);
		}
		else
			glw.point(this.x, this.y, scaleddrawsize, curopacity);
	};
	Particle.prototype.left = function ()
	{
		return this.x - this.size / 2;
	};
	Particle.prototype.right = function ()
	{
		return this.x + this.size / 2;
	};
	Particle.prototype.top = function ()
	{
		return this.y - this.size / 2;
	};
	Particle.prototype.bottom = function ()
	{
		return this.y + this.size / 2;
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
	};
	var instanceProto = pluginProto.Instance.prototype;
	var deadparticles = [];
	instanceProto.onCreate = function()
	{
		var props = this.properties;
		this.rate = props[0];
		this.spraycone = cr.to_radians(props[1]);
		this.spraytype = props[2];			// 0 = continuous, 1 = one-shot
		this.spraying = true;				// for continuous mode only
		this.initspeed = props[3];
		this.initsize = props[4];
		this.initopacity = props[5] / 100.0;
		this.growrate = props[6];
		this.xrandom = props[7];
		this.yrandom = props[8];
		this.speedrandom = props[9];
		this.sizerandom = props[10];
		this.growrandom = props[11];
		this.acc = props[12];
		this.g = props[13];
		this.lifeanglerandom = props[14];
		this.lifespeedrandom = props[15];
		this.lifeopacityrandom = props[16];
		this.destroymode = props[17];		// 0 = fade, 1 = timeout, 2 = stopped
		this.timeout = props[18];
		this.particleCreateCounter = 0;
		this.particlescale = 1;
		this.particleBoxLeft = this.x;
		this.particleBoxTop = this.y;
		this.particleBoxRight = this.x;
		this.particleBoxBottom = this.y;
		this.add_bbox_changed_callback(function (self) {
			self.bbox.set(self.particleBoxLeft, self.particleBoxTop, self.particleBoxRight, self.particleBoxBottom);
			self.bquad.set_from_rect(self.bbox);
			self.bbox_changed = false;
			self.update_collision_cell();
			self.update_render_cell();
		});
		if (!this.recycled)
			this.particles = [];
		this.runtime.tickMe(this);
		this.type.loadTextures();
		if (this.spraytype === 1)
		{
			for (var i = 0; i < this.rate; i++)
				this.allocateParticle().opacity = 0;
		}
		this.first_tick = true;		// for re-init'ing one-shot particles on first tick so they assume any new angle/position
	};
	instanceProto.saveToJSON = function ()
	{
		var o = {
			"r": this.rate,
			"sc": this.spraycone,
			"st": this.spraytype,
			"s": this.spraying,
			"isp": this.initspeed,
			"isz": this.initsize,
			"io": this.initopacity,
			"gr": this.growrate,
			"xr": this.xrandom,
			"yr": this.yrandom,
			"spr": this.speedrandom,
			"szr": this.sizerandom,
			"grnd": this.growrandom,
			"acc": this.acc,
			"g": this.g,
			"lar": this.lifeanglerandom,
			"lsr": this.lifespeedrandom,
			"lor": this.lifeopacityrandom,
			"dm": this.destroymode,
			"to": this.timeout,
			"pcc": this.particleCreateCounter,
			"ft": this.first_tick,
			"p": []
		};
		var i, len, p;
		var arr = o["p"];
		for (i = 0, len = this.particles.length; i < len; i++)
		{
			p = this.particles[i];
			arr.push([p.x, p.y, p.speed, p.angle, p.opacity, p.grow, p.size, p.gs, p.age]);
		}
		return o;
	};
	instanceProto.loadFromJSON = function (o)
	{
		this.rate = o["r"];
		this.spraycone = o["sc"];
		this.spraytype = o["st"];
		this.spraying = o["s"];
		this.initspeed = o["isp"];
		this.initsize = o["isz"];
		this.initopacity = o["io"];
		this.growrate = o["gr"];
		this.xrandom = o["xr"];
		this.yrandom = o["yr"];
		this.speedrandom = o["spr"];
		this.sizerandom = o["szr"];
		this.growrandom = o["grnd"];
		this.acc = o["acc"];
		this.g = o["g"];
		this.lifeanglerandom = o["lar"];
		this.lifespeedrandom = o["lsr"];
		this.lifeopacityrandom = o["lor"];
		this.destroymode = o["dm"];
		this.timeout = o["to"];
		this.particleCreateCounter = o["pcc"];
		this.first_tick = o["ft"];
		deadparticles.push.apply(deadparticles, this.particles);
		cr.clearArray(this.particles);
		var i, len, p, d;
		var arr = o["p"];
		for (i = 0, len = arr.length; i < len; i++)
		{
			p = this.allocateParticle();
			d = arr[i];
			p.x = d[0];
			p.y = d[1];
			p.speed = d[2];
			p.angle = d[3];
			p.opacity = d[4];
			p.grow = d[5];
			p.size = d[6];
			p.gs = d[7];
			p.age = d[8];
		}
	};
	instanceProto.onDestroy = function ()
	{
		deadparticles.push.apply(deadparticles, this.particles);
		cr.clearArray(this.particles);
	};
	instanceProto.allocateParticle = function ()
	{
		var p;
		if (deadparticles.length)
		{
			p = deadparticles.pop();
			p.owner = this;
		}
		else
			p = new Particle(this);
		this.particles.push(p);
		p.active = true;
		return p;
	};
	instanceProto.tick = function()
	{
		var dt = this.runtime.getDt(this);
		var i, len, p, n, j;
		if (this.spraytype === 0 && this.spraying)
		{
			this.particleCreateCounter += dt * this.rate;
			n = cr.floor(this.particleCreateCounter);
			this.particleCreateCounter -= n;
			for (i = 0; i < n; i++)
			{
				p = this.allocateParticle();
				p.init();
			}
		}
		this.particleBoxLeft = this.x;
		this.particleBoxTop = this.y;
		this.particleBoxRight = this.x;
		this.particleBoxBottom = this.y;
		for (i = 0, j = 0, len = this.particles.length; i < len; i++)
		{
			p = this.particles[i];
			this.particles[j] = p;
			this.runtime.redraw = true;
			if (this.spraytype === 1 && this.first_tick)
				p.init();
			p.tick(dt);
			if (!p.active)
			{
				deadparticles.push(p);
				continue;
			}
			if (p.left() < this.particleBoxLeft)
				this.particleBoxLeft = p.left();
			if (p.right() > this.particleBoxRight)
				this.particleBoxRight = p.right();
			if (p.top() < this.particleBoxTop)
				this.particleBoxTop = p.top();
			if (p.bottom() > this.particleBoxBottom)
				this.particleBoxBottom = p.bottom();
			j++;
		}
		cr.truncateArray(this.particles, j);
		this.set_bbox_changed();
		this.first_tick = false;
		if (this.spraytype === 1 && this.particles.length === 0)
			this.runtime.DestroyInstance(this);
	};
	instanceProto.draw = function (ctx)
	{
		var i, len, p, layer = this.layer;
		for (i = 0, len = this.particles.length; i < len; i++)
		{
			p = this.particles[i];
			if (p.right() >= layer.viewLeft && p.bottom() >= layer.viewTop && p.left() <= layer.viewRight && p.top() <= layer.viewBottom)
			{
				p.draw(ctx);
			}
		}
	};
	instanceProto.drawGL = function (glw)
	{
		this.particlescale = this.layer.getScale();
		glw.setTexture(this.type.webGL_texture);
		var i, len, p, layer = this.layer;
		for (i = 0, len = this.particles.length; i < len; i++)
		{
			p = this.particles[i];
			if (p.right() >= layer.viewLeft && p.bottom() >= layer.viewTop && p.left() <= layer.viewRight && p.top() <= layer.viewBottom)
			{
				p.drawGL(glw);
			}
		}
	};
	function Cnds() {};
	Cnds.prototype.IsSpraying = function ()
	{
		return this.spraying;
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.SetSpraying = function (set_)
	{
		this.spraying = (set_ !== 0);
	};
	Acts.prototype.SetEffect = function (effect)
	{
		this.blend_mode = effect;
		this.compositeOp = cr.effectToCompositeOp(effect);
		cr.setGLBlend(this, effect, this.runtime.gl);
		this.runtime.redraw = true;
	};
	Acts.prototype.SetRate = function (x)
	{
		this.rate = x;
		var diff, i;
		if (this.spraytype === 1 && this.first_tick)
		{
			if (x < this.particles.length)
			{
				diff = this.particles.length - x;
				for (i = 0; i < diff; i++)
					deadparticles.push(this.particles.pop());
			}
			else if (x > this.particles.length)
			{
				diff = x - this.particles.length;
				for (i = 0; i < diff; i++)
					this.allocateParticle().opacity = 0;
			}
		}
	};
	Acts.prototype.SetSprayCone = function (x)
	{
		this.spraycone = cr.to_radians(x);
	};
	Acts.prototype.SetInitSpeed = function (x)
	{
		this.initspeed = x;
	};
	Acts.prototype.SetInitSize = function (x)
	{
		this.initsize = x;
	};
	Acts.prototype.SetInitOpacity = function (x)
	{
		this.initopacity = x / 100;
	};
	Acts.prototype.SetGrowRate = function (x)
	{
		this.growrate = x;
	};
	Acts.prototype.SetXRandomiser = function (x)
	{
		this.xrandom = x;
	};
	Acts.prototype.SetYRandomiser = function (x)
	{
		this.yrandom = x;
	};
	Acts.prototype.SetSpeedRandomiser = function (x)
	{
		this.speedrandom = x;
	};
	Acts.prototype.SetSizeRandomiser = function (x)
	{
		this.sizerandom = x;
	};
	Acts.prototype.SetGrowRateRandomiser = function (x)
	{
		this.growrandom = x;
	};
	Acts.prototype.SetParticleAcc = function (x)
	{
		this.acc = x;
	};
	Acts.prototype.SetGravity = function (x)
	{
		this.g = x;
	};
	Acts.prototype.SetAngleRandomiser = function (x)
	{
		this.lifeanglerandom = x;
	};
	Acts.prototype.SetLifeSpeedRandomiser = function (x)
	{
		this.lifespeedrandom = x;
	};
	Acts.prototype.SetOpacityRandomiser = function (x)
	{
		this.lifeopacityrandom = x;
	};
	Acts.prototype.SetTimeout = function (x)
	{
		this.timeout = x;
	};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.ParticleCount = function (ret)
	{
		ret.set_int(this.particles.length);
	};
	Exps.prototype.Rate = function (ret)
	{
		ret.set_float(this.rate);
	};
	Exps.prototype.SprayCone = function (ret)
	{
		ret.set_float(cr.to_degrees(this.spraycone));
	};
	Exps.prototype.InitSpeed = function (ret)
	{
		ret.set_float(this.initspeed);
	};
	Exps.prototype.InitSize = function (ret)
	{
		ret.set_float(this.initsize);
	};
	Exps.prototype.InitOpacity = function (ret)
	{
		ret.set_float(this.initopacity * 100);
	};
	Exps.prototype.InitGrowRate = function (ret)
	{
		ret.set_float(this.growrate);
	};
	Exps.prototype.XRandom = function (ret)
	{
		ret.set_float(this.xrandom);
	};
	Exps.prototype.YRandom = function (ret)
	{
		ret.set_float(this.yrandom);
	};
	Exps.prototype.InitSpeedRandom = function (ret)
	{
		ret.set_float(this.speedrandom);
	};
	Exps.prototype.InitSizeRandom = function (ret)
	{
		ret.set_float(this.sizerandom);
	};
	Exps.prototype.InitGrowRandom = function (ret)
	{
		ret.set_float(this.growrandom);
	};
	Exps.prototype.ParticleAcceleration = function (ret)
	{
		ret.set_float(this.acc);
	};
	Exps.prototype.Gravity = function (ret)
	{
		ret.set_float(this.g);
	};
	Exps.prototype.ParticleAngleRandom = function (ret)
	{
		ret.set_float(this.lifeanglerandom);
	};
	Exps.prototype.ParticleSpeedRandom = function (ret)
	{
		ret.set_float(this.lifespeedrandom);
	};
	Exps.prototype.ParticleOpacityRandom = function (ret)
	{
		ret.set_float(this.lifeopacityrandom);
	};
	Exps.prototype.Timeout = function (ret)
	{
		ret.set_float(this.timeout);
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.plugins_.Rex_FSM = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Rex_FSM.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var behtypeProto = pluginProto.Type.prototype;
	behtypeProto.onCreate = function()
	{
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onCreate = function()
	{
        this.activated = (this.properties[0] == 1);
		var previous_state = "Off";
		var current_state = this.properties[1];
        current_state = (current_state!="")? current_state:"Off";
        if (!this.recycled)
            this.fsm = new cr.plugins_.Rex_FSM.FSMKlass(this, previous_state, current_state);
        else
            this.fsm.Reset(this, previous_state, current_state);
        this.check_state = null;
        this.check_state2 = null;
        this.is_echo = false;
        this.next_state = null;
	};
    instanceProto.run_trigger = function(trigger)
    {
        this.is_echo = false;
        this.runtime.trigger(trigger, this);
        return (this.is_echo);
    };
    instanceProto.get_next_state = function()
    {
        this.next_state = null;
		var is_echo = this.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnLogic);
		if (!is_echo)
		    this.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnDefaultLogic);
        return this.next_state;
    };
	instanceProto.saveToJSON = function ()
	{
		return { "en": this.activated,
		         "fsm": this.fsm.saveToJSON()
		         };
	};
	instanceProto.loadFromJSON = function (o)
	{
	    this.activated = o["en"];
	    this.fsm.loadFromJSON(o["fsm"]);
	};
	function Cnds() {};
	pluginProto.cnds = new Cnds();
	Cnds.prototype.OnEnter = function (name)
	{
	    var is_my_handler = (this.check_state == name);
        this.is_echo |= is_my_handler;
		return is_my_handler;
	};
	Cnds.prototype.OnDefaultEnter = function ()
	{
		return true;
	};
	Cnds.prototype.OnExit = function (name)
	{
	    var is_my_handler = (this.check_state == name);
        this.is_echo |= is_my_handler;
		return is_my_handler;
	};
	Cnds.prototype.OnDefaultExit = function ()
	{
		return true;
	};
	Cnds.prototype.OnTransfer = function (name_from, name_to)
	{
	    var is_my_handler = (this.check_state == name_from) && (this.check_state2 == name_to);
        this.is_echo |= is_my_handler;
		return is_my_handler;
	};
	Cnds.prototype.OnStateChanged = function ()
	{
		return true;
	};
	Cnds.prototype.OnLogic = function (name)
	{
        var is_my_handler = (this.fsm.CurState == name);
        this.is_echo |= is_my_handler;
		return is_my_handler;
	};
	Cnds.prototype.IsCurState = function (name)
	{
		return (this.fsm.CurState == name);
	};
	Cnds.prototype.IsPreState = function (name)
	{
		return (this.fsm.PreState == name);
	};
	Cnds.prototype.OnDefaultLogic = function ()
	{
		return true;
	};
	function Acts() {};
	pluginProto.acts = new Acts();
	Acts.prototype.SetActivated = function (s)
	{
		this.activated = (s==1);
	};
    Acts.prototype.Request = function ()
	{
        if (!this.activated)
            return;
        this.fsm.Request();
	};
    Acts.prototype.GotoState = function (new_state)
	{
        if (!this.activated)
            return;
	    this.fsm.Request(new_state);
	};
	Acts.prototype.NextStateSet = function (state)
	{
        this.next_state = state;
	};
	function Exps() {};
	pluginProto.exps = new Exps();
	Exps.prototype.CurState = function (ret)
	{
	    ret.set_string(this.fsm.CurState);
	};
	Exps.prototype.PreState = function (ret)
	{
	    ret.set_string(this.fsm.PreState);
	};
}());
(function ()
{
    cr.plugins_.Rex_FSM.FSMKlass = function(plugin, previous_state, current_state)
    {
        this.Reset(plugin, previous_state, current_state);
    };
    var FSMKlassProto = cr.plugins_.Rex_FSM.FSMKlass.prototype;
    FSMKlassProto.Reset = function (plugin, previous_state, current_state)
    {
        this.plugin = plugin;
        this.PreState = previous_state;
        this.CurState = current_state;
    };
    FSMKlassProto.Request = function(new_state)
    {
        if (new_state == null)
        {
            new_state = this.plugin.get_next_state();
            if (new_state == null)
                return;
        }
        this.PreState = this.CurState;
        this.CurState = new_state;
        var pre_state = this.PreState;
        var cur_state = this.CurState;
		this.plugin.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnStateChanged);
        var is_echo = this._run_transfer_action(pre_state, cur_state);
        if (is_echo)
            return;
        this._run_exit_action(pre_state);
        this._run_enter_action(cur_state);
    };
    FSMKlassProto._run_transfer_action = function(pre_state, cur_state)
    {
        this.plugin.check_state = pre_state;
        this.plugin.check_state2 = cur_state;
        var is_echo = this.plugin.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnTransfer);
        this.plugin.check_state = null;
        this.plugin.check_state2 = null;
        return is_echo;
    };
    FSMKlassProto._run_exit_action = function(pre_state)
    {
        this.plugin.check_state = pre_state;
	    var is_echo = this.plugin.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnExit);
	    this.plugin.check_state = null;
		if (is_echo)
		{
		    return;
		}
	    this.plugin.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnDefaultExit);
    };
    FSMKlassProto._run_enter_action = function(cur_state)
    {
        this.plugin.check_state = cur_state;
	    var is_echo = this.plugin.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnEnter);
	    this.plugin.check_state = null;
		if (is_echo)
		{
		    return;
		}
	    this.plugin.run_trigger(cr.plugins_.Rex_FSM.prototype.cnds.OnDefaultEnter);
    };
	FSMKlassProto.saveToJSON = function ()
	{
		return { "ps": this.PreState,
		         "cs": this.CurState
			   };
	};
	FSMKlassProto.loadFromJSON = function (o)
	{
	    this.PreState = o["ps"];
		this.CurState = o["cs"];
	};
}());
;
;
cr.plugins_.Sprite = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Sprite.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	function frame_getDataUri()
	{
		if (this.datauri.length === 0)
		{
			var tmpcanvas = document.createElement("canvas");
			tmpcanvas.width = this.width;
			tmpcanvas.height = this.height;
			var tmpctx = tmpcanvas.getContext("2d");
			if (this.spritesheeted)
			{
				tmpctx.drawImage(this.texture_img, this.offx, this.offy, this.width, this.height,
										 0, 0, this.width, this.height);
			}
			else
			{
				tmpctx.drawImage(this.texture_img, 0, 0, this.width, this.height);
			}
			this.datauri = tmpcanvas.toDataURL("image/png");
		}
		return this.datauri;
	};
	typeProto.onCreate = function()
	{
		if (this.is_family)
			return;
		var i, leni, j, lenj;
		var anim, frame, animobj, frameobj, wt, uv;
		this.all_frames = [];
		this.has_loaded_textures = false;
		for (i = 0, leni = this.animations.length; i < leni; i++)
		{
			anim = this.animations[i];
			animobj = {};
			animobj.name = anim[0];
			animobj.speed = anim[1];
			animobj.loop = anim[2];
			animobj.repeatcount = anim[3];
			animobj.repeatto = anim[4];
			animobj.pingpong = anim[5];
			animobj.sid = anim[6];
			animobj.frames = [];
			for (j = 0, lenj = anim[7].length; j < lenj; j++)
			{
				frame = anim[7][j];
				frameobj = {};
				frameobj.texture_file = frame[0];
				frameobj.texture_filesize = frame[1];
				frameobj.offx = frame[2];
				frameobj.offy = frame[3];
				frameobj.width = frame[4];
				frameobj.height = frame[5];
				frameobj.duration = frame[6];
				frameobj.hotspotX = frame[7];
				frameobj.hotspotY = frame[8];
				frameobj.image_points = frame[9];
				frameobj.poly_pts = frame[10];
				frameobj.pixelformat = frame[11];
				frameobj.spritesheeted = (frameobj.width !== 0);
				frameobj.datauri = "";		// generated on demand and cached
				frameobj.getDataUri = frame_getDataUri;
				uv = {};
				uv.left = 0;
				uv.top = 0;
				uv.right = 1;
				uv.bottom = 1;
				frameobj.sheetTex = uv;
				frameobj.webGL_texture = null;
				wt = this.runtime.findWaitingTexture(frame[0]);
				if (wt)
				{
					frameobj.texture_img = wt;
				}
				else
				{
					frameobj.texture_img = new Image();
					frameobj.texture_img.cr_src = frame[0];
					frameobj.texture_img.cr_filesize = frame[1];
					frameobj.texture_img.c2webGL_texture = null;
					this.runtime.waitForImageLoad(frameobj.texture_img, frame[0]);
				}
				cr.seal(frameobj);
				animobj.frames.push(frameobj);
				this.all_frames.push(frameobj);
			}
			cr.seal(animobj);
			this.animations[i] = animobj;		// swap array data for object
		}
	};
	typeProto.updateAllCurrentTexture = function ()
	{
		var i, len, inst;
		for (i = 0, len = this.instances.length; i < len; i++)
		{
			inst = this.instances[i];
			inst.curWebGLTexture = inst.curFrame.webGL_texture;
		}
	};
	typeProto.onLostWebGLContext = function ()
	{
		if (this.is_family)
			return;
		var i, len, frame;
		for (i = 0, len = this.all_frames.length; i < len; ++i)
		{
			frame = this.all_frames[i];
			frame.texture_img.c2webGL_texture = null;
			frame.webGL_texture = null;
		}
		this.has_loaded_textures = false;
		this.updateAllCurrentTexture();
	};
	typeProto.onRestoreWebGLContext = function ()
	{
		if (this.is_family || !this.instances.length)
			return;
		var i, len, frame;
		for (i = 0, len = this.all_frames.length; i < len; ++i)
		{
			frame = this.all_frames[i];
			frame.webGL_texture = this.runtime.glwrap.loadTexture(frame.texture_img, false, this.runtime.linearSampling, frame.pixelformat);
		}
		this.updateAllCurrentTexture();
	};
	typeProto.loadTextures = function ()
	{
		if (this.is_family || this.has_loaded_textures || !this.runtime.glwrap)
			return;
		var i, len, frame;
		for (i = 0, len = this.all_frames.length; i < len; ++i)
		{
			frame = this.all_frames[i];
			frame.webGL_texture = this.runtime.glwrap.loadTexture(frame.texture_img, false, this.runtime.linearSampling, frame.pixelformat);
		}
		this.has_loaded_textures = true;
	};
	typeProto.unloadTextures = function ()
	{
		if (this.is_family || this.instances.length || !this.has_loaded_textures)
			return;
		var i, len, frame;
		for (i = 0, len = this.all_frames.length; i < len; ++i)
		{
			frame = this.all_frames[i];
			this.runtime.glwrap.deleteTexture(frame.webGL_texture);
			frame.webGL_texture = null;
		}
		this.has_loaded_textures = false;
	};
	var already_drawn_images = [];
	typeProto.preloadCanvas2D = function (ctx)
	{
		var i, len, frameimg;
		cr.clearArray(already_drawn_images);
		for (i = 0, len = this.all_frames.length; i < len; ++i)
		{
			frameimg = this.all_frames[i].texture_img;
			if (already_drawn_images.indexOf(frameimg) !== -1)
					continue;
			ctx.drawImage(frameimg, 0, 0);
			already_drawn_images.push(frameimg);
		}
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
		var poly_pts = this.type.animations[0].frames[0].poly_pts;
		if (this.recycled)
			this.collision_poly.set_pts(poly_pts);
		else
			this.collision_poly = new cr.CollisionPoly(poly_pts);
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onCreate = function()
	{
		this.visible = (this.properties[0] === 0);	// 0=visible, 1=invisible
		this.isTicking = false;
		this.inAnimTrigger = false;
		this.collisionsEnabled = (this.properties[3] !== 0);
		this.cur_animation = this.getAnimationByName(this.properties[1]) || this.type.animations[0];
		this.cur_frame = this.properties[2];
		if (this.cur_frame < 0)
			this.cur_frame = 0;
		if (this.cur_frame >= this.cur_animation.frames.length)
			this.cur_frame = this.cur_animation.frames.length - 1;
		var curanimframe = this.cur_animation.frames[this.cur_frame];
		this.collision_poly.set_pts(curanimframe.poly_pts);
		this.hotspotX = curanimframe.hotspotX;
		this.hotspotY = curanimframe.hotspotY;
		this.cur_anim_speed = this.cur_animation.speed;
		this.cur_anim_repeatto = this.cur_animation.repeatto;
		if (!(this.type.animations.length === 1 && this.type.animations[0].frames.length === 1) && this.cur_anim_speed !== 0)
		{
			this.runtime.tickMe(this);
			this.isTicking = true;
		}
		if (this.recycled)
			this.animTimer.reset();
		else
			this.animTimer = new cr.KahanAdder();
		this.frameStart = this.getNowTime();
		this.animPlaying = true;
		this.animRepeats = 0;
		this.animForwards = true;
		this.animTriggerName = "";
		this.changeAnimName = "";
		this.changeAnimFrom = 0;
		this.changeAnimFrame = -1;
		this.type.loadTextures();
		var i, leni, j, lenj;
		var anim, frame, uv, maintex;
		for (i = 0, leni = this.type.animations.length; i < leni; i++)
		{
			anim = this.type.animations[i];
			for (j = 0, lenj = anim.frames.length; j < lenj; j++)
			{
				frame = anim.frames[j];
				if (frame.width === 0)
				{
					frame.width = frame.texture_img.width;
					frame.height = frame.texture_img.height;
				}
				if (frame.spritesheeted)
				{
					maintex = frame.texture_img;
					uv = frame.sheetTex;
					uv.left = frame.offx / maintex.width;
					uv.top = frame.offy / maintex.height;
					uv.right = (frame.offx + frame.width) / maintex.width;
					uv.bottom = (frame.offy + frame.height) / maintex.height;
					if (frame.offx === 0 && frame.offy === 0 && frame.width === maintex.width && frame.height === maintex.height)
					{
						frame.spritesheeted = false;
					}
				}
			}
		}
		this.curFrame = this.cur_animation.frames[this.cur_frame];
		this.curWebGLTexture = this.curFrame.webGL_texture;
	};
	instanceProto.saveToJSON = function ()
	{
		var o = {
			"a": this.cur_animation.sid,
			"f": this.cur_frame,
			"cas": this.cur_anim_speed,
			"fs": this.frameStart,
			"ar": this.animRepeats,
			"at": this.animTimer.sum,
			"rt": this.cur_anim_repeatto
		};
		if (!this.animPlaying)
			o["ap"] = this.animPlaying;
		if (!this.animForwards)
			o["af"] = this.animForwards;
		return o;
	};
	instanceProto.loadFromJSON = function (o)
	{
		var anim = this.getAnimationBySid(o["a"]);
		if (anim)
			this.cur_animation = anim;
		this.cur_frame = o["f"];
		if (this.cur_frame < 0)
			this.cur_frame = 0;
		if (this.cur_frame >= this.cur_animation.frames.length)
			this.cur_frame = this.cur_animation.frames.length - 1;
		this.cur_anim_speed = o["cas"];
		this.frameStart = o["fs"];
		this.animRepeats = o["ar"];
		this.animTimer.reset();
		this.animTimer.sum = o["at"];
		this.animPlaying = o.hasOwnProperty("ap") ? o["ap"] : true;
		this.animForwards = o.hasOwnProperty("af") ? o["af"] : true;
		if (o.hasOwnProperty("rt"))
			this.cur_anim_repeatto = o["rt"];
		else
			this.cur_anim_repeatto = this.cur_animation.repeatto;
		this.curFrame = this.cur_animation.frames[this.cur_frame];
		this.curWebGLTexture = this.curFrame.webGL_texture;
		this.collision_poly.set_pts(this.curFrame.poly_pts);
		this.hotspotX = this.curFrame.hotspotX;
		this.hotspotY = this.curFrame.hotspotY;
	};
	instanceProto.animationFinish = function (reverse)
	{
		this.cur_frame = reverse ? 0 : this.cur_animation.frames.length - 1;
		this.animPlaying = false;
		this.animTriggerName = this.cur_animation.name;
		this.inAnimTrigger = true;
		this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnyAnimFinished, this);
		this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnimFinished, this);
		this.inAnimTrigger = false;
		this.animRepeats = 0;
	};
	instanceProto.getNowTime = function()
	{
		return this.animTimer.sum;
	};
	instanceProto.tick = function()
	{
		this.animTimer.add(this.runtime.getDt(this));
		if (this.changeAnimName.length)
			this.doChangeAnim();
		if (this.changeAnimFrame >= 0)
			this.doChangeAnimFrame();
		var now = this.getNowTime();
		var cur_animation = this.cur_animation;
		var prev_frame = cur_animation.frames[this.cur_frame];
		var next_frame;
		var cur_frame_time = prev_frame.duration / this.cur_anim_speed;
		if (this.animPlaying && now >= this.frameStart + cur_frame_time)
		{
			if (this.animForwards)
			{
				this.cur_frame++;
			}
			else
			{
				this.cur_frame--;
			}
			this.frameStart += cur_frame_time;
			if (this.cur_frame >= cur_animation.frames.length)
			{
				if (cur_animation.pingpong)
				{
					this.animForwards = false;
					this.cur_frame = cur_animation.frames.length - 2;
				}
				else if (cur_animation.loop)
				{
					this.cur_frame = this.cur_anim_repeatto;
				}
				else
				{
					this.animRepeats++;
					if (this.animRepeats >= cur_animation.repeatcount)
					{
						this.animationFinish(false);
					}
					else
					{
						this.cur_frame = this.cur_anim_repeatto;
					}
				}
			}
			if (this.cur_frame < 0)
			{
				if (cur_animation.pingpong)
				{
					this.cur_frame = 1;
					this.animForwards = true;
					if (!cur_animation.loop)
					{
						this.animRepeats++;
						if (this.animRepeats >= cur_animation.repeatcount)
						{
							this.animationFinish(true);
						}
					}
				}
				else
				{
					if (cur_animation.loop)
					{
						this.cur_frame = this.cur_anim_repeatto;
					}
					else
					{
						this.animRepeats++;
						if (this.animRepeats >= cur_animation.repeatcount)
						{
							this.animationFinish(true);
						}
						else
						{
							this.cur_frame = this.cur_anim_repeatto;
						}
					}
				}
			}
			if (this.cur_frame < 0)
				this.cur_frame = 0;
			else if (this.cur_frame >= cur_animation.frames.length)
				this.cur_frame = cur_animation.frames.length - 1;
			if (now > this.frameStart + (cur_animation.frames[this.cur_frame].duration / this.cur_anim_speed))
			{
				this.frameStart = now;
			}
			next_frame = cur_animation.frames[this.cur_frame];
			this.OnFrameChanged(prev_frame, next_frame);
			this.runtime.redraw = true;
		}
	};
	instanceProto.getAnimationByName = function (name_)
	{
		var i, len, a;
		for (i = 0, len = this.type.animations.length; i < len; i++)
		{
			a = this.type.animations[i];
			if (cr.equals_nocase(a.name, name_))
				return a;
		}
		return null;
	};
	instanceProto.getAnimationBySid = function (sid_)
	{
		var i, len, a;
		for (i = 0, len = this.type.animations.length; i < len; i++)
		{
			a = this.type.animations[i];
			if (a.sid === sid_)
				return a;
		}
		return null;
	};
	instanceProto.doChangeAnim = function ()
	{
		var prev_frame = this.cur_animation.frames[this.cur_frame];
		var anim = this.getAnimationByName(this.changeAnimName);
		this.changeAnimName = "";
		if (!anim)
			return;
		if (cr.equals_nocase(anim.name, this.cur_animation.name) && this.animPlaying)
			return;
		this.cur_animation = anim;
		this.cur_anim_speed = anim.speed;
		this.cur_anim_repeatto = anim.repeatto;
		if (this.cur_frame < 0)
			this.cur_frame = 0;
		if (this.cur_frame >= this.cur_animation.frames.length)
			this.cur_frame = this.cur_animation.frames.length - 1;
		if (this.changeAnimFrom === 1)
			this.cur_frame = 0;
		this.animPlaying = true;
		this.frameStart = this.getNowTime();
		this.animForwards = true;
		this.OnFrameChanged(prev_frame, this.cur_animation.frames[this.cur_frame]);
		this.runtime.redraw = true;
	};
	instanceProto.doChangeAnimFrame = function ()
	{
		var prev_frame = this.cur_animation.frames[this.cur_frame];
		var prev_frame_number = this.cur_frame;
		this.cur_frame = cr.floor(this.changeAnimFrame);
		if (this.cur_frame < 0)
			this.cur_frame = 0;
		if (this.cur_frame >= this.cur_animation.frames.length)
			this.cur_frame = this.cur_animation.frames.length - 1;
		if (prev_frame_number !== this.cur_frame)
		{
			this.OnFrameChanged(prev_frame, this.cur_animation.frames[this.cur_frame]);
			this.frameStart = this.getNowTime();
			this.runtime.redraw = true;
		}
		this.changeAnimFrame = -1;
	};
	instanceProto.OnFrameChanged = function (prev_frame, next_frame)
	{
		var oldw = prev_frame.width;
		var oldh = prev_frame.height;
		var neww = next_frame.width;
		var newh = next_frame.height;
		if (oldw != neww)
			this.width *= (neww / oldw);
		if (oldh != newh)
			this.height *= (newh / oldh);
		this.hotspotX = next_frame.hotspotX;
		this.hotspotY = next_frame.hotspotY;
		this.collision_poly.set_pts(next_frame.poly_pts);
		this.set_bbox_changed();
		this.curFrame = next_frame;
		this.curWebGLTexture = next_frame.webGL_texture;
		var i, len, b;
		for (i = 0, len = this.behavior_insts.length; i < len; i++)
		{
			b = this.behavior_insts[i];
			if (b.onSpriteFrameChanged)
				b.onSpriteFrameChanged(prev_frame, next_frame);
		}
		this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnFrameChanged, this);
	};
	instanceProto.draw = function(ctx)
	{
		ctx.globalAlpha = this.opacity;
		var cur_frame = this.curFrame;
		var spritesheeted = cur_frame.spritesheeted;
		var cur_image = cur_frame.texture_img;
		var myx = this.x;
		var myy = this.y;
		var w = this.width;
		var h = this.height;
		if (this.angle === 0 && w >= 0 && h >= 0)
		{
			myx -= this.hotspotX * w;
			myy -= this.hotspotY * h;
			if (this.runtime.pixel_rounding)
			{
				myx = Math.round(myx);
				myy = Math.round(myy);
			}
			if (spritesheeted)
			{
				ctx.drawImage(cur_image, cur_frame.offx, cur_frame.offy, cur_frame.width, cur_frame.height,
										 myx, myy, w, h);
			}
			else
			{
				ctx.drawImage(cur_image, myx, myy, w, h);
			}
		}
		else
		{
			if (this.runtime.pixel_rounding)
			{
				myx = Math.round(myx);
				myy = Math.round(myy);
			}
			ctx.save();
			var widthfactor = w > 0 ? 1 : -1;
			var heightfactor = h > 0 ? 1 : -1;
			ctx.translate(myx, myy);
			if (widthfactor !== 1 || heightfactor !== 1)
				ctx.scale(widthfactor, heightfactor);
			ctx.rotate(this.angle * widthfactor * heightfactor);
			var drawx = 0 - (this.hotspotX * cr.abs(w))
			var drawy = 0 - (this.hotspotY * cr.abs(h));
			if (spritesheeted)
			{
				ctx.drawImage(cur_image, cur_frame.offx, cur_frame.offy, cur_frame.width, cur_frame.height,
										 drawx, drawy, cr.abs(w), cr.abs(h));
			}
			else
			{
				ctx.drawImage(cur_image, drawx, drawy, cr.abs(w), cr.abs(h));
			}
			ctx.restore();
		}
		/*
		ctx.strokeStyle = "#f00";
		ctx.lineWidth = 3;
		ctx.beginPath();
		this.collision_poly.cache_poly(this.width, this.height, this.angle);
		var i, len, ax, ay, bx, by;
		for (i = 0, len = this.collision_poly.pts_count; i < len; i++)
		{
			ax = this.collision_poly.pts_cache[i*2] + this.x;
			ay = this.collision_poly.pts_cache[i*2+1] + this.y;
			bx = this.collision_poly.pts_cache[((i+1)%len)*2] + this.x;
			by = this.collision_poly.pts_cache[((i+1)%len)*2+1] + this.y;
			ctx.moveTo(ax, ay);
			ctx.lineTo(bx, by);
		}
		ctx.stroke();
		ctx.closePath();
		*/
		/*
		if (this.behavior_insts.length >= 1 && this.behavior_insts[0].draw)
		{
			this.behavior_insts[0].draw(ctx);
		}
		*/
	};
	instanceProto.drawGL_earlyZPass = function(glw)
	{
		this.drawGL(glw);
	};
	instanceProto.drawGL = function(glw)
	{
		glw.setTexture(this.curWebGLTexture);
		glw.setOpacity(this.opacity);
		var cur_frame = this.curFrame;
		var q = this.bquad;
		if (this.runtime.pixel_rounding)
		{
			var ox = Math.round(this.x) - this.x;
			var oy = Math.round(this.y) - this.y;
			if (cur_frame.spritesheeted)
				glw.quadTex(q.tlx + ox, q.tly + oy, q.trx + ox, q.try_ + oy, q.brx + ox, q.bry + oy, q.blx + ox, q.bly + oy, cur_frame.sheetTex);
			else
				glw.quad(q.tlx + ox, q.tly + oy, q.trx + ox, q.try_ + oy, q.brx + ox, q.bry + oy, q.blx + ox, q.bly + oy);
		}
		else
		{
			if (cur_frame.spritesheeted)
				glw.quadTex(q.tlx, q.tly, q.trx, q.try_, q.brx, q.bry, q.blx, q.bly, cur_frame.sheetTex);
			else
				glw.quad(q.tlx, q.tly, q.trx, q.try_, q.brx, q.bry, q.blx, q.bly);
		}
	};
	instanceProto.getImagePointIndexByName = function(name_)
	{
		var cur_frame = this.curFrame;
		var i, len;
		for (i = 0, len = cur_frame.image_points.length; i < len; i++)
		{
			if (cr.equals_nocase(name_, cur_frame.image_points[i][0]))
				return i;
		}
		return -1;
	};
	instanceProto.getImagePoint = function(imgpt, getX)
	{
		var cur_frame = this.curFrame;
		var image_points = cur_frame.image_points;
		var index;
		if (cr.is_string(imgpt))
			index = this.getImagePointIndexByName(imgpt);
		else
			index = imgpt - 1;	// 0 is origin
		index = cr.floor(index);
		if (index < 0 || index >= image_points.length)
			return getX ? this.x : this.y;	// return origin
		var x = (image_points[index][1] - cur_frame.hotspotX) * this.width;
		var y = image_points[index][2];
		y = (y - cur_frame.hotspotY) * this.height;
		var cosa = Math.cos(this.angle);
		var sina = Math.sin(this.angle);
		var x_temp = (x * cosa) - (y * sina);
		y = (y * cosa) + (x * sina);
		x = x_temp;
		x += this.x;
		y += this.y;
		return getX ? x : y;
	};
	function Cnds() {};
	var arrCache = [];
	function allocArr()
	{
		if (arrCache.length)
			return arrCache.pop();
		else
			return [0, 0, 0];
	};
	function freeArr(a)
	{
		a[0] = 0;
		a[1] = 0;
		a[2] = 0;
		arrCache.push(a);
	};
	function makeCollKey(a, b)
	{
		if (a < b)
			return "" + a + "," + b;
		else
			return "" + b + "," + a;
	};
	function collmemory_add(collmemory, a, b, tickcount)
	{
		var a_uid = a.uid;
		var b_uid = b.uid;
		var key = makeCollKey(a_uid, b_uid);
		if (collmemory.hasOwnProperty(key))
		{
			collmemory[key][2] = tickcount;
			return;
		}
		var arr = allocArr();
		arr[0] = a_uid;
		arr[1] = b_uid;
		arr[2] = tickcount;
		collmemory[key] = arr;
	};
	function collmemory_remove(collmemory, a, b)
	{
		var key = makeCollKey(a.uid, b.uid);
		if (collmemory.hasOwnProperty(key))
		{
			freeArr(collmemory[key]);
			delete collmemory[key];
		}
	};
	function collmemory_removeInstance(collmemory, inst)
	{
		var uid = inst.uid;
		var p, entry;
		for (p in collmemory)
		{
			if (collmemory.hasOwnProperty(p))
			{
				entry = collmemory[p];
				if (entry[0] === uid || entry[1] === uid)
				{
					freeArr(collmemory[p]);
					delete collmemory[p];
				}
			}
		}
	};
	var last_coll_tickcount = -2;
	function collmemory_has(collmemory, a, b)
	{
		var key = makeCollKey(a.uid, b.uid);
		if (collmemory.hasOwnProperty(key))
		{
			last_coll_tickcount = collmemory[key][2];
			return true;
		}
		else
		{
			last_coll_tickcount = -2;
			return false;
		}
	};
	var candidates1 = [];
	Cnds.prototype.OnCollision = function (rtype)
	{
		if (!rtype)
			return false;
		var runtime = this.runtime;
		var cnd = runtime.getCurrentCondition();
		var ltype = cnd.type;
		var collmemory = null;
		if (cnd.extra["collmemory"])
		{
			collmemory = cnd.extra["collmemory"];
		}
		else
		{
			collmemory = {};
			cnd.extra["collmemory"] = collmemory;
		}
		if (!cnd.extra["spriteCreatedDestroyCallback"])
		{
			cnd.extra["spriteCreatedDestroyCallback"] = true;
			runtime.addDestroyCallback(function(inst) {
				collmemory_removeInstance(cnd.extra["collmemory"], inst);
			});
		}
		var lsol = ltype.getCurrentSol();
		var rsol = rtype.getCurrentSol();
		var linstances = lsol.getObjects();
		var rinstances;
		var l, linst, r, rinst;
		var curlsol, currsol;
		var tickcount = this.runtime.tickcount;
		var lasttickcount = tickcount - 1;
		var exists, run;
		var current_event = runtime.getCurrentEventStack().current_event;
		var orblock = current_event.orblock;
		for (l = 0; l < linstances.length; l++)
		{
			linst = linstances[l];
			if (rsol.select_all)
			{
				linst.update_bbox();
				this.runtime.getCollisionCandidates(linst.layer, rtype, linst.bbox, candidates1);
				rinstances = candidates1;
			}
			else
				rinstances = rsol.getObjects();
			for (r = 0; r < rinstances.length; r++)
			{
				rinst = rinstances[r];
				if (runtime.testOverlap(linst, rinst) || runtime.checkRegisteredCollision(linst, rinst))
				{
					exists = collmemory_has(collmemory, linst, rinst);
					run = (!exists || (last_coll_tickcount < lasttickcount));
					collmemory_add(collmemory, linst, rinst, tickcount);
					if (run)
					{
						runtime.pushCopySol(current_event.solModifiers);
						curlsol = ltype.getCurrentSol();
						currsol = rtype.getCurrentSol();
						curlsol.select_all = false;
						currsol.select_all = false;
						if (ltype === rtype)
						{
							curlsol.instances.length = 2;	// just use lsol, is same reference as rsol
							curlsol.instances[0] = linst;
							curlsol.instances[1] = rinst;
							ltype.applySolToContainer();
						}
						else
						{
							curlsol.instances.length = 1;
							currsol.instances.length = 1;
							curlsol.instances[0] = linst;
							currsol.instances[0] = rinst;
							ltype.applySolToContainer();
							rtype.applySolToContainer();
						}
						current_event.retrigger();
						runtime.popSol(current_event.solModifiers);
					}
				}
				else
				{
					collmemory_remove(collmemory, linst, rinst);
				}
			}
			cr.clearArray(candidates1);
		}
		return false;
	};
	var rpicktype = null;
	var rtopick = new cr.ObjectSet();
	var needscollisionfinish = false;
	var candidates2 = [];
	var temp_bbox = new cr.rect(0, 0, 0, 0);
	function DoOverlapCondition(rtype, offx, offy)
	{
		if (!rtype)
			return false;
		var do_offset = (offx !== 0 || offy !== 0);
		var oldx, oldy, ret = false, r, lenr, rinst;
		var cnd = this.runtime.getCurrentCondition();
		var ltype = cnd.type;
		var inverted = cnd.inverted;
		var rsol = rtype.getCurrentSol();
		var orblock = this.runtime.getCurrentEventStack().current_event.orblock;
		var rinstances;
		if (rsol.select_all)
		{
			this.update_bbox();
			temp_bbox.copy(this.bbox);
			temp_bbox.offset(offx, offy);
			this.runtime.getCollisionCandidates(this.layer, rtype, temp_bbox, candidates2);
			rinstances = candidates2;
		}
		else if (orblock)
		{
			if (this.runtime.isCurrentConditionFirst() && !rsol.else_instances.length && rsol.instances.length)
				rinstances = rsol.instances;
			else
				rinstances = rsol.else_instances;
		}
		else
		{
			rinstances = rsol.instances;
		}
		rpicktype = rtype;
		needscollisionfinish = (ltype !== rtype && !inverted);
		if (do_offset)
		{
			oldx = this.x;
			oldy = this.y;
			this.x += offx;
			this.y += offy;
			this.set_bbox_changed();
		}
		for (r = 0, lenr = rinstances.length; r < lenr; r++)
		{
			rinst = rinstances[r];
			if (this.runtime.testOverlap(this, rinst))
			{
				ret = true;
				if (inverted)
					break;
				if (ltype !== rtype)
					rtopick.add(rinst);
			}
		}
		if (do_offset)
		{
			this.x = oldx;
			this.y = oldy;
			this.set_bbox_changed();
		}
		cr.clearArray(candidates2);
		return ret;
	};
	typeProto.finish = function (do_pick)
	{
		if (!needscollisionfinish)
			return;
		if (do_pick)
		{
			var orblock = this.runtime.getCurrentEventStack().current_event.orblock;
			var sol = rpicktype.getCurrentSol();
			var topick = rtopick.valuesRef();
			var i, len, inst;
			if (sol.select_all)
			{
				sol.select_all = false;
				cr.clearArray(sol.instances);
				for (i = 0, len = topick.length; i < len; ++i)
				{
					sol.instances[i] = topick[i];
				}
				if (orblock)
				{
					cr.clearArray(sol.else_instances);
					for (i = 0, len = rpicktype.instances.length; i < len; ++i)
					{
						inst = rpicktype.instances[i];
						if (!rtopick.contains(inst))
							sol.else_instances.push(inst);
					}
				}
			}
			else
			{
				if (orblock)
				{
					var initsize = sol.instances.length;
					for (i = 0, len = topick.length; i < len; ++i)
					{
						sol.instances[initsize + i] = topick[i];
						cr.arrayFindRemove(sol.else_instances, topick[i]);
					}
				}
				else
				{
					cr.shallowAssignArray(sol.instances, topick);
				}
			}
			rpicktype.applySolToContainer();
		}
		rtopick.clear();
		needscollisionfinish = false;
	};
	Cnds.prototype.IsOverlapping = function (rtype)
	{
		return DoOverlapCondition.call(this, rtype, 0, 0);
	};
	Cnds.prototype.IsOverlappingOffset = function (rtype, offx, offy)
	{
		return DoOverlapCondition.call(this, rtype, offx, offy);
	};
	Cnds.prototype.IsAnimPlaying = function (animname)
	{
		if (this.changeAnimName.length)
			return cr.equals_nocase(this.changeAnimName, animname);
		else
			return cr.equals_nocase(this.cur_animation.name, animname);
	};
	Cnds.prototype.CompareFrame = function (cmp, framenum)
	{
		return cr.do_cmp(this.cur_frame, cmp, framenum);
	};
	Cnds.prototype.CompareAnimSpeed = function (cmp, x)
	{
		var s = (this.animForwards ? this.cur_anim_speed : -this.cur_anim_speed);
		return cr.do_cmp(s, cmp, x);
	};
	Cnds.prototype.OnAnimFinished = function (animname)
	{
		return cr.equals_nocase(this.animTriggerName, animname);
	};
	Cnds.prototype.OnAnyAnimFinished = function ()
	{
		return true;
	};
	Cnds.prototype.OnFrameChanged = function ()
	{
		return true;
	};
	Cnds.prototype.IsMirrored = function ()
	{
		return this.width < 0;
	};
	Cnds.prototype.IsFlipped = function ()
	{
		return this.height < 0;
	};
	Cnds.prototype.OnURLLoaded = function ()
	{
		return true;
	};
	Cnds.prototype.IsCollisionEnabled = function ()
	{
		return this.collisionsEnabled;
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.Spawn = function (obj, layer, imgpt)
	{
		if (!obj || !layer)
			return;
		var inst = this.runtime.createInstance(obj, layer, this.getImagePoint(imgpt, true), this.getImagePoint(imgpt, false));
		if (!inst)
			return;
		if (typeof inst.angle !== "undefined")
		{
			inst.angle = this.angle;
			inst.set_bbox_changed();
		}
		this.runtime.isInOnDestroy++;
		var i, len, s;
		this.runtime.trigger(Object.getPrototypeOf(obj.plugin).cnds.OnCreated, inst);
		if (inst.is_contained)
		{
			for (i = 0, len = inst.siblings.length; i < len; i++)
			{
				s = inst.siblings[i];
				this.runtime.trigger(Object.getPrototypeOf(s.type.plugin).cnds.OnCreated, s);
			}
		}
		this.runtime.isInOnDestroy--;
		var cur_act = this.runtime.getCurrentAction();
		var reset_sol = false;
		if (cr.is_undefined(cur_act.extra["Spawn_LastExec"]) || cur_act.extra["Spawn_LastExec"] < this.runtime.execcount)
		{
			reset_sol = true;
			cur_act.extra["Spawn_LastExec"] = this.runtime.execcount;
		}
		var sol;
		if (obj != this.type)
		{
			sol = obj.getCurrentSol();
			sol.select_all = false;
			if (reset_sol)
			{
				cr.clearArray(sol.instances);
				sol.instances[0] = inst;
			}
			else
				sol.instances.push(inst);
			if (inst.is_contained)
			{
				for (i = 0, len = inst.siblings.length; i < len; i++)
				{
					s = inst.siblings[i];
					sol = s.type.getCurrentSol();
					sol.select_all = false;
					if (reset_sol)
					{
						cr.clearArray(sol.instances);
						sol.instances[0] = s;
					}
					else
						sol.instances.push(s);
				}
			}
		}
	};
	Acts.prototype.SetEffect = function (effect)
	{
		this.blend_mode = effect;
		this.compositeOp = cr.effectToCompositeOp(effect);
		cr.setGLBlend(this, effect, this.runtime.gl);
		this.runtime.redraw = true;
	};
	Acts.prototype.StopAnim = function ()
	{
		this.animPlaying = false;
	};
	Acts.prototype.StartAnim = function (from)
	{
		this.animPlaying = true;
		this.frameStart = this.getNowTime();
		if (from === 1 && this.cur_frame !== 0)
		{
			this.changeAnimFrame = 0;
			if (!this.inAnimTrigger)
				this.doChangeAnimFrame();
		}
		if (!this.isTicking)
		{
			this.runtime.tickMe(this);
			this.isTicking = true;
		}
	};
	Acts.prototype.SetAnim = function (animname, from)
	{
		this.changeAnimName = animname;
		this.changeAnimFrom = from;
		if (!this.isTicking)
		{
			this.runtime.tickMe(this);
			this.isTicking = true;
		}
		if (!this.inAnimTrigger)
			this.doChangeAnim();
	};
	Acts.prototype.SetAnimFrame = function (framenumber)
	{
		this.changeAnimFrame = framenumber;
		if (!this.isTicking)
		{
			this.runtime.tickMe(this);
			this.isTicking = true;
		}
		if (!this.inAnimTrigger)
			this.doChangeAnimFrame();
	};
	Acts.prototype.SetAnimSpeed = function (s)
	{
		this.cur_anim_speed = cr.abs(s);
		this.animForwards = (s >= 0);
		if (!this.isTicking)
		{
			this.runtime.tickMe(this);
			this.isTicking = true;
		}
	};
	Acts.prototype.SetAnimRepeatToFrame = function (s)
	{
		s = Math.floor(s);
		if (s < 0)
			s = 0;
		if (s >= this.cur_animation.frames.length)
			s = this.cur_animation.frames.length - 1;
		this.cur_anim_repeatto = s;
	};
	Acts.prototype.SetMirrored = function (m)
	{
		var neww = cr.abs(this.width) * (m === 0 ? -1 : 1);
		if (this.width === neww)
			return;
		this.width = neww;
		this.set_bbox_changed();
	};
	Acts.prototype.SetFlipped = function (f)
	{
		var newh = cr.abs(this.height) * (f === 0 ? -1 : 1);
		if (this.height === newh)
			return;
		this.height = newh;
		this.set_bbox_changed();
	};
	Acts.prototype.SetScale = function (s)
	{
		var cur_frame = this.curFrame;
		var mirror_factor = (this.width < 0 ? -1 : 1);
		var flip_factor = (this.height < 0 ? -1 : 1);
		var new_width = cur_frame.width * s * mirror_factor;
		var new_height = cur_frame.height * s * flip_factor;
		if (this.width !== new_width || this.height !== new_height)
		{
			this.width = new_width;
			this.height = new_height;
			this.set_bbox_changed();
		}
	};
	Acts.prototype.LoadURL = function (url_, resize_)
	{
		var img = new Image();
		var self = this;
		var curFrame_ = this.curFrame;
		img.onload = function ()
		{
			if (curFrame_.texture_img.src === img.src)
			{
				if (self.runtime.glwrap && self.curFrame === curFrame_)
					self.curWebGLTexture = curFrame_.webGL_texture;
				if (resize_ === 0)		// resize to image size
				{
					self.width = img.width;
					self.height = img.height;
					self.set_bbox_changed();
				}
				self.runtime.redraw = true;
				self.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnURLLoaded, self);
				return;
			}
			curFrame_.texture_img = img;
			curFrame_.offx = 0;
			curFrame_.offy = 0;
			curFrame_.width = img.width;
			curFrame_.height = img.height;
			curFrame_.spritesheeted = false;
			curFrame_.datauri = "";
			curFrame_.pixelformat = 0;	// reset to RGBA, since we don't know what type of image will have come in
			if (self.runtime.glwrap)
			{
				if (curFrame_.webGL_texture)
					self.runtime.glwrap.deleteTexture(curFrame_.webGL_texture);
				curFrame_.webGL_texture = self.runtime.glwrap.loadTexture(img, false, self.runtime.linearSampling);
				if (self.curFrame === curFrame_)
					self.curWebGLTexture = curFrame_.webGL_texture;
				self.type.updateAllCurrentTexture();
			}
			if (resize_ === 0)		// resize to image size
			{
				self.width = img.width;
				self.height = img.height;
				self.set_bbox_changed();
			}
			self.runtime.redraw = true;
			self.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnURLLoaded, self);
		};
		if (url_.substr(0, 5) !== "data:")
			img["crossOrigin"] = "anonymous";
		this.runtime.setImageSrc(img, url_);
	};
	Acts.prototype.SetCollisions = function (set_)
	{
		if (this.collisionsEnabled === (set_ !== 0))
			return;		// no change
		this.collisionsEnabled = (set_ !== 0);
		if (this.collisionsEnabled)
			this.set_bbox_changed();		// needs to be added back to cells
		else
		{
			if (this.collcells.right >= this.collcells.left)
				this.type.collision_grid.update(this, this.collcells, null);
			this.collcells.set(0, 0, -1, -1);
		}
	};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.AnimationFrame = function (ret)
	{
		ret.set_int(this.cur_frame);
	};
	Exps.prototype.AnimationFrameCount = function (ret)
	{
		ret.set_int(this.cur_animation.frames.length);
	};
	Exps.prototype.AnimationName = function (ret)
	{
		ret.set_string(this.cur_animation.name);
	};
	Exps.prototype.AnimationSpeed = function (ret)
	{
		ret.set_float(this.animForwards ? this.cur_anim_speed : -this.cur_anim_speed);
	};
	Exps.prototype.ImagePointX = function (ret, imgpt)
	{
		ret.set_float(this.getImagePoint(imgpt, true));
	};
	Exps.prototype.ImagePointY = function (ret, imgpt)
	{
		ret.set_float(this.getImagePoint(imgpt, false));
	};
	Exps.prototype.ImagePointCount = function (ret)
	{
		ret.set_int(this.curFrame.image_points.length);
	};
	Exps.prototype.ImageWidth = function (ret)
	{
		ret.set_float(this.curFrame.width);
	};
	Exps.prototype.ImageHeight = function (ret)
	{
		ret.set_float(this.curFrame.height);
	};
	pluginProto.exps = new Exps();
}());
/* global cr,log,assert2 */
/* jshint globalstrict: true */
/* jshint strict: true */
;
;
cr.plugins_.Spritefont2 = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Spritefont2.prototype;
	pluginProto.onCreate = function ()
	{
	};
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
		if (this.is_family)
			return;
		this.texture_img = new Image();
		this.runtime.waitForImageLoad(this.texture_img, this.texture_file);
		this.webGL_texture = null;
	};
	typeProto.onLostWebGLContext = function ()
	{
		if (this.is_family)
			return;
		this.webGL_texture = null;
	};
	typeProto.onRestoreWebGLContext = function ()
	{
		if (this.is_family || !this.instances.length)
			return;
		if (!this.webGL_texture)
		{
			this.webGL_texture = this.runtime.glwrap.loadTexture(this.texture_img, false, this.runtime.linearSampling, this.texture_pixelformat);
		}
		var i, len;
		for (i = 0, len = this.instances.length; i < len; i++)
			this.instances[i].webGL_texture = this.webGL_texture;
	};
	typeProto.unloadTextures = function ()
	{
		if (this.is_family || this.instances.length || !this.webGL_texture)
			return;
		this.runtime.glwrap.deleteTexture(this.webGL_texture);
		this.webGL_texture = null;
	};
	typeProto.preloadCanvas2D = function (ctx)
	{
		ctx.drawImage(this.texture_img, 0, 0);
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onDestroy = function()
	{
		freeAllLines (this.lines);
		freeAllClip  (this.clipList);
		freeAllClipUV(this.clipUV);
		cr.wipe(this.characterWidthList);
	};
	instanceProto.onCreate = function()
	{
		this.texture_img      = this.type.texture_img;
		this.characterWidth   = this.properties[0];
		this.characterHeight  = this.properties[1];
		this.characterSet     = this.properties[2];
		this.text             = this.properties[3];
		this.characterScale   = this.properties[4];
		this.visible          = (this.properties[5] === 0);	// 0=visible, 1=invisible
		this.halign           = this.properties[6]/2.0;		// 0=left, 1=center, 2=right
		this.valign           = this.properties[7]/2.0;		// 0=top, 1=center, 2=bottom
		this.wrapbyword       = (this.properties[9] === 0);	// 0=word, 1=character
		this.characterSpacing = this.properties[10];
		this.lineHeight       = this.properties[11];
		this.textWidth  = 0;
		this.textHeight = 0;
		if (this.recycled)
		{
			cr.clearArray(this.lines);
			cr.wipe(this.clipList);
			cr.wipe(this.clipUV);
			cr.wipe(this.characterWidthList);
		}
		else
		{
			this.lines = [];
			this.clipList = {};
			this.clipUV = {};
			this.characterWidthList = {};
		}
		this.text_changed = true;
		this.lastwrapwidth = this.width;
		if (this.runtime.glwrap)
		{
			if (!this.type.webGL_texture)
			{
				this.type.webGL_texture = this.runtime.glwrap.loadTexture(this.type.texture_img, false, this.runtime.linearSampling, this.type.texture_pixelformat);
			}
			this.webGL_texture = this.type.webGL_texture;
		}
		this.SplitSheet();
	};
	instanceProto.saveToJSON = function ()
	{
		var save = {
			"t": this.text,
			"csc": this.characterScale,
			"csp": this.characterSpacing,
			"lh": this.lineHeight,
			"tw": this.textWidth,
			"th": this.textHeight,
			"lrt": this.last_render_tick,
			"ha": this.halign,
			"va": this.valign,
			"cw": {}
		};
		for (var ch in this.characterWidthList)
			save["cw"][ch] = this.characterWidthList[ch];
		return save;
	};
	instanceProto.loadFromJSON = function (o)
	{
		this.text = o["t"];
		this.characterScale = o["csc"];
		this.characterSpacing = o["csp"];
		this.lineHeight = o["lh"];
		this.textWidth = o["tw"];
		this.textHeight = o["th"];
		this.last_render_tick = o["lrt"];
		if (o.hasOwnProperty("ha"))
			this.halign = o["ha"];
		if (o.hasOwnProperty("va"))
			this.valign = o["va"];
		for(var ch in o["cw"])
			this.characterWidthList[ch] = o["cw"][ch];
		this.text_changed = true;
		this.lastwrapwidth = this.width;
	};
	function trimRight(text)
	{
		return text.replace(/\s\s*$/, '');
	}
	var MAX_CACHE_SIZE = 1000;
	function alloc(cache,Constructor)
	{
		if (cache.length)
			return cache.pop();
		else
			return new Constructor();
	}
	function free(cache,data)
	{
		if (cache.length < MAX_CACHE_SIZE)
		{
			cache.push(data);
		}
	}
	function freeAll(cache,dataList,isArray)
	{
		if (isArray) {
			var i, len;
			for (i = 0, len = dataList.length; i < len; i++)
			{
				free(cache,dataList[i]);
			}
			cr.clearArray(dataList);
		} else {
			var prop;
			for(prop in dataList) {
				if(Object.prototype.hasOwnProperty.call(dataList,prop)) {
					free(cache,dataList[prop]);
					delete dataList[prop];
				}
			}
		}
	}
	function addLine(inst,lineIndex,cur_line) {
		var lines = inst.lines;
		var line;
		cur_line = trimRight(cur_line);
		if (lineIndex >= lines.length)
			lines.push(allocLine());
		line = lines[lineIndex];
		line.text = cur_line;
		line.width = inst.measureWidth(cur_line);
		inst.textWidth = cr.max(inst.textWidth,line.width);
	}
	var linesCache = [];
	function allocLine()       { return alloc(linesCache,Object); }
	function freeLine(l)       { free(linesCache,l); }
	function freeAllLines(arr) { freeAll(linesCache,arr,true); }
	function addClip(obj,property,x,y,w,h) {
		if (obj[property] === undefined) {
			obj[property] = alloc(clipCache,Object);
		}
		obj[property].x = x;
		obj[property].y = y;
		obj[property].w = w;
		obj[property].h = h;
	}
	var clipCache = [];
	function allocClip()      { return alloc(clipCache,Object); }
	function freeAllClip(obj) { freeAll(clipCache,obj,false);}
	function addClipUV(obj,property,left,top,right,bottom) {
		if (obj[property] === undefined) {
			obj[property] = alloc(clipUVCache,cr.rect);
		}
		obj[property].left   = left;
		obj[property].top    = top;
		obj[property].right  = right;
		obj[property].bottom = bottom;
	}
	var clipUVCache = [];
	function allocClipUV()      { return alloc(clipUVCache,cr.rect);}
	function freeAllClipUV(obj) { freeAll(clipUVCache,obj,false);}
	instanceProto.SplitSheet = function() {
		var texture      = this.texture_img;
		var texWidth     = texture.width;
		var texHeight    = texture.height;
		var charWidth    = this.characterWidth;
		var charHeight   = this.characterHeight;
		var charU        = charWidth /texWidth;
		var charV        = charHeight/texHeight;
		var charSet      = this.characterSet ;
		var cols = Math.floor(texWidth/charWidth);
		var rows = Math.floor(texHeight/charHeight);
		for ( var c = 0; c < charSet.length; c++) {
			if  (c >= cols * rows) break;
			var x = c%cols;
			var y = Math.floor(c/cols);
			var letter = charSet.charAt(c);
			if (this.runtime.glwrap) {
				addClipUV(
					this.clipUV, letter,
					x * charU ,
					y * charV ,
					(x+1) * charU ,
					(y+1) * charV
				);
			} else {
				addClip(
					this.clipList, letter,
					x * charWidth,
					y * charHeight,
					charWidth,
					charHeight
				);
			}
		}
	};
	/*
     *	Word-Wrapping
     */
	var wordsCache = [];
	pluginProto.TokeniseWords = function (text)
	{
		cr.clearArray(wordsCache);
		var cur_word = "";
		var ch;
		var i = 0;
		while (i < text.length)
		{
			ch = text.charAt(i);
			if (ch === "\n")
			{
				if (cur_word.length)
				{
					wordsCache.push(cur_word);
					cur_word = "";
				}
				wordsCache.push("\n");
				++i;
			}
			else if (ch === " " || ch === "\t" || ch === "-")
			{
				do {
					cur_word += text.charAt(i);
					i++;
				}
				while (i < text.length && (text.charAt(i) === " " || text.charAt(i) === "\t"));
				wordsCache.push(cur_word);
				cur_word = "";
			}
			else if (i < text.length)
			{
				cur_word += ch;
				i++;
			}
		}
		if (cur_word.length)
			wordsCache.push(cur_word);
	};
	pluginProto.WordWrap = function (inst)
	{
		var text = inst.text;
		var lines = inst.lines;
		if (!text || !text.length)
		{
			freeAllLines(lines);
			return;
		}
		var width = inst.width;
		if (width <= 2.0)
		{
			freeAllLines(lines);
			return;
		}
		var charWidth = inst.characterWidth;
		var charScale = inst.characterScale;
		var charSpacing = inst.characterSpacing;
		if ( (text.length * (charWidth * charScale + charSpacing) - charSpacing) <= width && text.indexOf("\n") === -1)
		{
			var all_width = inst.measureWidth(text);
			if (all_width <= width)
			{
				freeAllLines(lines);
				lines.push(allocLine());
				lines[0].text = text;
				lines[0].width = all_width;
				inst.textWidth  = all_width;
				inst.textHeight = inst.characterHeight * charScale + inst.lineHeight;
				return;
			}
		}
		var wrapbyword = inst.wrapbyword;
		this.WrapText(inst);
		inst.textHeight = lines.length * (inst.characterHeight * charScale + inst.lineHeight);
	};
	pluginProto.WrapText = function (inst)
	{
		var wrapbyword = inst.wrapbyword;
		var text       = inst.text;
		var lines      = inst.lines;
		var width      = inst.width;
		var wordArray;
		if (wrapbyword) {
			this.TokeniseWords(text);	// writes to wordsCache
			wordArray = wordsCache;
		} else {
			wordArray = text;
		}
		var cur_line = "";
		var prev_line;
		var line_width;
		var i;
		var lineIndex = 0;
		var line;
		var ignore_newline = false;
		for (i = 0; i < wordArray.length; i++)
		{
			if (wordArray[i] === "\n")
			{
				if (ignore_newline === true) {
					ignore_newline = false;
				} else {
					addLine(inst,lineIndex,cur_line);
					lineIndex++;
				}
				cur_line = "";
				continue;
			}
			ignore_newline = false;
			prev_line = cur_line;
			cur_line += wordArray[i];
			line_width = inst.measureWidth(trimRight(cur_line));
			if (line_width > width)
			{
				if (prev_line === "") {
					addLine(inst,lineIndex,cur_line);
					cur_line = "";
					ignore_newline = true;
				} else {
					addLine(inst,lineIndex,prev_line);
					cur_line = wordArray[i];
				}
				lineIndex++;
				if (!wrapbyword && cur_line === " ")
					cur_line = "";
			}
		}
		if (trimRight(cur_line).length)
		{
			addLine(inst,lineIndex,cur_line);
			lineIndex++;
		}
		for (i = lineIndex; i < lines.length; i++)
			freeLine(lines[i]);
		lines.length = lineIndex;
	};
	instanceProto.measureWidth = function(text) {
		var spacing = this.characterSpacing;
		var len     = text.length;
		var width   = 0;
		for (var i = 0; i < len; i++) {
			width += this.getCharacterWidth(text.charAt(i)) * this.characterScale + spacing;
		}
		width -= (width > 0) ? spacing : 0;
		return width;
	};
	/***/
	instanceProto.getCharacterWidth = function(character) {
		var widthList = this.characterWidthList;
		if (widthList[character] !== undefined) {
			return widthList[character];
		} else {
			return this.characterWidth;
		}
	};
	instanceProto.rebuildText = function() {
		if (this.text_changed || this.width !== this.lastwrapwidth) {
			this.textWidth = 0;
			this.textHeight = 0;
			this.type.plugin.WordWrap(this);
			this.text_changed = false;
			this.lastwrapwidth = this.width;
		}
	};
	var EPSILON = 0.00001;
	instanceProto.draw = function(ctx, glmode)
	{
		var texture = this.texture_img;
		if (this.text !== "" && texture != null) {
			this.rebuildText();
			if (this.height < this.characterHeight*this.characterScale + this.lineHeight) {
				return;
			}
			ctx.globalAlpha = this.opacity;
			var myx = this.x;
			var myy = this.y;
			if (this.runtime.pixel_rounding)
			{
				myx = Math.round(myx);
				myy = Math.round(myy);
			}
			var viewLeft = this.layer.viewLeft;
			var viewTop = this.layer.viewTop;
			var viewRight = this.layer.viewRight;
			var viewBottom = this.layer.viewBottom;
			ctx.save();
			ctx.translate(myx, myy);
			ctx.rotate(this.angle);
			var angle      = this.angle;
			var ha         = this.halign;
			var va         = this.valign;
			var scale      = this.characterScale;
			var charHeight = this.characterHeight * scale;
			var lineHeight = this.lineHeight;
			var charSpace  = this.characterSpacing;
			var lines = this.lines;
			var textHeight = this.textHeight;
			var letterWidth;
			var halign;
			var valign = va * cr.max(0,(this.height - textHeight));
			var offx = -(this.hotspotX * this.width);
			var offy = -(this.hotspotY * this.height);
			offy += valign;
			var drawX ;
			var drawY = offy;
			var roundX, roundY;
			for(var i = 0; i < lines.length; i++) {
				var line = lines[i].text;
				var len  = lines[i].width;
				halign = ha * cr.max(0,this.width - len);
				drawX = offx + halign;
				drawY += lineHeight;
				if (angle === 0 && myy + drawY + charHeight < viewTop)
				{
					drawY += charHeight;
					continue;
				}
				for(var j = 0; j < line.length; j++) {
					var letter = line.charAt(j);
					letterWidth = this.getCharacterWidth(letter);
					var clip = this.clipList[letter];
					if (angle === 0 && myx + drawX + letterWidth * scale + charSpace < viewLeft)
					{
						drawX += letterWidth * scale + charSpace;
						continue;
					}
					if ( drawX + letterWidth * scale > this.width + EPSILON ) {
						break;
					}
					if (clip !== undefined) {
						roundX = drawX;
						roundY = drawY;
						if (angle === 0)
						{
							roundX = Math.round(roundX);
							roundY = Math.round(roundY);
						}
						ctx.drawImage( this.texture_img,
									 clip.x, clip.y, clip.w, clip.h,
									 roundX,roundY,clip.w*scale,clip.h*scale);
					}
					drawX += letterWidth * scale + charSpace;
					if (angle === 0 && myx + drawX > viewRight)
						break;
				}
				drawY += charHeight;
				if (angle === 0 && (drawY + charHeight + lineHeight > this.height || myy + drawY > viewBottom))
				{
					break;
				}
			}
			ctx.restore();
		}
	};
	var dQuad = new cr.quad();
	function rotateQuad(quad,cosa,sina) {
		var x_temp;
		x_temp   = (quad.tlx * cosa) - (quad.tly * sina);
		quad.tly = (quad.tly * cosa) + (quad.tlx * sina);
		quad.tlx = x_temp;
		x_temp    = (quad.trx * cosa) - (quad.try_ * sina);
		quad.try_ = (quad.try_ * cosa) + (quad.trx * sina);
		quad.trx  = x_temp;
		x_temp   = (quad.blx * cosa) - (quad.bly * sina);
		quad.bly = (quad.bly * cosa) + (quad.blx * sina);
		quad.blx = x_temp;
		x_temp    = (quad.brx * cosa) - (quad.bry * sina);
		quad.bry = (quad.bry * cosa) + (quad.brx * sina);
		quad.brx  = x_temp;
	}
	instanceProto.drawGL = function(glw)
	{
		glw.setTexture(this.webGL_texture);
		glw.setOpacity(this.opacity);
		if (!this.text)
			return;
		this.rebuildText();
		if (this.height < this.characterHeight*this.characterScale + this.lineHeight) {
			return;
		}
		this.update_bbox();
		var q = this.bquad;
		var ox = 0;
		var oy = 0;
		if (this.runtime.pixel_rounding)
		{
			ox = Math.round(this.x) - this.x;
			oy = Math.round(this.y) - this.y;
		}
		var viewLeft = this.layer.viewLeft;
		var viewTop = this.layer.viewTop;
		var viewRight = this.layer.viewRight;
		var viewBottom = this.layer.viewBottom;
		var angle      = this.angle;
		var ha         = this.halign;
		var va         = this.valign;
		var scale      = this.characterScale;
		var charHeight = this.characterHeight * scale;   // to precalculate in onCreate or on change
		var lineHeight = this.lineHeight;
		var charSpace  = this.characterSpacing;
		var lines = this.lines;
		var textHeight = this.textHeight;
		var letterWidth;
		var cosa,sina;
		if (angle !== 0)
		{
			cosa = Math.cos(angle);
			sina = Math.sin(angle);
		}
		var halign;
		var valign = va * cr.max(0,(this.height - textHeight));
		var offx = q.tlx + ox;
		var offy = q.tly + oy;
		var drawX ;
		var drawY = valign;
		var roundX, roundY;
		for(var i = 0; i < lines.length; i++) {
			var line       = lines[i].text;
			var lineWidth  = lines[i].width;
			halign = ha * cr.max(0,this.width - lineWidth);
			drawX = halign;
			drawY += lineHeight;
			if (angle === 0 && offy + drawY + charHeight < viewTop)
			{
				drawY += charHeight;
				continue;
			}
			for(var j = 0; j < line.length; j++) {
				var letter = line.charAt(j);
				letterWidth = this.getCharacterWidth(letter);
				var clipUV = this.clipUV[letter];
				if (angle === 0 && offx + drawX + letterWidth * scale + charSpace < viewLeft)
				{
					drawX += letterWidth * scale + charSpace;
					continue;
				}
				if (drawX + letterWidth * scale > this.width + EPSILON)
				{
					break;
				}
				if (clipUV !== undefined) {
					var clipWidth  = this.characterWidth*scale;
					var clipHeight = this.characterHeight*scale;
					roundX = drawX;
					roundY = drawY;
					if (angle === 0)
					{
						roundX = Math.round(roundX);
						roundY = Math.round(roundY);
					}
					dQuad.tlx  = roundX;
					dQuad.tly  = roundY;
					dQuad.trx  = roundX + clipWidth;
					dQuad.try_ = roundY ;
					dQuad.blx  = roundX;
					dQuad.bly  = roundY + clipHeight;
					dQuad.brx  = roundX + clipWidth;
					dQuad.bry  = roundY + clipHeight;
					if(angle !== 0)
					{
						rotateQuad(dQuad,cosa,sina);
					}
					dQuad.offset(offx,offy);
					glw.quadTex(
						dQuad.tlx, dQuad.tly,
						dQuad.trx, dQuad.try_,
						dQuad.brx, dQuad.bry,
						dQuad.blx, dQuad.bly,
						clipUV
					);
				}
				drawX += letterWidth * scale + charSpace;
				if (angle === 0 && offx + drawX > viewRight)
					break;
			}
			drawY += charHeight;
			if (angle === 0 && (drawY + charHeight + lineHeight > this.height || offy + drawY > viewBottom))
			{
				break;
			}
		}
	};
	function Cnds() {}
	Cnds.prototype.CompareText = function(text_to_compare, case_sensitive)
	{
		if (case_sensitive)
			return this.text == text_to_compare;
		else
			return cr.equals_nocase(this.text, text_to_compare);
	};
	pluginProto.cnds = new Cnds();
	function Acts() {}
	Acts.prototype.SetText = function(param)
	{
		if (cr.is_number(param) && param < 1e9)
			param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
		var text_to_set = param.toString();
		if (this.text !== text_to_set)
		{
			this.text = text_to_set;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	Acts.prototype.AppendText = function(param)
	{
		if (cr.is_number(param))
			param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
		var text_to_append = param.toString();
		if (text_to_append)	// not empty
		{
			this.text += text_to_append;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	Acts.prototype.SetScale = function(param)
	{
		if (param !== this.characterScale) {
			this.characterScale = param;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	Acts.prototype.SetCharacterSpacing = function(param)
	{
		if (param !== this.CharacterSpacing) {
			this.characterSpacing = param;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	Acts.prototype.SetLineHeight = function(param)
	{
		if (param !== this.lineHeight) {
			this.lineHeight = param;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	instanceProto.SetCharWidth = function(character,width) {
		var w = parseInt(width,10);
		if (this.characterWidthList[character] !== w) {
			this.characterWidthList[character] = w;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	Acts.prototype.SetCharacterWidth = function(characterSet,width)
	{
		if (characterSet !== "") {
			for(var c = 0; c < characterSet.length; c++) {
				this.SetCharWidth(characterSet.charAt(c),width);
			}
		}
	};
	Acts.prototype.SetEffect = function (effect)
	{
		this.blend_mode = effect;
		this.compositeOp = cr.effectToCompositeOp(effect);
		cr.setGLBlend(this, effect, this.runtime.gl);
		this.runtime.redraw = true;
	};
	Acts.prototype.SetHAlign = function (a)
	{
		this.halign = a / 2.0;
		this.text_changed = true;
		this.runtime.redraw = true;
	};
	Acts.prototype.SetVAlign = function (a)
	{
		this.valign = a / 2.0;
		this.text_changed = true;
		this.runtime.redraw = true;
	};
	pluginProto.acts = new Acts();
	function Exps() {}
	Exps.prototype.CharacterWidth = function(ret,character)
	{
		ret.set_int(this.getCharacterWidth(character));
	};
	Exps.prototype.CharacterHeight = function(ret)
	{
		ret.set_int(this.characterHeight);
	};
	Exps.prototype.CharacterScale = function(ret)
	{
		ret.set_float(this.characterScale);
	};
	Exps.prototype.CharacterSpacing = function(ret)
	{
		ret.set_int(this.characterSpacing);
	};
	Exps.prototype.LineHeight = function(ret)
	{
		ret.set_int(this.lineHeight);
	};
	Exps.prototype.Text = function(ret)
	{
		ret.set_string(this.text);
	};
	Exps.prototype.TextWidth = function (ret)
	{
		this.rebuildText();
		ret.set_float(this.textWidth);
	};
	Exps.prototype.TextHeight = function (ret)
	{
		this.rebuildText();
		ret.set_float(this.textHeight);
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.plugins_.Text = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Text.prototype;
	pluginProto.onCreate = function ()
	{
		pluginProto.acts.SetWidth = function (w)
		{
			if (this.width !== w)
			{
				this.width = w;
				this.text_changed = true;	// also recalculate text wrapping
				this.set_bbox_changed();
			}
		};
	};
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
	};
	typeProto.onLostWebGLContext = function ()
	{
		if (this.is_family)
			return;
		var i, len, inst;
		for (i = 0, len = this.instances.length; i < len; i++)
		{
			inst = this.instances[i];
			inst.mycanvas = null;
			inst.myctx = null;
			inst.mytex = null;
		}
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
		if (this.recycled)
			cr.clearArray(this.lines);
		else
			this.lines = [];		// for word wrapping
		this.text_changed = true;
	};
	var instanceProto = pluginProto.Instance.prototype;
	var requestedWebFonts = {};		// already requested web fonts have an entry here
	instanceProto.onCreate = function()
	{
		this.text = this.properties[0];
		this.visible = (this.properties[1] === 0);		// 0=visible, 1=invisible
		this.font = this.properties[2];
		this.color = this.properties[3];
		this.halign = this.properties[4];				// 0=left, 1=center, 2=right
		this.valign = this.properties[5];				// 0=top, 1=center, 2=bottom
		this.wrapbyword = (this.properties[7] === 0);	// 0=word, 1=character
		this.lastwidth = this.width;
		this.lastwrapwidth = this.width;
		this.lastheight = this.height;
		this.line_height_offset = this.properties[8];
		this.facename = "";
		this.fontstyle = "";
		this.ptSize = 0;
		this.textWidth = 0;
		this.textHeight = 0;
		this.parseFont();
		this.mycanvas = null;
		this.myctx = null;
		this.mytex = null;
		this.need_text_redraw = false;
		this.last_render_tick = this.runtime.tickcount;
		if (this.recycled)
			this.rcTex.set(0, 0, 1, 1);
		else
			this.rcTex = new cr.rect(0, 0, 1, 1);
		if (this.runtime.glwrap)
			this.runtime.tickMe(this);
;
	};
	instanceProto.parseFont = function ()
	{
		var arr = this.font.split(" ");
		var i;
		for (i = 0; i < arr.length; i++)
		{
			if (arr[i].substr(arr[i].length - 2, 2) === "pt")
			{
				this.ptSize = parseInt(arr[i].substr(0, arr[i].length - 2));
				this.pxHeight = Math.ceil((this.ptSize / 72.0) * 96.0) + 4;	// assume 96dpi...
				if (i > 0)
					this.fontstyle = arr[i - 1];
				this.facename = arr[i + 1];
				for (i = i + 2; i < arr.length; i++)
					this.facename += " " + arr[i];
				break;
			}
		}
	};
	instanceProto.saveToJSON = function ()
	{
		return {
			"t": this.text,
			"f": this.font,
			"c": this.color,
			"ha": this.halign,
			"va": this.valign,
			"wr": this.wrapbyword,
			"lho": this.line_height_offset,
			"fn": this.facename,
			"fs": this.fontstyle,
			"ps": this.ptSize,
			"pxh": this.pxHeight,
			"tw": this.textWidth,
			"th": this.textHeight,
			"lrt": this.last_render_tick
		};
	};
	instanceProto.loadFromJSON = function (o)
	{
		this.text = o["t"];
		this.font = o["f"];
		this.color = o["c"];
		this.halign = o["ha"];
		this.valign = o["va"];
		this.wrapbyword = o["wr"];
		this.line_height_offset = o["lho"];
		this.facename = o["fn"];
		this.fontstyle = o["fs"];
		this.ptSize = o["ps"];
		this.pxHeight = o["pxh"];
		this.textWidth = o["tw"];
		this.textHeight = o["th"];
		this.last_render_tick = o["lrt"];
		this.text_changed = true;
		this.lastwidth = this.width;
		this.lastwrapwidth = this.width;
		this.lastheight = this.height;
	};
	instanceProto.tick = function ()
	{
		if (this.runtime.glwrap && this.mytex && (this.runtime.tickcount - this.last_render_tick >= 300))
		{
			var layer = this.layer;
            this.update_bbox();
            var bbox = this.bbox;
            if (bbox.right < layer.viewLeft || bbox.bottom < layer.viewTop || bbox.left > layer.viewRight || bbox.top > layer.viewBottom)
			{
				this.runtime.glwrap.deleteTexture(this.mytex);
				this.mytex = null;
				this.myctx = null;
				this.mycanvas = null;
			}
		}
	};
	instanceProto.onDestroy = function ()
	{
		this.myctx = null;
		this.mycanvas = null;
		if (this.runtime.glwrap && this.mytex)
			this.runtime.glwrap.deleteTexture(this.mytex);
		this.mytex = null;
	};
	instanceProto.updateFont = function ()
	{
		this.font = this.fontstyle + " " + this.ptSize.toString() + "pt " + this.facename;
		this.text_changed = true;
		this.runtime.redraw = true;
	};
	instanceProto.draw = function(ctx, glmode)
	{
		ctx.font = this.font;
		ctx.textBaseline = "top";
		ctx.fillStyle = this.color;
		ctx.globalAlpha = glmode ? 1 : this.opacity;
		var myscale = 1;
		if (glmode)
		{
			myscale = Math.abs(this.layer.getScale());
			ctx.save();
			ctx.scale(myscale, myscale);
		}
		if (this.text_changed || this.width !== this.lastwrapwidth)
		{
			this.type.plugin.WordWrap(this.text, this.lines, ctx, this.width, this.wrapbyword);
			this.text_changed = false;
			this.lastwrapwidth = this.width;
		}
		this.update_bbox();
		var penX = glmode ? 0 : this.bquad.tlx;
		var penY = glmode ? 0 : this.bquad.tly;
		if (this.runtime.pixel_rounding)
		{
			penX = (penX + 0.5) | 0;
			penY = (penY + 0.5) | 0;
		}
		if (this.angle !== 0 && !glmode)
		{
			ctx.save();
			ctx.translate(penX, penY);
			ctx.rotate(this.angle);
			penX = 0;
			penY = 0;
		}
		var endY = penY + this.height;
		var line_height = this.pxHeight;
		line_height += this.line_height_offset;
		var drawX;
		var i;
		if (this.valign === 1)		// center
			penY += Math.max(this.height / 2 - (this.lines.length * line_height) / 2, 0);
		else if (this.valign === 2)	// bottom
			penY += Math.max(this.height - (this.lines.length * line_height) - 2, 0);
		for (i = 0; i < this.lines.length; i++)
		{
			drawX = penX;
			if (this.halign === 1)		// center
				drawX = penX + (this.width - this.lines[i].width) / 2;
			else if (this.halign === 2)	// right
				drawX = penX + (this.width - this.lines[i].width);
			ctx.fillText(this.lines[i].text, drawX, penY);
			penY += line_height;
			if (penY >= endY - line_height)
				break;
		}
		if (this.angle !== 0 || glmode)
			ctx.restore();
		this.last_render_tick = this.runtime.tickcount;
	};
	instanceProto.drawGL = function(glw)
	{
		if (this.width < 1 || this.height < 1)
			return;
		var need_redraw = this.text_changed || this.need_text_redraw;
		this.need_text_redraw = false;
		var layer_scale = this.layer.getScale();
		var layer_angle = this.layer.getAngle();
		var rcTex = this.rcTex;
		var floatscaledwidth = layer_scale * this.width;
		var floatscaledheight = layer_scale * this.height;
		var scaledwidth = Math.ceil(floatscaledwidth);
		var scaledheight = Math.ceil(floatscaledheight);
		var absscaledwidth = Math.abs(scaledwidth);
		var absscaledheight = Math.abs(scaledheight);
		var halfw = this.runtime.draw_width / 2;
		var halfh = this.runtime.draw_height / 2;
		if (!this.myctx)
		{
			this.mycanvas = document.createElement("canvas");
			this.mycanvas.width = absscaledwidth;
			this.mycanvas.height = absscaledheight;
			this.lastwidth = absscaledwidth;
			this.lastheight = absscaledheight;
			need_redraw = true;
			this.myctx = this.mycanvas.getContext("2d");
		}
		if (absscaledwidth !== this.lastwidth || absscaledheight !== this.lastheight)
		{
			this.mycanvas.width = absscaledwidth;
			this.mycanvas.height = absscaledheight;
			if (this.mytex)
			{
				glw.deleteTexture(this.mytex);
				this.mytex = null;
			}
			need_redraw = true;
		}
		if (need_redraw)
		{
			this.myctx.clearRect(0, 0, absscaledwidth, absscaledheight);
			this.draw(this.myctx, true);
			if (!this.mytex)
				this.mytex = glw.createEmptyTexture(absscaledwidth, absscaledheight, this.runtime.linearSampling, this.runtime.isMobile);
			glw.videoToTexture(this.mycanvas, this.mytex, this.runtime.isMobile);
		}
		this.lastwidth = absscaledwidth;
		this.lastheight = absscaledheight;
		glw.setTexture(this.mytex);
		glw.setOpacity(this.opacity);
		glw.resetModelView();
		glw.translate(-halfw, -halfh);
		glw.updateModelView();
		var q = this.bquad;
		var tlx = this.layer.layerToCanvas(q.tlx, q.tly, true, true);
		var tly = this.layer.layerToCanvas(q.tlx, q.tly, false, true);
		var trx = this.layer.layerToCanvas(q.trx, q.try_, true, true);
		var try_ = this.layer.layerToCanvas(q.trx, q.try_, false, true);
		var brx = this.layer.layerToCanvas(q.brx, q.bry, true, true);
		var bry = this.layer.layerToCanvas(q.brx, q.bry, false, true);
		var blx = this.layer.layerToCanvas(q.blx, q.bly, true, true);
		var bly = this.layer.layerToCanvas(q.blx, q.bly, false, true);
		if (this.runtime.pixel_rounding || (this.angle === 0 && layer_angle === 0))
		{
			var ox = ((tlx + 0.5) | 0) - tlx;
			var oy = ((tly + 0.5) | 0) - tly
			tlx += ox;
			tly += oy;
			trx += ox;
			try_ += oy;
			brx += ox;
			bry += oy;
			blx += ox;
			bly += oy;
		}
		if (this.angle === 0 && layer_angle === 0)
		{
			trx = tlx + scaledwidth;
			try_ = tly;
			brx = trx;
			bry = tly + scaledheight;
			blx = tlx;
			bly = bry;
			rcTex.right = 1;
			rcTex.bottom = 1;
		}
		else
		{
			rcTex.right = floatscaledwidth / scaledwidth;
			rcTex.bottom = floatscaledheight / scaledheight;
		}
		glw.quadTex(tlx, tly, trx, try_, brx, bry, blx, bly, rcTex);
		glw.resetModelView();
		glw.scale(layer_scale, layer_scale);
		glw.rotateZ(-this.layer.getAngle());
		glw.translate((this.layer.viewLeft + this.layer.viewRight) / -2, (this.layer.viewTop + this.layer.viewBottom) / -2);
		glw.updateModelView();
		this.last_render_tick = this.runtime.tickcount;
	};
	var wordsCache = [];
	pluginProto.TokeniseWords = function (text)
	{
		cr.clearArray(wordsCache);
		var cur_word = "";
		var ch;
		var i = 0;
		while (i < text.length)
		{
			ch = text.charAt(i);
			if (ch === "\n")
			{
				if (cur_word.length)
				{
					wordsCache.push(cur_word);
					cur_word = "";
				}
				wordsCache.push("\n");
				++i;
			}
			else if (ch === " " || ch === "\t" || ch === "-")
			{
				do {
					cur_word += text.charAt(i);
					i++;
				}
				while (i < text.length && (text.charAt(i) === " " || text.charAt(i) === "\t"));
				wordsCache.push(cur_word);
				cur_word = "";
			}
			else if (i < text.length)
			{
				cur_word += ch;
				i++;
			}
		}
		if (cur_word.length)
			wordsCache.push(cur_word);
	};
	var linesCache = [];
	function allocLine()
	{
		if (linesCache.length)
			return linesCache.pop();
		else
			return {};
	};
	function freeLine(l)
	{
		linesCache.push(l);
	};
	function freeAllLines(arr)
	{
		var i, len;
		for (i = 0, len = arr.length; i < len; i++)
		{
			freeLine(arr[i]);
		}
		cr.clearArray(arr);
	};
	pluginProto.WordWrap = function (text, lines, ctx, width, wrapbyword)
	{
		if (!text || !text.length)
		{
			freeAllLines(lines);
			return;
		}
		if (width <= 2.0)
		{
			freeAllLines(lines);
			return;
		}
		if (text.length <= 100 && text.indexOf("\n") === -1)
		{
			var all_width = ctx.measureText(text).width;
			if (all_width <= width)
			{
				freeAllLines(lines);
				lines.push(allocLine());
				lines[0].text = text;
				lines[0].width = all_width;
				return;
			}
		}
		this.WrapText(text, lines, ctx, width, wrapbyword);
	};
	function trimSingleSpaceRight(str)
	{
		if (!str.length || str.charAt(str.length - 1) !== " ")
			return str;
		return str.substring(0, str.length - 1);
	};
	pluginProto.WrapText = function (text, lines, ctx, width, wrapbyword)
	{
		var wordArray;
		if (wrapbyword)
		{
			this.TokeniseWords(text);	// writes to wordsCache
			wordArray = wordsCache;
		}
		else
			wordArray = text;
		var cur_line = "";
		var prev_line;
		var line_width;
		var i;
		var lineIndex = 0;
		var line;
		for (i = 0; i < wordArray.length; i++)
		{
			if (wordArray[i] === "\n")
			{
				if (lineIndex >= lines.length)
					lines.push(allocLine());
				cur_line = trimSingleSpaceRight(cur_line);		// for correct center/right alignment
				line = lines[lineIndex];
				line.text = cur_line;
				line.width = ctx.measureText(cur_line).width;
				lineIndex++;
				cur_line = "";
				continue;
			}
			prev_line = cur_line;
			cur_line += wordArray[i];
			line_width = ctx.measureText(cur_line).width;
			if (line_width >= width)
			{
				if (lineIndex >= lines.length)
					lines.push(allocLine());
				prev_line = trimSingleSpaceRight(prev_line);
				line = lines[lineIndex];
				line.text = prev_line;
				line.width = ctx.measureText(prev_line).width;
				lineIndex++;
				cur_line = wordArray[i];
				if (!wrapbyword && cur_line === " ")
					cur_line = "";
			}
		}
		if (cur_line.length)
		{
			if (lineIndex >= lines.length)
				lines.push(allocLine());
			cur_line = trimSingleSpaceRight(cur_line);
			line = lines[lineIndex];
			line.text = cur_line;
			line.width = ctx.measureText(cur_line).width;
			lineIndex++;
		}
		for (i = lineIndex; i < lines.length; i++)
			freeLine(lines[i]);
		lines.length = lineIndex;
	};
	function Cnds() {};
	Cnds.prototype.CompareText = function(text_to_compare, case_sensitive)
	{
		if (case_sensitive)
			return this.text == text_to_compare;
		else
			return cr.equals_nocase(this.text, text_to_compare);
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.SetText = function(param)
	{
		if (cr.is_number(param) && param < 1e9)
			param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
		var text_to_set = param.toString();
		if (this.text !== text_to_set)
		{
			this.text = text_to_set;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	Acts.prototype.AppendText = function(param)
	{
		if (cr.is_number(param))
			param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
		var text_to_append = param.toString();
		if (text_to_append)	// not empty
		{
			this.text += text_to_append;
			this.text_changed = true;
			this.runtime.redraw = true;
		}
	};
	Acts.prototype.SetFontFace = function (face_, style_)
	{
		var newstyle = "";
		switch (style_) {
		case 1: newstyle = "bold"; break;
		case 2: newstyle = "italic"; break;
		case 3: newstyle = "bold italic"; break;
		}
		if (face_ === this.facename && newstyle === this.fontstyle)
			return;		// no change
		this.facename = face_;
		this.fontstyle = newstyle;
		this.updateFont();
	};
	Acts.prototype.SetFontSize = function (size_)
	{
		if (this.ptSize === size_)
			return;
		this.ptSize = size_;
		this.pxHeight = Math.ceil((this.ptSize / 72.0) * 96.0) + 4;	// assume 96dpi...
		this.updateFont();
	};
	Acts.prototype.SetFontColor = function (rgb)
	{
		var newcolor = "rgb(" + cr.GetRValue(rgb).toString() + "," + cr.GetGValue(rgb).toString() + "," + cr.GetBValue(rgb).toString() + ")";
		if (newcolor === this.color)
			return;
		this.color = newcolor;
		this.need_text_redraw = true;
		this.runtime.redraw = true;
	};
	Acts.prototype.SetWebFont = function (familyname_, cssurl_)
	{
		if (this.runtime.isDomFree)
		{
			cr.logexport("[Construct 2] Text plugin: 'Set web font' not supported on this platform - the action has been ignored");
			return;		// DC todo
		}
		var self = this;
		var refreshFunc = (function () {
							self.runtime.redraw = true;
							self.text_changed = true;
						});
		if (requestedWebFonts.hasOwnProperty(cssurl_))
		{
			var newfacename = "'" + familyname_ + "'";
			if (this.facename === newfacename)
				return;	// no change
			this.facename = newfacename;
			this.updateFont();
			for (var i = 1; i < 10; i++)
			{
				setTimeout(refreshFunc, i * 100);
				setTimeout(refreshFunc, i * 1000);
			}
			return;
		}
		var wf = document.createElement("link");
		wf.href = cssurl_;
		wf.rel = "stylesheet";
		wf.type = "text/css";
		wf.onload = refreshFunc;
		document.getElementsByTagName('head')[0].appendChild(wf);
		requestedWebFonts[cssurl_] = true;
		this.facename = "'" + familyname_ + "'";
		this.updateFont();
		for (var i = 1; i < 10; i++)
		{
			setTimeout(refreshFunc, i * 100);
			setTimeout(refreshFunc, i * 1000);
		}
;
	};
	Acts.prototype.SetEffect = function (effect)
	{
		this.blend_mode = effect;
		this.compositeOp = cr.effectToCompositeOp(effect);
		cr.setGLBlend(this, effect, this.runtime.gl);
		this.runtime.redraw = true;
	};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.Text = function(ret)
	{
		ret.set_string(this.text);
	};
	Exps.prototype.FaceName = function (ret)
	{
		ret.set_string(this.facename);
	};
	Exps.prototype.FaceSize = function (ret)
	{
		ret.set_int(this.ptSize);
	};
	Exps.prototype.TextWidth = function (ret)
	{
		var w = 0;
		var i, len, x;
		for (i = 0, len = this.lines.length; i < len; i++)
		{
			x = this.lines[i].width;
			if (w < x)
				w = x;
		}
		ret.set_int(w);
	};
	Exps.prototype.TextHeight = function (ret)
	{
		ret.set_int(this.lines.length * (this.pxHeight + this.line_height_offset) - this.line_height_offset);
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.plugins_.TiledBg = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.TiledBg.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
		if (this.is_family)
			return;
		this.texture_img = new Image();
		this.texture_img.cr_filesize = this.texture_filesize;
		this.runtime.waitForImageLoad(this.texture_img, this.texture_file);
		this.pattern = null;
		this.webGL_texture = null;
	};
	typeProto.onLostWebGLContext = function ()
	{
		if (this.is_family)
			return;
		this.webGL_texture = null;
	};
	typeProto.onRestoreWebGLContext = function ()
	{
		if (this.is_family || !this.instances.length)
			return;
		if (!this.webGL_texture)
		{
			this.webGL_texture = this.runtime.glwrap.loadTexture(this.texture_img, true, this.runtime.linearSampling, this.texture_pixelformat);
		}
		var i, len;
		for (i = 0, len = this.instances.length; i < len; i++)
			this.instances[i].webGL_texture = this.webGL_texture;
	};
	typeProto.loadTextures = function ()
	{
		if (this.is_family || this.webGL_texture || !this.runtime.glwrap)
			return;
		this.webGL_texture = this.runtime.glwrap.loadTexture(this.texture_img, true, this.runtime.linearSampling, this.texture_pixelformat);
	};
	typeProto.unloadTextures = function ()
	{
		if (this.is_family || this.instances.length || !this.webGL_texture)
			return;
		this.runtime.glwrap.deleteTexture(this.webGL_texture);
		this.webGL_texture = null;
	};
	typeProto.preloadCanvas2D = function (ctx)
	{
		ctx.drawImage(this.texture_img, 0, 0);
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
	};
	var instanceProto = pluginProto.Instance.prototype;
	instanceProto.onCreate = function()
	{
		this.visible = (this.properties[0] === 0);							// 0=visible, 1=invisible
		this.rcTex = new cr.rect(0, 0, 0, 0);
		this.has_own_texture = false;										// true if a texture loaded in from URL
		this.texture_img = this.type.texture_img;
		if (this.runtime.glwrap)
		{
			this.type.loadTextures();
			this.webGL_texture = this.type.webGL_texture;
		}
		else
		{
			if (!this.type.pattern)
				this.type.pattern = this.runtime.ctx.createPattern(this.type.texture_img, "repeat");
			this.pattern = this.type.pattern;
		}
	};
	instanceProto.afterLoad = function ()
	{
		this.has_own_texture = false;
		this.texture_img = this.type.texture_img;
	};
	instanceProto.onDestroy = function ()
	{
		if (this.runtime.glwrap && this.has_own_texture && this.webGL_texture)
		{
			this.runtime.glwrap.deleteTexture(this.webGL_texture);
			this.webGL_texture = null;
		}
	};
	instanceProto.draw = function(ctx)
	{
		ctx.globalAlpha = this.opacity;
		ctx.save();
		ctx.fillStyle = this.pattern;
		var myx = this.x;
		var myy = this.y;
		if (this.runtime.pixel_rounding)
		{
			myx = Math.round(myx);
			myy = Math.round(myy);
		}
		var drawX = -(this.hotspotX * this.width);
		var drawY = -(this.hotspotY * this.height);
		var offX = drawX % this.texture_img.width;
		var offY = drawY % this.texture_img.height;
		if (offX < 0)
			offX += this.texture_img.width;
		if (offY < 0)
			offY += this.texture_img.height;
		ctx.translate(myx, myy);
		ctx.rotate(this.angle);
		ctx.translate(offX, offY);
		ctx.fillRect(drawX - offX,
					 drawY - offY,
					 this.width,
					 this.height);
		ctx.restore();
	};
	instanceProto.drawGL_earlyZPass = function(glw)
	{
		this.drawGL(glw);
	};
	instanceProto.drawGL = function(glw)
	{
		glw.setTexture(this.webGL_texture);
		glw.setOpacity(this.opacity);
		var rcTex = this.rcTex;
		rcTex.right = this.width / this.texture_img.width;
		rcTex.bottom = this.height / this.texture_img.height;
		var q = this.bquad;
		if (this.runtime.pixel_rounding)
		{
			var ox = Math.round(this.x) - this.x;
			var oy = Math.round(this.y) - this.y;
			glw.quadTex(q.tlx + ox, q.tly + oy, q.trx + ox, q.try_ + oy, q.brx + ox, q.bry + oy, q.blx + ox, q.bly + oy, rcTex);
		}
		else
			glw.quadTex(q.tlx, q.tly, q.trx, q.try_, q.brx, q.bry, q.blx, q.bly, rcTex);
	};
	function Cnds() {};
	Cnds.prototype.OnURLLoaded = function ()
	{
		return true;
	};
	pluginProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.SetEffect = function (effect)
	{
		this.blend_mode = effect;
		this.compositeOp = cr.effectToCompositeOp(effect);
		cr.setGLBlend(this, effect, this.runtime.gl);
		this.runtime.redraw = true;
	};
	Acts.prototype.LoadURL = function (url_)
	{
		var img = new Image();
		var self = this;
		img.onload = function ()
		{
			self.texture_img = img;
			if (self.runtime.glwrap)
			{
				if (self.has_own_texture && self.webGL_texture)
					self.runtime.glwrap.deleteTexture(self.webGL_texture);
				self.webGL_texture = self.runtime.glwrap.loadTexture(img, true, self.runtime.linearSampling);
			}
			else
			{
				self.pattern = self.runtime.ctx.createPattern(img, "repeat");
			}
			self.has_own_texture = true;
			self.runtime.redraw = true;
			self.runtime.trigger(cr.plugins_.TiledBg.prototype.cnds.OnURLLoaded, self);
		};
		if (url_.substr(0, 5) !== "data:")
			img.crossOrigin = "anonymous";
		this.runtime.setImageSrc(img, url_);
	};
	pluginProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.ImageWidth = function (ret)
	{
		ret.set_float(this.texture_img.width);
	};
	Exps.prototype.ImageHeight = function (ret)
	{
		ret.set_float(this.texture_img.height);
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.plugins_.Touch = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var pluginProto = cr.plugins_.Touch.prototype;
	pluginProto.Type = function(plugin)
	{
		this.plugin = plugin;
		this.runtime = plugin.runtime;
	};
	var typeProto = pluginProto.Type.prototype;
	typeProto.onCreate = function()
	{
	};
	pluginProto.Instance = function(type)
	{
		this.type = type;
		this.runtime = type.runtime;
		this.touches = [];
		this.mouseDown = false;
	};
	var instanceProto = pluginProto.Instance.prototype;
	var dummyoffset = {left: 0, top: 0};
	instanceProto.findTouch = function (id)
	{
		var i, len;
		for (i = 0, len = this.touches.length; i < len; i++)
		{
			if (this.touches[i]["id"] === id)
				return i;
		}
		return -1;
	};
	var appmobi_accx = 0;
	var appmobi_accy = 0;
	var appmobi_accz = 0;
	function AppMobiGetAcceleration(evt)
	{
		appmobi_accx = evt.x;
		appmobi_accy = evt.y;
		appmobi_accz = evt.z;
	};
	var pg_accx = 0;
	var pg_accy = 0;
	var pg_accz = 0;
	function PhoneGapGetAcceleration(evt)
	{
		pg_accx = evt.x;
		pg_accy = evt.y;
		pg_accz = evt.z;
	};
	var theInstance = null;
	var touchinfo_cache = [];
	function AllocTouchInfo(x, y, id, index)
	{
		var ret;
		if (touchinfo_cache.length)
			ret = touchinfo_cache.pop();
		else
			ret = new TouchInfo();
		ret.init(x, y, id, index);
		return ret;
	};
	function ReleaseTouchInfo(ti)
	{
		if (touchinfo_cache.length < 100)
			touchinfo_cache.push(ti);
	};
	var GESTURE_HOLD_THRESHOLD = 15;		// max px motion for hold gesture to register
	var GESTURE_HOLD_TIMEOUT = 500;			// time for hold gesture to register
	var GESTURE_TAP_TIMEOUT = 333;			// time for tap gesture to register
	var GESTURE_DOUBLETAP_THRESHOLD = 25;	// max distance apart for taps to be
	function TouchInfo()
	{
		this.starttime = 0;
		this.time = 0;
		this.lasttime = 0;
		this.startx = 0;
		this.starty = 0;
		this.x = 0;
		this.y = 0;
		this.lastx = 0;
		this.lasty = 0;
		this["id"] = 0;
		this.startindex = 0;
		this.triggeredHold = false;
		this.tooFarForHold = false;
	};
	TouchInfo.prototype.init = function (x, y, id, index)
	{
		var nowtime = cr.performance_now();
		this.time = nowtime;
		this.lasttime = nowtime;
		this.starttime = nowtime;
		this.startx = x;
		this.starty = y;
		this.x = x;
		this.y = y;
		this.lastx = x;
		this.lasty = y;
		this.width = 0;
		this.height = 0;
		this.pressure = 0;
		this["id"] = id;
		this.startindex = index;
		this.triggeredHold = false;
		this.tooFarForHold = false;
	};
	TouchInfo.prototype.update = function (nowtime, x, y, width, height, pressure)
	{
		this.lasttime = this.time;
		this.time = nowtime;
		this.lastx = this.x;
		this.lasty = this.y;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.pressure = pressure;
		if (!this.tooFarForHold && cr.distanceTo(this.startx, this.starty, this.x, this.y) >= GESTURE_HOLD_THRESHOLD)
		{
			this.tooFarForHold = true;
		}
	};
	TouchInfo.prototype.maybeTriggerHold = function (inst, index)
	{
		if (this.triggeredHold)
			return;		// already triggered this gesture
		var nowtime = cr.performance_now();
		if (nowtime - this.starttime >= GESTURE_HOLD_TIMEOUT && !this.tooFarForHold && cr.distanceTo(this.startx, this.starty, this.x, this.y) < GESTURE_HOLD_THRESHOLD)
		{
			this.triggeredHold = true;
			inst.trigger_index = this.startindex;
			inst.trigger_id = this["id"];
			inst.getTouchIndex = index;
			inst.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnHoldGesture, inst);
			inst.curTouchX = this.x;
			inst.curTouchY = this.y;
			inst.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnHoldGestureObject, inst);
			inst.getTouchIndex = 0;
		}
	};
	var lastTapX = -1000;
	var lastTapY = -1000;
	var lastTapTime = -10000;
	TouchInfo.prototype.maybeTriggerTap = function (inst, index)
	{
		if (this.triggeredHold)
			return;
		var nowtime = cr.performance_now();
		if (nowtime - this.starttime <= GESTURE_TAP_TIMEOUT && !this.tooFarForHold && cr.distanceTo(this.startx, this.starty, this.x, this.y) < GESTURE_HOLD_THRESHOLD)
		{
			inst.trigger_index = this.startindex;
			inst.trigger_id = this["id"];
			inst.getTouchIndex = index;
			if ((nowtime - lastTapTime <= GESTURE_TAP_TIMEOUT * 2) && cr.distanceTo(lastTapX, lastTapY, this.x, this.y) < GESTURE_DOUBLETAP_THRESHOLD)
			{
				inst.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnDoubleTapGesture, inst);
				inst.curTouchX = this.x;
				inst.curTouchY = this.y;
				inst.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnDoubleTapGestureObject, inst);
				lastTapX = -1000;
				lastTapY = -1000;
				lastTapTime = -10000;
			}
			else
			{
				inst.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTapGesture, inst);
				inst.curTouchX = this.x;
				inst.curTouchY = this.y;
				inst.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTapGestureObject, inst);
				lastTapX = this.x;
				lastTapY = this.y;
				lastTapTime = nowtime;
			}
			inst.getTouchIndex = 0;
		}
	};
	instanceProto.onCreate = function()
	{
		theInstance = this;
		this.isWindows8 = !!(typeof window["c2isWindows8"] !== "undefined" && window["c2isWindows8"]);
		this.orient_alpha = 0;
		this.orient_beta = 0;
		this.orient_gamma = 0;
		this.acc_g_x = 0;
		this.acc_g_y = 0;
		this.acc_g_z = 0;
		this.acc_x = 0;
		this.acc_y = 0;
		this.acc_z = 0;
		this.curTouchX = 0;
		this.curTouchY = 0;
		this.trigger_index = 0;
		this.trigger_id = 0;
		this.getTouchIndex = 0;
		this.useMouseInput = (this.properties[0] !== 0);
		var elem = (this.runtime.fullscreen_mode > 0) ? document : this.runtime.canvas;
		var elem2 = document;
		if (this.runtime.isDirectCanvas)
			elem2 = elem = window["Canvas"];
		else if (this.runtime.isCocoonJs)
			elem2 = elem = window;
		var self = this;
		if (window.navigator["pointerEnabled"])
		{
			elem.addEventListener("pointerdown",
				function(info) {
					self.onPointerStart(info);
				},
				false
			);
			elem.addEventListener("pointermove",
				function(info) {
					self.onPointerMove(info);
				},
				false
			);
			elem2.addEventListener("pointerup",
				function(info) {
					self.onPointerEnd(info, false);
				},
				false
			);
			elem2.addEventListener("pointercancel",
				function(info) {
					self.onPointerEnd(info, true);
				},
				false
			);
			if (this.runtime.canvas)
			{
				this.runtime.canvas.addEventListener("MSGestureHold", function(e) {
					e.preventDefault();
				}, false);
				document.addEventListener("MSGestureHold", function(e) {
					e.preventDefault();
				}, false);
				this.runtime.canvas.addEventListener("gesturehold", function(e) {
					e.preventDefault();
				}, false);
				document.addEventListener("gesturehold", function(e) {
					e.preventDefault();
				}, false);
			}
		}
		else if (window.navigator["msPointerEnabled"])
		{
			elem.addEventListener("MSPointerDown",
				function(info) {
					self.onPointerStart(info);
				},
				false
			);
			elem.addEventListener("MSPointerMove",
				function(info) {
					self.onPointerMove(info);
				},
				false
			);
			elem2.addEventListener("MSPointerUp",
				function(info) {
					self.onPointerEnd(info, false);
				},
				false
			);
			elem2.addEventListener("MSPointerCancel",
				function(info) {
					self.onPointerEnd(info, true);
				},
				false
			);
			if (this.runtime.canvas)
			{
				this.runtime.canvas.addEventListener("MSGestureHold", function(e) {
					e.preventDefault();
				}, false);
				document.addEventListener("MSGestureHold", function(e) {
					e.preventDefault();
				}, false);
			}
		}
		else
		{
			elem.addEventListener("touchstart",
				function(info) {
					self.onTouchStart(info);
				},
				false
			);
			elem.addEventListener("touchmove",
				function(info) {
					self.onTouchMove(info);
				},
				false
			);
			elem2.addEventListener("touchend",
				function(info) {
					self.onTouchEnd(info, false);
				},
				false
			);
			elem2.addEventListener("touchcancel",
				function(info) {
					self.onTouchEnd(info, true);
				},
				false
			);
		}
		if (this.isWindows8)
		{
			var win8accelerometerFn = function(e) {
					var reading = e["reading"];
					self.acc_x = reading["accelerationX"];
					self.acc_y = reading["accelerationY"];
					self.acc_z = reading["accelerationZ"];
				};
			var win8inclinometerFn = function(e) {
					var reading = e["reading"];
					self.orient_alpha = reading["yawDegrees"];
					self.orient_beta = reading["pitchDegrees"];
					self.orient_gamma = reading["rollDegrees"];
				};
			var accelerometer = Windows["Devices"]["Sensors"]["Accelerometer"]["getDefault"]();
            if (accelerometer)
			{
                accelerometer["reportInterval"] = Math.max(accelerometer["minimumReportInterval"], 16);
				accelerometer.addEventListener("readingchanged", win8accelerometerFn);
            }
			var inclinometer = Windows["Devices"]["Sensors"]["Inclinometer"]["getDefault"]();
			if (inclinometer)
			{
				inclinometer["reportInterval"] = Math.max(inclinometer["minimumReportInterval"], 16);
				inclinometer.addEventListener("readingchanged", win8inclinometerFn);
			}
			document.addEventListener("visibilitychange", function(e) {
				if (document["hidden"] || document["msHidden"])
				{
					if (accelerometer)
						accelerometer.removeEventListener("readingchanged", win8accelerometerFn);
					if (inclinometer)
						inclinometer.removeEventListener("readingchanged", win8inclinometerFn);
				}
				else
				{
					if (accelerometer)
						accelerometer.addEventListener("readingchanged", win8accelerometerFn);
					if (inclinometer)
						inclinometer.addEventListener("readingchanged", win8inclinometerFn);
				}
			}, false);
		}
		else
		{
			window.addEventListener("deviceorientation", function (eventData) {
				self.orient_alpha = eventData["alpha"] || 0;
				self.orient_beta = eventData["beta"] || 0;
				self.orient_gamma = eventData["gamma"] || 0;
			}, false);
			window.addEventListener("devicemotion", function (eventData) {
				if (eventData["accelerationIncludingGravity"])
				{
					self.acc_g_x = eventData["accelerationIncludingGravity"]["x"] || 0;
					self.acc_g_y = eventData["accelerationIncludingGravity"]["y"] || 0;
					self.acc_g_z = eventData["accelerationIncludingGravity"]["z"] || 0;
				}
				if (eventData["acceleration"])
				{
					self.acc_x = eventData["acceleration"]["x"] || 0;
					self.acc_y = eventData["acceleration"]["y"] || 0;
					self.acc_z = eventData["acceleration"]["z"] || 0;
				}
			}, false);
		}
		if (this.useMouseInput && !this.runtime.isDomFree)
		{
			jQuery(document).mousemove(
				function(info) {
					self.onMouseMove(info);
				}
			);
			jQuery(document).mousedown(
				function(info) {
					self.onMouseDown(info);
				}
			);
			jQuery(document).mouseup(
				function(info) {
					self.onMouseUp(info);
				}
			);
		}
		if (!this.runtime.isiOS && this.runtime.isCordova && navigator["accelerometer"] && navigator["accelerometer"]["watchAcceleration"])
		{
			navigator["accelerometer"]["watchAcceleration"](PhoneGapGetAcceleration, null, { "frequency": 40 });
		}
		this.runtime.tick2Me(this);
	};
	instanceProto.onPointerMove = function (info)
	{
		if (info["pointerType"] === info["MSPOINTER_TYPE_MOUSE"] || info["pointerType"] === "mouse")
			return;
		if (info.preventDefault)
			info.preventDefault();
		var i = this.findTouch(info["pointerId"]);
		var nowtime = cr.performance_now();
		if (i >= 0)
		{
			var offset = this.runtime.isDomFree ? dummyoffset : jQuery(this.runtime.canvas).offset();
			var t = this.touches[i];
			if (nowtime - t.time < 2)
				return;
			t.update(nowtime, info.pageX - offset.left, info.pageY - offset.top, info.width || 0, info.height || 0, info.pressure || 0);
		}
	};
	instanceProto.onPointerStart = function (info)
	{
		if (info["pointerType"] === info["MSPOINTER_TYPE_MOUSE"] || info["pointerType"] === "mouse")
			return;
		if (info.preventDefault && cr.isCanvasInputEvent(info))
			info.preventDefault();
		var offset = this.runtime.isDomFree ? dummyoffset : jQuery(this.runtime.canvas).offset();
		var touchx = info.pageX - offset.left;
		var touchy = info.pageY - offset.top;
		var nowtime = cr.performance_now();
		this.trigger_index = this.touches.length;
		this.trigger_id = info["pointerId"];
		this.touches.push(AllocTouchInfo(touchx, touchy, info["pointerId"], this.trigger_index));
		this.runtime.isInUserInputEvent = true;
		this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnNthTouchStart, this);
		this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTouchStart, this);
		this.curTouchX = touchx;
		this.curTouchY = touchy;
		this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTouchObject, this);
		this.runtime.isInUserInputEvent = false;
	};
	instanceProto.onPointerEnd = function (info, isCancel)
	{
		if (info["pointerType"] === info["MSPOINTER_TYPE_MOUSE"] || info["pointerType"] === "mouse")
			return;
		if (info.preventDefault && cr.isCanvasInputEvent(info))
			info.preventDefault();
		var i = this.findTouch(info["pointerId"]);
		this.trigger_index = (i >= 0 ? this.touches[i].startindex : -1);
		this.trigger_id = (i >= 0 ? this.touches[i]["id"] : -1);
		this.runtime.isInUserInputEvent = true;
		this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnNthTouchEnd, this);
		this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTouchEnd, this);
		if (i >= 0)
		{
			if (!isCancel)
				this.touches[i].maybeTriggerTap(this, i);
			ReleaseTouchInfo(this.touches[i]);
			this.touches.splice(i, 1);
		}
		this.runtime.isInUserInputEvent = false;
	};
	instanceProto.onTouchMove = function (info)
	{
		if (info.preventDefault)
			info.preventDefault();
		var nowtime = cr.performance_now();
		var i, len, t, u;
		for (i = 0, len = info.changedTouches.length; i < len; i++)
		{
			t = info.changedTouches[i];
			var j = this.findTouch(t["identifier"]);
			if (j >= 0)
			{
				var offset = this.runtime.isDomFree ? dummyoffset : jQuery(this.runtime.canvas).offset();
				u = this.touches[j];
				if (nowtime - u.time < 2)
					continue;
				var touchWidth = (t.radiusX || t.webkitRadiusX || t.mozRadiusX || t.msRadiusX || 0) * 2;
				var touchHeight = (t.radiusY || t.webkitRadiusY || t.mozRadiusY || t.msRadiusY || 0) * 2;
				var touchForce = t.force || t.webkitForce || t.mozForce || t.msForce || 0;
				u.update(nowtime, t.pageX - offset.left, t.pageY - offset.top, touchWidth, touchHeight, touchForce);
			}
		}
	};
	instanceProto.onTouchStart = function (info)
	{
		if (info.preventDefault && cr.isCanvasInputEvent(info))
			info.preventDefault();
		var offset = this.runtime.isDomFree ? dummyoffset : jQuery(this.runtime.canvas).offset();
		var nowtime = cr.performance_now();
		this.runtime.isInUserInputEvent = true;
		var i, len, t, j;
		for (i = 0, len = info.changedTouches.length; i < len; i++)
		{
			t = info.changedTouches[i];
			j = this.findTouch(t["identifier"]);
			if (j !== -1)
				continue;
			var touchx = t.pageX - offset.left;
			var touchy = t.pageY - offset.top;
			this.trigger_index = this.touches.length;
			this.trigger_id = t["identifier"];
			this.touches.push(AllocTouchInfo(touchx, touchy, t["identifier"], this.trigger_index));
			this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnNthTouchStart, this);
			this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTouchStart, this);
			this.curTouchX = touchx;
			this.curTouchY = touchy;
			this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTouchObject, this);
		}
		this.runtime.isInUserInputEvent = false;
	};
	instanceProto.onTouchEnd = function (info, isCancel)
	{
		if (info.preventDefault && cr.isCanvasInputEvent(info))
			info.preventDefault();
		this.runtime.isInUserInputEvent = true;
		var i, len, t, j;
		for (i = 0, len = info.changedTouches.length; i < len; i++)
		{
			t = info.changedTouches[i];
			j = this.findTouch(t["identifier"]);
			if (j >= 0)
			{
				this.trigger_index = this.touches[j].startindex;
				this.trigger_id = this.touches[j]["id"];
				this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnNthTouchEnd, this);
				this.runtime.trigger(cr.plugins_.Touch.prototype.cnds.OnTouchEnd, this);
				if (!isCancel)
					this.touches[j].maybeTriggerTap(this, j);
				ReleaseTouchInfo(this.touches[j]);
				this.touches.splice(j, 1);
			}
		}
		this.runtime.isInUserInputEvent = false;
	};
	instanceProto.getAlpha = function ()
	{
		if (this.runtime.isCordova && this.orient_alpha === 0 && pg_accz !== 0)
			return pg_accz * 90;
		else
			return this.orient_alpha;
	};
	instanceProto.getBeta = function ()
	{
		if (this.runtime.isCordova && this.orient_beta === 0 && pg_accy !== 0)
			return pg_accy * 90;
		else
			return this.orient_beta;
	};
	instanceProto.getGamma = function ()
	{
		if (this.runtime.isCordova && this.orient_gamma === 0 && pg_accx !== 0)
			return pg_accx * 90;
		else
			return this.orient_gamma;
	};
	var noop_func = function(){};
	instanceProto.onMouseDown = function(info)
	{
		var t = { pageX: info.pageX, pageY: info.pageY, "identifier": 0 };
		var fakeinfo = { changedTouches: [t] };
		this.onTouchStart(fakeinfo);
		this.mouseDown = true;
	};
	instanceProto.onMouseMove = function(info)
	{
		if (!this.mouseDown)
			return;
		var t = { pageX: info.pageX, pageY: info.pageY, "identifier": 0 };
		var fakeinfo = { changedTouches: [t] };
		this.onTouchMove(fakeinfo);
	};
	instanceProto.onMouseUp = function(info)
	{
		if (info.preventDefault && this.runtime.had_a_click && !this.runtime.isMobile)
			info.preventDefault();
		this.runtime.had_a_click = true;
		var t = { pageX: info.pageX, pageY: info.pageY, "identifier": 0 };
		var fakeinfo = { changedTouches: [t] };
		this.onTouchEnd(fakeinfo);
		this.mouseDown = false;
	};
	instanceProto.tick2 = function()
	{
		var i, len, t;
		var nowtime = cr.performance_now();
		for (i = 0, len = this.touches.length; i < len; ++i)
		{
			t = this.touches[i];
			if (t.time <= nowtime - 50)
				t.lasttime = nowtime;
			t.maybeTriggerHold(this, i);
		}
	};
	function Cnds() {};
	Cnds.prototype.OnTouchStart = function ()
	{
		return true;
	};
	Cnds.prototype.OnTouchEnd = function ()
	{
		return true;
	};
	Cnds.prototype.IsInTouch = function ()
	{
		return this.touches.length;
	};
	Cnds.prototype.OnTouchObject = function (type)
	{
		if (!type)
			return false;
		return this.runtime.testAndSelectCanvasPointOverlap(type, this.curTouchX, this.curTouchY, false);
	};
	var touching = [];
	Cnds.prototype.IsTouchingObject = function (type)
	{
		if (!type)
			return false;
		var sol = type.getCurrentSol();
		var instances = sol.getObjects();
		var px, py;
		var i, leni, j, lenj;
		for (i = 0, leni = instances.length; i < leni; i++)
		{
			var inst = instances[i];
			inst.update_bbox();
			for (j = 0, lenj = this.touches.length; j < lenj; j++)
			{
				var touch = this.touches[j];
				px = inst.layer.canvasToLayer(touch.x, touch.y, true);
				py = inst.layer.canvasToLayer(touch.x, touch.y, false);
				if (inst.contains_pt(px, py))
				{
					touching.push(inst);
					break;
				}
			}
		}
		if (touching.length)
		{
			sol.select_all = false;
			cr.shallowAssignArray(sol.instances, touching);
			type.applySolToContainer();
			cr.clearArray(touching);
			return true;
		}
		else
			return false;
	};
	Cnds.prototype.CompareTouchSpeed = function (index, cmp, s)
	{
		index = Math.floor(index);
		if (index < 0 || index >= this.touches.length)
			return false;
		var t = this.touches[index];
		var dist = cr.distanceTo(t.x, t.y, t.lastx, t.lasty);
		var timediff = (t.time - t.lasttime) / 1000;
		var speed = 0;
		if (timediff > 0)
			speed = dist / timediff;
		return cr.do_cmp(speed, cmp, s);
	};
	Cnds.prototype.OrientationSupported = function ()
	{
		return typeof window["DeviceOrientationEvent"] !== "undefined";
	};
	Cnds.prototype.MotionSupported = function ()
	{
		return typeof window["DeviceMotionEvent"] !== "undefined";
	};
	Cnds.prototype.CompareOrientation = function (orientation_, cmp_, angle_)
	{
		var v = 0;
		if (orientation_ === 0)
			v = this.getAlpha();
		else if (orientation_ === 1)
			v = this.getBeta();
		else
			v = this.getGamma();
		return cr.do_cmp(v, cmp_, angle_);
	};
	Cnds.prototype.CompareAcceleration = function (acceleration_, cmp_, angle_)
	{
		var v = 0;
		if (acceleration_ === 0)
			v = this.acc_g_x;
		else if (acceleration_ === 1)
			v = this.acc_g_y;
		else if (acceleration_ === 2)
			v = this.acc_g_z;
		else if (acceleration_ === 3)
			v = this.acc_x;
		else if (acceleration_ === 4)
			v = this.acc_y;
		else if (acceleration_ === 5)
			v = this.acc_z;
		return cr.do_cmp(v, cmp_, angle_);
	};
	Cnds.prototype.OnNthTouchStart = function (touch_)
	{
		touch_ = Math.floor(touch_);
		return touch_ === this.trigger_index;
	};
	Cnds.prototype.OnNthTouchEnd = function (touch_)
	{
		touch_ = Math.floor(touch_);
		return touch_ === this.trigger_index;
	};
	Cnds.prototype.HasNthTouch = function (touch_)
	{
		touch_ = Math.floor(touch_);
		return this.touches.length >= touch_ + 1;
	};
	Cnds.prototype.OnHoldGesture = function ()
	{
		return true;
	};
	Cnds.prototype.OnTapGesture = function ()
	{
		return true;
	};
	Cnds.prototype.OnDoubleTapGesture = function ()
	{
		return true;
	};
	Cnds.prototype.OnHoldGestureObject = function (type)
	{
		if (!type)
			return false;
		return this.runtime.testAndSelectCanvasPointOverlap(type, this.curTouchX, this.curTouchY, false);
	};
	Cnds.prototype.OnTapGestureObject = function (type)
	{
		if (!type)
			return false;
		return this.runtime.testAndSelectCanvasPointOverlap(type, this.curTouchX, this.curTouchY, false);
	};
	Cnds.prototype.OnDoubleTapGestureObject = function (type)
	{
		if (!type)
			return false;
		return this.runtime.testAndSelectCanvasPointOverlap(type, this.curTouchX, this.curTouchY, false);
	};
	pluginProto.cnds = new Cnds();
	function Exps() {};
	Exps.prototype.TouchCount = function (ret)
	{
		ret.set_int(this.touches.length);
	};
	Exps.prototype.X = function (ret, layerparam)
	{
		var index = this.getTouchIndex;
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		var layer, oldScale, oldZoomRate, oldParallaxX, oldAngle;
		if (cr.is_undefined(layerparam))
		{
			layer = this.runtime.getLayerByNumber(0);
			oldScale = layer.scale;
			oldZoomRate = layer.zoomRate;
			oldParallaxX = layer.parallaxX;
			oldAngle = layer.angle;
			layer.scale = 1;
			layer.zoomRate = 1.0;
			layer.parallaxX = 1.0;
			layer.angle = 0;
			ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, true));
			layer.scale = oldScale;
			layer.zoomRate = oldZoomRate;
			layer.parallaxX = oldParallaxX;
			layer.angle = oldAngle;
		}
		else
		{
			if (cr.is_number(layerparam))
				layer = this.runtime.getLayerByNumber(layerparam);
			else
				layer = this.runtime.getLayerByName(layerparam);
			if (layer)
				ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, true));
			else
				ret.set_float(0);
		}
	};
	Exps.prototype.XAt = function (ret, index, layerparam)
	{
		index = Math.floor(index);
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		var layer, oldScale, oldZoomRate, oldParallaxX, oldAngle;
		if (cr.is_undefined(layerparam))
		{
			layer = this.runtime.getLayerByNumber(0);
			oldScale = layer.scale;
			oldZoomRate = layer.zoomRate;
			oldParallaxX = layer.parallaxX;
			oldAngle = layer.angle;
			layer.scale = 1;
			layer.zoomRate = 1.0;
			layer.parallaxX = 1.0;
			layer.angle = 0;
			ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, true));
			layer.scale = oldScale;
			layer.zoomRate = oldZoomRate;
			layer.parallaxX = oldParallaxX;
			layer.angle = oldAngle;
		}
		else
		{
			if (cr.is_number(layerparam))
				layer = this.runtime.getLayerByNumber(layerparam);
			else
				layer = this.runtime.getLayerByName(layerparam);
			if (layer)
				ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, true));
			else
				ret.set_float(0);
		}
	};
	Exps.prototype.XForID = function (ret, id, layerparam)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		var layer, oldScale, oldZoomRate, oldParallaxX, oldAngle;
		if (cr.is_undefined(layerparam))
		{
			layer = this.runtime.getLayerByNumber(0);
			oldScale = layer.scale;
			oldZoomRate = layer.zoomRate;
			oldParallaxX = layer.parallaxX;
			oldAngle = layer.angle;
			layer.scale = 1;
			layer.zoomRate = 1.0;
			layer.parallaxX = 1.0;
			layer.angle = 0;
			ret.set_float(layer.canvasToLayer(touch.x, touch.y, true));
			layer.scale = oldScale;
			layer.zoomRate = oldZoomRate;
			layer.parallaxX = oldParallaxX;
			layer.angle = oldAngle;
		}
		else
		{
			if (cr.is_number(layerparam))
				layer = this.runtime.getLayerByNumber(layerparam);
			else
				layer = this.runtime.getLayerByName(layerparam);
			if (layer)
				ret.set_float(layer.canvasToLayer(touch.x, touch.y, true));
			else
				ret.set_float(0);
		}
	};
	Exps.prototype.Y = function (ret, layerparam)
	{
		var index = this.getTouchIndex;
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		var layer, oldScale, oldZoomRate, oldParallaxY, oldAngle;
		if (cr.is_undefined(layerparam))
		{
			layer = this.runtime.getLayerByNumber(0);
			oldScale = layer.scale;
			oldZoomRate = layer.zoomRate;
			oldParallaxY = layer.parallaxY;
			oldAngle = layer.angle;
			layer.scale = 1;
			layer.zoomRate = 1.0;
			layer.parallaxY = 1.0;
			layer.angle = 0;
			ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, false));
			layer.scale = oldScale;
			layer.zoomRate = oldZoomRate;
			layer.parallaxY = oldParallaxY;
			layer.angle = oldAngle;
		}
		else
		{
			if (cr.is_number(layerparam))
				layer = this.runtime.getLayerByNumber(layerparam);
			else
				layer = this.runtime.getLayerByName(layerparam);
			if (layer)
				ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, false));
			else
				ret.set_float(0);
		}
	};
	Exps.prototype.YAt = function (ret, index, layerparam)
	{
		index = Math.floor(index);
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		var layer, oldScale, oldZoomRate, oldParallaxY, oldAngle;
		if (cr.is_undefined(layerparam))
		{
			layer = this.runtime.getLayerByNumber(0);
			oldScale = layer.scale;
			oldZoomRate = layer.zoomRate;
			oldParallaxY = layer.parallaxY;
			oldAngle = layer.angle;
			layer.scale = 1;
			layer.zoomRate = 1.0;
			layer.parallaxY = 1.0;
			layer.angle = 0;
			ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, false));
			layer.scale = oldScale;
			layer.zoomRate = oldZoomRate;
			layer.parallaxY = oldParallaxY;
			layer.angle = oldAngle;
		}
		else
		{
			if (cr.is_number(layerparam))
				layer = this.runtime.getLayerByNumber(layerparam);
			else
				layer = this.runtime.getLayerByName(layerparam);
			if (layer)
				ret.set_float(layer.canvasToLayer(this.touches[index].x, this.touches[index].y, false));
			else
				ret.set_float(0);
		}
	};
	Exps.prototype.YForID = function (ret, id, layerparam)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		var layer, oldScale, oldZoomRate, oldParallaxY, oldAngle;
		if (cr.is_undefined(layerparam))
		{
			layer = this.runtime.getLayerByNumber(0);
			oldScale = layer.scale;
			oldZoomRate = layer.zoomRate;
			oldParallaxY = layer.parallaxY;
			oldAngle = layer.angle;
			layer.scale = 1;
			layer.zoomRate = 1.0;
			layer.parallaxY = 1.0;
			layer.angle = 0;
			ret.set_float(layer.canvasToLayer(touch.x, touch.y, false));
			layer.scale = oldScale;
			layer.zoomRate = oldZoomRate;
			layer.parallaxY = oldParallaxY;
			layer.angle = oldAngle;
		}
		else
		{
			if (cr.is_number(layerparam))
				layer = this.runtime.getLayerByNumber(layerparam);
			else
				layer = this.runtime.getLayerByName(layerparam);
			if (layer)
				ret.set_float(layer.canvasToLayer(touch.x, touch.y, false));
			else
				ret.set_float(0);
		}
	};
	Exps.prototype.AbsoluteX = function (ret)
	{
		if (this.touches.length)
			ret.set_float(this.touches[0].x);
		else
			ret.set_float(0);
	};
	Exps.prototype.AbsoluteXAt = function (ret, index)
	{
		index = Math.floor(index);
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		ret.set_float(this.touches[index].x);
	};
	Exps.prototype.AbsoluteXForID = function (ret, id)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		ret.set_float(touch.x);
	};
	Exps.prototype.AbsoluteY = function (ret)
	{
		if (this.touches.length)
			ret.set_float(this.touches[0].y);
		else
			ret.set_float(0);
	};
	Exps.prototype.AbsoluteYAt = function (ret, index)
	{
		index = Math.floor(index);
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		ret.set_float(this.touches[index].y);
	};
	Exps.prototype.AbsoluteYForID = function (ret, id)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		ret.set_float(touch.y);
	};
	Exps.prototype.SpeedAt = function (ret, index)
	{
		index = Math.floor(index);
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		var t = this.touches[index];
		var dist = cr.distanceTo(t.x, t.y, t.lastx, t.lasty);
		var timediff = (t.time - t.lasttime) / 1000;
		if (timediff === 0)
			ret.set_float(0);
		else
			ret.set_float(dist / timediff);
	};
	Exps.prototype.SpeedForID = function (ret, id)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		var dist = cr.distanceTo(touch.x, touch.y, touch.lastx, touch.lasty);
		var timediff = (touch.time - touch.lasttime) / 1000;
		if (timediff === 0)
			ret.set_float(0);
		else
			ret.set_float(dist / timediff);
	};
	Exps.prototype.AngleAt = function (ret, index)
	{
		index = Math.floor(index);
		if (index < 0 || index >= this.touches.length)
		{
			ret.set_float(0);
			return;
		}
		var t = this.touches[index];
		ret.set_float(cr.to_degrees(cr.angleTo(t.lastx, t.lasty, t.x, t.y)));
	};
	Exps.prototype.AngleForID = function (ret, id)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		ret.set_float(cr.to_degrees(cr.angleTo(touch.lastx, touch.lasty, touch.x, touch.y)));
	};
	Exps.prototype.Alpha = function (ret)
	{
		ret.set_float(this.getAlpha());
	};
	Exps.prototype.Beta = function (ret)
	{
		ret.set_float(this.getBeta());
	};
	Exps.prototype.Gamma = function (ret)
	{
		ret.set_float(this.getGamma());
	};
	Exps.prototype.AccelerationXWithG = function (ret)
	{
		ret.set_float(this.acc_g_x);
	};
	Exps.prototype.AccelerationYWithG = function (ret)
	{
		ret.set_float(this.acc_g_y);
	};
	Exps.prototype.AccelerationZWithG = function (ret)
	{
		ret.set_float(this.acc_g_z);
	};
	Exps.prototype.AccelerationX = function (ret)
	{
		ret.set_float(this.acc_x);
	};
	Exps.prototype.AccelerationY = function (ret)
	{
		ret.set_float(this.acc_y);
	};
	Exps.prototype.AccelerationZ = function (ret)
	{
		ret.set_float(this.acc_z);
	};
	Exps.prototype.TouchIndex = function (ret)
	{
		ret.set_int(this.trigger_index);
	};
	Exps.prototype.TouchID = function (ret)
	{
		ret.set_float(this.trigger_id);
	};
	Exps.prototype.WidthForID = function (ret, id)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		ret.set_float(touch.width);
	};
	Exps.prototype.HeightForID = function (ret, id)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		ret.set_float(touch.height);
	};
	Exps.prototype.PressureForID = function (ret, id)
	{
		var index = this.findTouch(id);
		if (index < 0)
		{
			ret.set_float(0);
			return;
		}
		var touch = this.touches[index];
		ret.set_float(touch.pressure);
	};
	pluginProto.exps = new Exps();
}());
;
;
cr.behaviors.Bullet = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var behaviorProto = cr.behaviors.Bullet.prototype;
	behaviorProto.Type = function(behavior, objtype)
	{
		this.behavior = behavior;
		this.objtype = objtype;
		this.runtime = behavior.runtime;
	};
	var behtypeProto = behaviorProto.Type.prototype;
	behtypeProto.onCreate = function()
	{
	};
	behaviorProto.Instance = function(type, inst)
	{
		this.type = type;
		this.behavior = type.behavior;
		this.inst = inst;				// associated object instance to modify
		this.runtime = type.runtime;
	};
	var behinstProto = behaviorProto.Instance.prototype;
	behinstProto.onCreate = function()
	{
		var speed = this.properties[0];
		this.acc = this.properties[1];
		this.g = this.properties[2];
		this.bounceOffSolid = (this.properties[3] !== 0);
		this.setAngle = (this.properties[4] !== 0);
		this.dx = Math.cos(this.inst.angle) * speed;
		this.dy = Math.sin(this.inst.angle) * speed;
		this.lastx = this.inst.x;
		this.lasty = this.inst.y;
		this.lastKnownAngle = this.inst.angle;
		this.travelled = 0;
		this.enabled = (this.properties[5] !== 0);
	};
	behinstProto.saveToJSON = function ()
	{
		return {
			"acc": this.acc,
			"g": this.g,
			"dx": this.dx,
			"dy": this.dy,
			"lx": this.lastx,
			"ly": this.lasty,
			"lka": this.lastKnownAngle,
			"t": this.travelled,
			"e": this.enabled
		};
	};
	behinstProto.loadFromJSON = function (o)
	{
		this.acc = o["acc"];
		this.g = o["g"];
		this.dx = o["dx"];
		this.dy = o["dy"];
		this.lastx = o["lx"];
		this.lasty = o["ly"];
		this.lastKnownAngle = o["lka"];
		this.travelled = o["t"];
		this.enabled = o["e"];
	};
	behinstProto.tick = function ()
	{
		if (!this.enabled)
			return;
		var dt = this.runtime.getDt(this.inst);
		var s, a;
		var bounceSolid, bounceAngle;
		if (this.inst.angle !== this.lastKnownAngle)
		{
			if (this.setAngle)
			{
				s = cr.distanceTo(0, 0, this.dx, this.dy);
				this.dx = Math.cos(this.inst.angle) * s;
				this.dy = Math.sin(this.inst.angle) * s;
			}
			this.lastKnownAngle = this.inst.angle;
		}
		if (this.acc !== 0)
		{
			s = cr.distanceTo(0, 0, this.dx, this.dy);
			if (this.dx === 0 && this.dy === 0)
				a = this.inst.angle;
			else
				a = cr.angleTo(0, 0, this.dx, this.dy);
			s += this.acc * dt;
			if (s < 0)
				s = 0;
			this.dx = Math.cos(a) * s;
			this.dy = Math.sin(a) * s;
		}
		if (this.g !== 0)
			this.dy += this.g * dt;
		this.lastx = this.inst.x;
		this.lasty = this.inst.y;
		if (this.dx !== 0 || this.dy !== 0)
		{
			this.inst.x += this.dx * dt;
			this.inst.y += this.dy * dt;
			this.travelled += cr.distanceTo(0, 0, this.dx * dt, this.dy * dt)
			if (this.setAngle)
			{
				this.inst.angle = cr.angleTo(0, 0, this.dx, this.dy);
				this.inst.set_bbox_changed();
				this.lastKnownAngle = this.inst.angle;
			}
			this.inst.set_bbox_changed();
			if (this.bounceOffSolid)
			{
				bounceSolid = this.runtime.testOverlapSolid(this.inst);
				if (bounceSolid)
				{
					this.runtime.registerCollision(this.inst, bounceSolid);
					s = cr.distanceTo(0, 0, this.dx, this.dy);
					bounceAngle = this.runtime.calculateSolidBounceAngle(this.inst, this.lastx, this.lasty);
					this.dx = Math.cos(bounceAngle) * s;
					this.dy = Math.sin(bounceAngle) * s;
					this.inst.x += this.dx * dt;			// move out for one tick since the object can't have spent a tick in the solid
					this.inst.y += this.dy * dt;
					this.inst.set_bbox_changed();
					if (this.setAngle)
					{
						this.inst.angle = bounceAngle;
						this.lastKnownAngle = bounceAngle;
						this.inst.set_bbox_changed();
					}
					if (!this.runtime.pushOutSolid(this.inst, this.dx / s, this.dy / s, Math.max(s * 2.5 * dt, 30)))
						this.runtime.pushOutSolidNearest(this.inst, 100);
				}
			}
		}
	};
	function Cnds() {};
	Cnds.prototype.CompareSpeed = function (cmp, s)
	{
		return cr.do_cmp(cr.distanceTo(0, 0, this.dx, this.dy), cmp, s);
	};
	Cnds.prototype.CompareTravelled = function (cmp, d)
	{
		return cr.do_cmp(this.travelled, cmp, d);
	};
	behaviorProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.SetSpeed = function (s)
	{
		var a = cr.angleTo(0, 0, this.dx, this.dy);
		this.dx = Math.cos(a) * s;
		this.dy = Math.sin(a) * s;
	};
	Acts.prototype.SetAcceleration = function (a)
	{
		this.acc = a;
	};
	Acts.prototype.SetGravity = function (g)
	{
		this.g = g;
	};
	Acts.prototype.SetAngleOfMotion = function (a)
	{
		a = cr.to_radians(a);
		var s = cr.distanceTo(0, 0, this.dx, this.dy)
		this.dx = Math.cos(a) * s;
		this.dy = Math.sin(a) * s;
	};
	Acts.prototype.Bounce = function (objtype)
	{
		if (!objtype)
			return;
		var otherinst = objtype.getFirstPicked(this.inst);
		if (!otherinst)
			return;
		var dt = this.runtime.getDt(this.inst);
		var s = cr.distanceTo(0, 0, this.dx, this.dy);
		var bounceAngle = this.runtime.calculateSolidBounceAngle(this.inst, this.lastx, this.lasty, otherinst);
		this.dx = Math.cos(bounceAngle) * s;
		this.dy = Math.sin(bounceAngle) * s;
		this.inst.x += this.dx * dt;			// move out for one tick since the object can't have spent a tick in the solid
		this.inst.y += this.dy * dt;
		this.inst.set_bbox_changed();
		if (this.setAngle)
		{
			this.inst.angle = bounceAngle;
			this.lastKnownAngle = bounceAngle;
			this.inst.set_bbox_changed();
		}
		if (this.bounceOffSolid)
		{
			if (!this.runtime.pushOutSolid(this.inst, this.dx / s, this.dy / s, Math.max(s * 2.5 * dt, 30)))
				this.runtime.pushOutSolidNearest(this.inst, 100);
		}
		else if (s !== 0)
		{
			this.runtime.pushOut(this.inst, this.dx / s, this.dy / s, Math.max(s * 2.5 * dt, 30), otherinst)
		}
	};
	Acts.prototype.SetDistanceTravelled = function (d)
	{
		this.travelled = d;
	};
	Acts.prototype.SetEnabled = function (en)
	{
		this.enabled = (en === 1);
	};
	behaviorProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.Speed = function (ret)
	{
		var s = cr.distanceTo(0, 0, this.dx, this.dy);
		s = cr.round6dp(s);
		ret.set_float(s);
	};
	Exps.prototype.Acceleration = function (ret)
	{
		ret.set_float(this.acc);
	};
	Exps.prototype.AngleOfMotion = function (ret)
	{
		ret.set_float(cr.to_degrees(cr.angleTo(0, 0, this.dx, this.dy)));
	};
	Exps.prototype.DistanceTravelled = function (ret)
	{
		ret.set_float(this.travelled);
	};
	Exps.prototype.Gravity = function (ret)
	{
		ret.set_float(this.g);
	};
	behaviorProto.exps = new Exps();
}());
;
;
cr.behaviors.Fade = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var behaviorProto = cr.behaviors.Fade.prototype;
	behaviorProto.Type = function(behavior, objtype)
	{
		this.behavior = behavior;
		this.objtype = objtype;
		this.runtime = behavior.runtime;
	};
	var behtypeProto = behaviorProto.Type.prototype;
	behtypeProto.onCreate = function()
	{
	};
	behaviorProto.Instance = function(type, inst)
	{
		this.type = type;
		this.behavior = type.behavior;
		this.inst = inst;				// associated object instance to modify
		this.runtime = type.runtime;
	};
	var behinstProto = behaviorProto.Instance.prototype;
	behinstProto.onCreate = function()
	{
		this.activeAtStart = this.properties[0] === 1;
		this.setMaxOpacity = false;					// used to retrieve maxOpacity once in first 'Start fade' action if initially inactive
		this.fadeInTime = this.properties[1];
		this.waitTime = this.properties[2];
		this.fadeOutTime = this.properties[3];
		this.destroy = this.properties[4];			// 0 = no, 1 = after fade out
		this.stage = this.activeAtStart ? 0 : 3;		// 0 = fade in, 1 = wait, 2 = fade out, 3 = done
		if (this.recycled)
			this.stageTime.reset();
		else
			this.stageTime = new cr.KahanAdder();
		this.maxOpacity = (this.inst.opacity ? this.inst.opacity : 1.0);
		if (this.activeAtStart)
		{
			if (this.fadeInTime === 0)
			{
				this.stage = 1;
				if (this.waitTime === 0)
					this.stage = 2;
			}
			else
			{
				this.inst.opacity = 0;
				this.runtime.redraw = true;
			}
		}
	};
	behinstProto.saveToJSON = function ()
	{
		return {
			"fit": this.fadeInTime,
			"wt": this.waitTime,
			"fot": this.fadeOutTime,
			"s": this.stage,
			"st": this.stageTime.sum,
			"mo": this.maxOpacity,
		};
	};
	behinstProto.loadFromJSON = function (o)
	{
		this.fadeInTime = o["fit"];
		this.waitTime = o["wt"];
		this.fadeOutTime = o["fot"];
		this.stage = o["s"];
		this.stageTime.reset();
		this.stageTime.sum = o["st"];
		this.maxOpacity = o["mo"];
	};
	behinstProto.tick = function ()
	{
		this.stageTime.add(this.runtime.getDt(this.inst));
		if (this.stage === 0)
		{
			this.inst.opacity = (this.stageTime.sum / this.fadeInTime) * this.maxOpacity;
			this.runtime.redraw = true;
			if (this.inst.opacity >= this.maxOpacity)
			{
				this.inst.opacity = this.maxOpacity;
				this.stage = 1;	// wait stage
				this.stageTime.reset();
				this.runtime.trigger(cr.behaviors.Fade.prototype.cnds.OnFadeInEnd, this.inst);
			}
		}
		if (this.stage === 1)
		{
			if (this.stageTime.sum >= this.waitTime)
			{
				this.stage = 2;	// fade out stage
				this.stageTime.reset();
				this.runtime.trigger(cr.behaviors.Fade.prototype.cnds.OnWaitEnd, this.inst);
			}
		}
		if (this.stage === 2)
		{
			if (this.fadeOutTime !== 0)
			{
				this.inst.opacity = this.maxOpacity - ((this.stageTime.sum / this.fadeOutTime) * this.maxOpacity);
				this.runtime.redraw = true;
				if (this.inst.opacity < 0)
				{
					this.inst.opacity = 0;
					this.stage = 3;	// done
					this.stageTime.reset();
					this.runtime.trigger(cr.behaviors.Fade.prototype.cnds.OnFadeOutEnd, this.inst);
					if (this.destroy === 1)
						this.runtime.DestroyInstance(this.inst);
				}
			}
		}
	};
	behinstProto.doStart = function ()
	{
		this.stage = 0;
		this.stageTime.reset();
		if (this.fadeInTime === 0)
		{
			this.stage = 1;
			if (this.waitTime === 0)
				this.stage = 2;
		}
		else
		{
			this.inst.opacity = 0;
			this.runtime.redraw = true;
		}
	};
	function Cnds() {};
	Cnds.prototype.OnFadeOutEnd = function ()
	{
		return true;
	};
	Cnds.prototype.OnFadeInEnd = function ()
	{
		return true;
	};
	Cnds.prototype.OnWaitEnd = function ()
	{
		return true;
	};
	behaviorProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.StartFade = function ()
	{
		if (!this.activeAtStart && !this.setMaxOpacity)
		{
			this.maxOpacity = (this.inst.opacity ? this.inst.opacity : 1.0);
			this.setMaxOpacity = true;
		}
		if (this.stage === 3)
			this.doStart();
	};
	Acts.prototype.RestartFade = function ()
	{
		this.doStart();
	};
	Acts.prototype.SetFadeInTime = function (t)
	{
		if (t < 0)
			t = 0;
		this.fadeInTime = t;
	};
	Acts.prototype.SetWaitTime = function (t)
	{
		if (t < 0)
			t = 0;
		this.waitTime = t;
	};
	Acts.prototype.SetFadeOutTime = function (t)
	{
		if (t < 0)
			t = 0;
		this.fadeOutTime = t;
	};
	behaviorProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.FadeInTime = function (ret)
	{
		ret.set_float(this.fadeInTime);
	};
	Exps.prototype.WaitTime = function (ret)
	{
		ret.set_float(this.waitTime);
	};
	Exps.prototype.FadeOutTime = function (ret)
	{
		ret.set_float(this.fadeOutTime);
	};
	behaviorProto.exps = new Exps();
}());
;
;
cr.behaviors.Flash = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var behaviorProto = cr.behaviors.Flash.prototype;
	behaviorProto.Type = function(behavior, objtype)
	{
		this.behavior = behavior;
		this.objtype = objtype;
		this.runtime = behavior.runtime;
	};
	var behtypeProto = behaviorProto.Type.prototype;
	behtypeProto.onCreate = function()
	{
	};
	behaviorProto.Instance = function(type, inst)
	{
		this.type = type;
		this.behavior = type.behavior;
		this.inst = inst;				// associated object instance to modify
		this.runtime = type.runtime;
	};
	var behinstProto = behaviorProto.Instance.prototype;
	behinstProto.onCreate = function()
	{
		this.ontime = 0;
		this.offtime = 0;
		this.stage = 0;			// 0 = on, 1 = off
		this.stagetimeleft = 0;
		this.timeleft = 0;
	};
	behinstProto.saveToJSON = function ()
	{
		return {
			"ontime": this.ontime,
			"offtime": this.offtime,
			"stage": this.stage,
			"stagetimeleft": this.stagetimeleft,
			"timeleft": this.timeleft
		};
	};
	behinstProto.loadFromJSON = function (o)
	{
		this.ontime = o["ontime"];
		this.offtime = o["offtime"];
		this.stage = o["stage"];
		this.stagetimeleft = o["stagetimeleft"];
		this.timeleft = o["timeleft"];
	};
	behinstProto.tick = function ()
	{
		if (this.timeleft <= 0)
			return;		// not flashing
		var dt = this.runtime.getDt(this.inst);
		this.timeleft -= dt;
		if (this.timeleft <= 0)
		{
			this.timeleft = 0;
			this.inst.visible = true;
			this.runtime.redraw = true;
			this.runtime.trigger(cr.behaviors.Flash.prototype.cnds.OnFlashEnded, this.inst);
			return;
		}
		this.stagetimeleft -= dt;
		if (this.stagetimeleft <= 0)
		{
			if (this.stage === 0)
			{
				this.inst.visible = false;
				this.stage = 1;
				this.stagetimeleft += this.offtime;
			}
			else
			{
				this.inst.visible = true;
				this.stage = 0;
				this.stagetimeleft += this.ontime;
			}
			this.runtime.redraw = true;
		}
	};
	function Cnds() {};
	Cnds.prototype.IsFlashing = function ()
	{
		return this.timeleft > 0;
	};
	Cnds.prototype.OnFlashEnded = function ()
	{
		return true;
	};
	behaviorProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.Flash = function (on_, off_, dur_)
	{
		this.ontime = on_;
		this.offtime = off_;
		this.stage = 1;		// always start off
		this.stagetimeleft = off_;
		this.timeleft = dur_;
		this.inst.visible = false;
		this.runtime.redraw = true;
	};
	Acts.prototype.StopFlashing = function ()
	{
		this.timeleft = 0;
		this.inst.visible = true;
		this.runtime.redraw = true;
		return;
	};
	behaviorProto.acts = new Acts();
	function Exps() {};
	behaviorProto.exps = new Exps();
}());
;
;
cr.behaviors.Pin = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var behaviorProto = cr.behaviors.Pin.prototype;
	behaviorProto.Type = function(behavior, objtype)
	{
		this.behavior = behavior;
		this.objtype = objtype;
		this.runtime = behavior.runtime;
	};
	var behtypeProto = behaviorProto.Type.prototype;
	behtypeProto.onCreate = function()
	{
	};
	behaviorProto.Instance = function(type, inst)
	{
		this.type = type;
		this.behavior = type.behavior;
		this.inst = inst;				// associated object instance to modify
		this.runtime = type.runtime;
	};
	var behinstProto = behaviorProto.Instance.prototype;
	behinstProto.onCreate = function()
	{
		this.pinObject = null;
		this.pinObjectUid = -1;		// for loading
		this.pinAngle = 0;
		this.pinDist = 0;
		this.myStartAngle = 0;
		this.theirStartAngle = 0;
		this.lastKnownAngle = 0;
		this.mode = 0;				// 0 = position & angle; 1 = position; 2 = angle; 3 = rope; 4 = bar
		var self = this;
		if (!this.recycled)
		{
			this.myDestroyCallback = (function(inst) {
													self.onInstanceDestroyed(inst);
												});
		}
		this.runtime.addDestroyCallback(this.myDestroyCallback);
	};
	behinstProto.saveToJSON = function ()
	{
		return {
			"uid": this.pinObject ? this.pinObject.uid : -1,
			"pa": this.pinAngle,
			"pd": this.pinDist,
			"msa": this.myStartAngle,
			"tsa": this.theirStartAngle,
			"lka": this.lastKnownAngle,
			"m": this.mode
		};
	};
	behinstProto.loadFromJSON = function (o)
	{
		this.pinObjectUid = o["uid"];		// wait until afterLoad to look up
		this.pinAngle = o["pa"];
		this.pinDist = o["pd"];
		this.myStartAngle = o["msa"];
		this.theirStartAngle = o["tsa"];
		this.lastKnownAngle = o["lka"];
		this.mode = o["m"];
	};
	behinstProto.afterLoad = function ()
	{
		if (this.pinObjectUid === -1)
			this.pinObject = null;
		else
		{
			this.pinObject = this.runtime.getObjectByUID(this.pinObjectUid);
;
		}
		this.pinObjectUid = -1;
	};
	behinstProto.onInstanceDestroyed = function (inst)
	{
		if (this.pinObject == inst)
			this.pinObject = null;
	};
	behinstProto.onDestroy = function()
	{
		this.pinObject = null;
		this.runtime.removeDestroyCallback(this.myDestroyCallback);
	};
	behinstProto.tick = function ()
	{
	};
	behinstProto.tick2 = function ()
	{
		if (!this.pinObject)
			return;
		if (this.lastKnownAngle !== this.inst.angle)
			this.myStartAngle = cr.clamp_angle(this.myStartAngle + (this.inst.angle - this.lastKnownAngle));
		var newx = this.inst.x;
		var newy = this.inst.y;
		if (this.mode === 3 || this.mode === 4)		// rope mode or bar mode
		{
			var dist = cr.distanceTo(this.inst.x, this.inst.y, this.pinObject.x, this.pinObject.y);
			if ((dist > this.pinDist) || (this.mode === 4 && dist < this.pinDist))
			{
				var a = cr.angleTo(this.pinObject.x, this.pinObject.y, this.inst.x, this.inst.y);
				newx = this.pinObject.x + Math.cos(a) * this.pinDist;
				newy = this.pinObject.y + Math.sin(a) * this.pinDist;
			}
		}
		else
		{
			newx = this.pinObject.x + Math.cos(this.pinObject.angle + this.pinAngle) * this.pinDist;
			newy = this.pinObject.y + Math.sin(this.pinObject.angle + this.pinAngle) * this.pinDist;
		}
		var newangle = cr.clamp_angle(this.myStartAngle + (this.pinObject.angle - this.theirStartAngle));
		this.lastKnownAngle = newangle;
		if ((this.mode === 0 || this.mode === 1 || this.mode === 3 || this.mode === 4)
			&& (this.inst.x !== newx || this.inst.y !== newy))
		{
			this.inst.x = newx;
			this.inst.y = newy;
			this.inst.set_bbox_changed();
		}
		if ((this.mode === 0 || this.mode === 2) && (this.inst.angle !== newangle))
		{
			this.inst.angle = newangle;
			this.inst.set_bbox_changed();
		}
	};
	function Cnds() {};
	Cnds.prototype.IsPinned = function ()
	{
		return !!this.pinObject;
	};
	behaviorProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.Pin = function (obj, mode_)
	{
		if (!obj)
			return;
		var otherinst = obj.getFirstPicked(this.inst);
		if (!otherinst)
			return;
		this.pinObject = otherinst;
		this.pinAngle = cr.angleTo(otherinst.x, otherinst.y, this.inst.x, this.inst.y) - otherinst.angle;
		this.pinDist = cr.distanceTo(otherinst.x, otherinst.y, this.inst.x, this.inst.y);
		this.myStartAngle = this.inst.angle;
		this.lastKnownAngle = this.inst.angle;
		this.theirStartAngle = otherinst.angle;
		this.mode = mode_;
	};
	Acts.prototype.Unpin = function ()
	{
		this.pinObject = null;
	};
	behaviorProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.PinnedUID = function (ret)
	{
		ret.set_int(this.pinObject ? this.pinObject.uid : -1);
	};
	behaviorProto.exps = new Exps();
}());
;
;
cr.behaviors.Rotate = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var behaviorProto = cr.behaviors.Rotate.prototype;
	behaviorProto.Type = function(behavior, objtype)
	{
		this.behavior = behavior;
		this.objtype = objtype;
		this.runtime = behavior.runtime;
	};
	var behtypeProto = behaviorProto.Type.prototype;
	behtypeProto.onCreate = function()
	{
	};
	behaviorProto.Instance = function(type, inst)
	{
		this.type = type;
		this.behavior = type.behavior;
		this.inst = inst;				// associated object instance to modify
		this.runtime = type.runtime;
	};
	var behinstProto = behaviorProto.Instance.prototype;
	behinstProto.onCreate = function()
	{
		this.speed = cr.to_radians(this.properties[0]);
		this.acc = cr.to_radians(this.properties[1]);
	};
	behinstProto.saveToJSON = function ()
	{
		return {
			"speed": this.speed,
			"acc": this.acc
		};
	};
	behinstProto.loadFromJSON = function (o)
	{
		this.speed = o["speed"];
		this.acc = o["acc"];
	};
	behinstProto.tick = function ()
	{
		var dt = this.runtime.getDt(this.inst);
		if (dt === 0)
			return;
		if (this.acc !== 0)
			this.speed += this.acc * dt;
		if (this.speed !== 0)
		{
			this.inst.angle = cr.clamp_angle(this.inst.angle + this.speed * dt);
			this.inst.set_bbox_changed();
		}
	};
	function Cnds() {};
	behaviorProto.cnds = new Cnds();
	function Acts() {};
	Acts.prototype.SetSpeed = function (s)
	{
		this.speed = cr.to_radians(s);
	};
	Acts.prototype.SetAcceleration = function (a)
	{
		this.acc = cr.to_radians(a);
	};
	behaviorProto.acts = new Acts();
	function Exps() {};
	Exps.prototype.Speed = function (ret)
	{
		ret.set_float(cr.to_degrees(this.speed));
	};
	Exps.prototype.Acceleration = function (ret)
	{
		ret.set_float(cr.to_degrees(this.acc));
	};
	behaviorProto.exps = new Exps();
}());
;
;
function trim (str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
cr.behaviors.rex_lunarray_Tween_mod = function(runtime)
{
	this.runtime = runtime;
};
(function ()
{
	var behaviorProto = cr.behaviors.rex_lunarray_Tween_mod.prototype;
	behaviorProto.Type = function(behavior, objtype)
	{
		this.behavior = behavior;
		this.objtype = objtype;
		this.runtime = behavior.runtime;
	};
	var behtypeProto = behaviorProto.Type.prototype;
	behtypeProto.onCreate = function()
	{
	};
	behaviorProto.Instance = function(type, inst)
	{
		this.type = type;
		this.behavior = type.behavior;
		this.inst = inst;				// associated object instance to modify
		this.runtime = type.runtime;
		this.i = 0;		// progress
	};
	var behinstProto = behaviorProto.Instance.prototype;
	behinstProto.groupUpdateProgress = function(v)
	{
		if (v > 1) v = 1;
		if (cr.lunarray_tweenProgress[this.group] = -1) cr.lunarray_tweenProgress[this.group] = v;
		if (cr.lunarray_tweenProgress[this.group] >= v) cr.lunarray_tweenProgress[this.group] = v;
	}
	behinstProto.groupSync = function()
	{
		if (this.group != "") {
			if (typeof cr.lunarray_tweenGroup === "undefined") {
				cr.lunarray_tweenGroup = {};
				cr.lunarray_tweenProgress = {};
			}
			if (typeof cr.lunarray_tweenGroup[this.group] === "undefined") {
				cr.lunarray_tweenGroup[this.group] = [];
				cr.lunarray_tweenProgress[this.group] = -1;
			}
			if (cr.lunarray_tweenGroup[this.group].indexOf(this) == -1) {
				cr.lunarray_tweenGroup[this.group].push(this);
			}
		}
	}
	behinstProto.saveState = function()
	{
		this.tweenSaveWidth = this.inst.width;
		this.tweenSaveHeight = this.inst.height;
		this.tweenSaveAngle = this.inst.angle;
		this.tweenSaveOpacity = this.inst.opacity;
		this.tweenSaveX = this.inst.x;
		this.tweenSaveY = this.inst.y;
		this.tweenSaveValue = this.value;
	}
	behinstProto.onCreate = function()
	{
		this.active = (this.properties[0] === 1);
		this.tweened = this.properties[1]; // 0=Position|1=Size|2=Width|3=Height|4=Angle|5=Opacity|6=Value only|7=Pixel Size
		this.easing = this.properties[2];
		this.initial = this.properties[3];
		this.target = this.properties[4];
		this.duration = this.properties[5];
		this.wait = this.properties[6];
		this.playmode = this.properties[7]; //0=Play Once|1=Repeat|2=Ping Pong|3=Play once and destroy|4=Loop|5=Ping Pong Stop|6=Play and stop
		this.value = this.properties[8];
		this.coord_mode = this.properties[9]; //0=Absolute|1=Relative
		this.forceInit = (this.properties[10] === 1);
		this.group = this.properties[11];
		this.repeatcount_save = this.properties[12];
		if (this.repeatcount_save <= 0)
		    this.repeatcount_save = -1;
		this.repeatcount = this.repeatcount_save;
		this.targetObject = null;
		this.pingpongCounter = 0;
		if (this.playmode == 5) this.pingpongCounter = 1;
		this.groupSync();
		this.isPaused = false;
		this.initialX = this.inst.x;
		this.initialY = this.inst.y;
		this.targetX = parseFloat(this.target.split(",")[0]);
		this.targetY = parseFloat(this.target.split(",")[1]);
		this.saveState();
		this.tweenInitialX = 0;
		this.tweenInitialY = 0;
		this.tweenTargetX = 0;
		this.tweenTargetY = 0;
		this.tweenTargetAngle = 0;
		this.ratio = this.inst.height / this.inst.width;
		this.reverse = false;
		this.rewindMode = false;
		this.doTweenX = true;
		this.doTweenY = true;
		this.loop = false;
		this.initiating = 0;
		this.cooldown = 0;
		this.lastPlayMode = this.playmode;
		this.lastKnownValue = this.tweenInitialX;
		this.lastKnownX = this.tweenInitialX;
		this.lastKnownY = this.tweenInitialY;
		if (this.forceInit) this.init();
		if (this.initial == "") this.initial = "current";
		this.onStarted = false;
		this.onStartedDone = false;
		this.onWaitEnd = false;
		this.onWaitEndDone = false;
		this.onEnd = false;
		this.onEndDone = false;
		this.onCooldown = false;
		this.onCooldownDone = false;
		this.onCountEnd = false;
		if (this.active) {
			this.init();
		}
	};
	behinstProto.init = function ()
	{
		this.onStarted = false;
		if (this.initial === "") this.initial = "current";
		if (this.target === "") this.target = "current";
		var isCurrent = (this.initial === "current");
		var targetIsCurrent = (this.target === "current");
		var isTargettingObject = (this.target === "OBJ");
		if (this.target === "OBJ") {
			if (this.targetObject != null) {
				if (this.tweened == 0) {
					if (this.coord_mode == 1) //relative mode
						this.target = (this.targetObject.x-this.inst.x) + "," + (this.targetObject.y-this.inst.y);
					else //absolute mode
						this.target = (this.targetObject.x) + "," + (this.targetObject.y);
				} else if ((this.tweened == 1) || (this.tweened == 2) || (this.tweened == 3) || (this.tweened == 7)) {
					if (this.coord_mode == 1) { //relative mode
						this.target = ((this.tweened==2)?1:(this.targetObject.width)) + "," + ((this.tweened==3)?1:(this.targetObject.height));
					} else {
						this.target = ((this.tweened==2)?1:(this.targetObject.width/this.tweenSaveWidth)) + "," + ((this.tweened==3)?1:(this.targetObject.height/this.tweenSaveHeight));
					}
				} else if (this.tweened == 4) {
					if (this.coord_mode == 1) //relative mode
						this.target = cr.to_degrees(this.targetObject.angle-this.inst.angle) + "";
					else //absolute mode
						this.target = cr.to_degrees(this.targetObject.angle) + "";
				} else if (this.tweened == 5) {
					if (this.coord_mode == 1) //relative mode
						this.target = ((this.targetObject.opacity-this.inst.opacity)*100) + "";
					else //absolute mode
						this.target = (this.targetObject.opacity*100) + "";
				}
			}
		}
		if (this.tweened == 0) {
			if (targetIsCurrent) this.target = this.inst.x + "," + this.inst.y;
			if (!isCurrent) {
				if (!this.reverse) {
					if (this.playmode != 1) {
						this.inst.x = parseFloat(this.initial.split(",")[0]);
						this.inst.y = parseFloat(this.initial.split(",")[1]);
					}
				}
			} else {
				if (this.coord_mode == 1) {
					this.initial = this.inst.x + "," + this.inst.y;
				} else {
					this.initial = this.tweenSaveX + "," + this.tweenSaveY;
				}
			}
			if (this.coord_mode == 1) {
				if (this.loop) {
					this.inst.x = this.tweenSaveX;
					this.inst.y = this.tweenSaveY;
				}
				this.initialX = this.inst.x;
				this.initialY = this.inst.y;
				if (!this.reverse) {
					this.targetX = parseFloat(this.target.split(",")[0]);
					this.targetY = parseFloat(this.target.split(",")[1]);
				} else {
					this.targetX = -parseFloat(this.target.split(",")[0]);
					this.targetY = -parseFloat(this.target.split(",")[1]);
				}
				this.tweenInitialX = this.initialX;
				this.tweenInitialY = this.initialY;
				this.tweenTargetX = this.tweenInitialX + this.targetX;
				this.tweenTargetY = this.tweenInitialY + this.targetY;
			} else {
				if (!this.reverse) {
					this.inst.x = this.tweenSaveX;
					this.inst.y = this.tweenSaveY;
					this.targetX = parseFloat(this.target.split(",")[0]);
					this.targetY = parseFloat(this.target.split(",")[1]);
				} else {
					this.inst.x = parseFloat(this.target.split(",")[0]);
					this.inst.y = parseFloat(this.target.split(",")[1]);
					this.targetX = this.tweenSaveX;
					this.targetY = this.tweenSaveY;
				}
				this.initialX = this.inst.x;
				this.initialY = this.inst.y;
				this.tweenInitialX = this.initialX;
				this.tweenInitialY = this.initialY;
				this.tweenTargetX = this.targetX;
				this.tweenTargetY = this.targetY;
				if (this.playmode == -6) {
					this.tweenTargetX = this.tweenSaveX;
					this.tweenTargetY = this.tweenSaveY;
				}
			}
		} else if ((this.tweened == 1) || (this.tweened == 2) || (this.tweened == 3)) {
			if (targetIsCurrent) this.target = "1,1";
			if (this.initial == "current") this.initial = "1,1";
			this.initial = "" + this.initial;
			this.target = "" + this.target;
			if (this.tweened == 2) {
				if (this.initial.indexOf(',') == -1) this.initial = parseFloat(this.initial) + ",1";
				if (this.target.indexOf(',') == -1) this.target = parseFloat(this.target) + ",1";
			} else if (this.tweened == 3) {
				if (this.initial.indexOf(',') == -1) this.initial = "1," + parseFloat(this.initial);
				if (this.target.indexOf(',') == -1) this.target = "1," + parseFloat(this.target);
			} else {
				if (this.initial.indexOf(',') == -1) this.initial = parseFloat(this.initial) + "," + parseFloat(this.initial);
				if (this.target.indexOf(',') == -1) this.target = parseFloat(this.target) + "," + parseFloat(this.target);
			}
			var ix = parseFloat(this.initial.split(",")[0]);
			var iy = parseFloat(this.initial.split(",")[1]);
			this.doTweenX = true;
			var tx = parseFloat(this.target.split(",")[0]);
			if ((tx == 0) || (isNaN(tx)))	this.doTweenX = false;
			if (this.tweened == 3) this.doTweenX = false;
			this.doTweenY = true;
			var ty = parseFloat(this.target.split(",")[1]);
			if ((ty == 0) || (isNaN(ty)))	this.doTweenY = false;
			if (this.tweened == 2) this.doTweenY = false;
			if (this.coord_mode == 1) {
				if (this.loop) {
					this.inst.width = this.tweenSaveWidth;
					this.inst.height = this.tweenSaveHeight;
				}
				if (!isCurrent) {
					if (!this.reverse) {
						this.inst.width = this.inst.width * ix;
						this.inst.height = this.inst.height * iy;
					} else {
						this.inst.width = this.inst.width * tx;
						this.inst.height = this.inst.height * ty;
					}
				}
				this.initialX = this.inst.width;
				this.initialY = this.inst.height;
				this.tweenInitialX = this.initialX;
				this.tweenInitialY = this.initialY;
				if (!this.reverse) {
					this.targetX = this.initialX * tx;
					this.targetY = this.initialY * ty;
				} else {
					this.targetX = this.initialX * ix/tx;
					this.targetY = this.initialY * iy/ty;
				}
				this.tweenTargetX = this.targetX;
				this.tweenTargetY = this.targetY;
			} else {
				if (!isCurrent) {
					if (!this.reverse) {
						this.inst.width = this.tweenSaveWidth * ix;
						this.inst.height = this.tweenSaveHeight * iy;
					} else {
						this.inst.width = this.tweenSaveWidth * tx;
						this.inst.height = this.tweenSaveHeight * ty;
					}
				}
				this.initialX = this.inst.width;
				this.initialY = this.inst.height;
				this.tweenInitialX = this.initialX;
				this.tweenInitialY = this.initialY;
				if (!this.reverse) {
					this.targetX = this.tweenSaveWidth * tx;
					this.targetY = this.tweenSaveHeight * ty;
				} else {
					this.targetX = this.tweenSaveWidth * ix;
					this.targetY = this.tweenSaveHeight * iy;
				}
				this.tweenTargetX = this.targetX;
				this.tweenTargetY = this.targetY;
			}
			if (this.playmode == -6) {
				this.tweenTargetX = this.tweenSaveWidth * ix;
				this.tweenTargetY = this.tweenSaveHeight * iy;
			}
		} else if (this.tweened == 4) {
			if (targetIsCurrent) this.target = cr.to_degrees(this.inst.angle);
			if (this.initial != "current") {
				if (!this.reverse) {
					if (this.playmode != 1) { //if repeat, don't initialize
						this.inst.angle = cr.to_radians(parseFloat(this.initial.split(",")[0]));
					}
				}
			}
			if (this.coord_mode == 1) {
				if (this.loop) {
					this.inst.angle = this.tweenSaveAngle;
				}
				this.initialX = this.inst.angle;
				if (this.reverse) {
					this.targetX = this.inst.angle - cr.to_radians(parseFloat(this.target.split(",")[0]));
				} else {
					this.targetX = this.inst.angle + cr.to_radians(parseFloat(this.target.split(",")[0]));
				}
				this.tweenInitialX = this.initialX;
				this.tweenTargetX = cr.to_degrees(this.targetX);
			} else {
				if (this.reverse) {
					this.inst.angle = cr.to_radians(parseFloat(this.target.split(",")[0]));;
					this.initialX = this.inst.angle;
					this.targetX = this.tweenSaveAngle;
					this.tweenInitialX = this.initialX;
					this.tweenTargetX = cr.to_degrees(this.targetX);
				} else {
					this.inst.angle = this.tweenSaveAngle;
					this.initialX = this.inst.angle;
					this.targetX = cr.to_radians(parseFloat(this.target.split(",")[0]));
					this.tweenInitialX = this.initialX;
					this.tweenTargetX = cr.to_degrees(this.targetX);
				}
			}
			if (this.playmode == -6) {
				this.tweenTargetX = cr.to_degrees(this.tweenSaveAngle);
			}
			this.tweenTargetAngle = cr.to_radians(this.tweenTargetX);
		} else if (this.tweened == 5) {
			if (this.initial == "current") this.initial = this.inst.opacity;
			if (targetIsCurrent) this.target = ""+this.inst.opacity;
			if (!isCurrent) {
				if (!this.reverse) {
					if (this.playmode != 1) { //if repeat, don't initialize
						this.inst.opacity = parseFloat(this.initial.split(",")[0]) / 100;
					}
				}
			}
			if (this.coord_mode == 1) {
				if (this.loop) {
					this.inst.opacity = this.tweenSaveOpacity;
				}
				this.initialX = this.inst.opacity;
				this.tweenInitialX = this.initialX;
				if (!this.reverse) {
					this.targetX = parseFloat(this.target.split(",")[0]) / 100;
				} else {
					this.targetX = -parseFloat(this.target.split(",")[0]) / 100;
				}
				this.tweenTargetX = this.tweenInitialX + this.targetX;
			} else {
				this.initialX = this.inst.opacity;
				if (!this.reverse) {
					this.tweenInitialX = this.initialX;
					this.targetX = parseFloat(this.target.split(",")[0]) / 100;
				} else {
					this.tweenInitialX = parseFloat(this.target.split(",")[0]) / 100;
					this.targetX = parseFloat(this.initial.split(",")[0]) / 100;
				}
				this.tweenTargetX = this.targetX;
			}
			if (this.playmode == -6) {
				this.tweenTargetX = this.tweenSaveOpacity;
			}
		} else if (this.tweened == 6) {
			if (isNaN(this.value)) this.value = 0;
			if (this.initial == "current") this.initial = ""+this.value;
			if (targetIsCurrent) this.target = ""+this.value;
			if (!isCurrent) {
				if (!this.reverse) {
					if (this.playmode != 1) { //if repeat, don't initialize
						this.value = parseFloat(this.initial.split(",")[0]);
					}
				}
			}
			if (this.coord_mode == 1) {
				if (this.loop) {
					this.value = this.tweenSaveValue;
				}
				if (!isCurrent) {
					if (!this.reverse) {
						this.value = parseFloat(this.initial.split(",")[0]);
					} else {
						this.value = parseFloat(this.target.split(",")[0]);
					}
				}
				this.initialX = this.value;
				if (!this.reverse) {
					this.targetX = this.initialX + parseFloat(this.target.split(",")[0]);
				} else {
					this.targetX = this.initialX - parseFloat(this.target.split(",")[0]);
				}
				this.tweenInitialX = this.initialX;
				this.tweenTargetX = this.targetX;
			} else {
				if (!isCurrent) {
					if (!this.reverse) {
						this.value = parseFloat(this.initial.split(",")[0]);
					} else {
						this.value = parseFloat(this.target.split(",")[0]);
					}
				}
				this.initialX = this.value;
				if (!this.reverse) {
					this.targetX = parseFloat(this.target.split(",")[0]);
				} else {
					this.targetX = parseFloat(this.initial.split(",")[0]);
				}
				this.tweenInitialX = this.initialX;
				this.tweenTargetX = this.targetX;
			}
			if (this.playmode == -6) {
				this.tweenTargetX = this.tweenSaveValue;
			}
		} else if (this.tweened == 7) {
			if (targetIsCurrent) this.target = this.inst.width + "," + this.inst.height;
			if (this.initial != "current") {
				if (!this.reverse) {
					if (this.playmode != 1) { //if repeat, don't initialize
						this.inst.width = parseFloat(this.initial.split(",")[0]);
						this.inst.height = parseFloat(this.initial.split(",")[1]);
					}
				}
			}
			this.doTweenX = true;
			var tx = parseFloat(this.target.split(",")[0]);
			if ((tx < 0) || (isNaN(tx)))	this.doTweenX = false;
			this.doTweenY = true;
			var ty = parseFloat(this.target.split(",")[1]);
			if ((ty < 0) || (isNaN(ty)))	this.doTweenY = false;
			if (this.coord_mode == 1) {
				if (this.loop) {
					this.inst.width = this.tweenSaveWidth;
					this.inst.height = this.tweenSaveHeight;
				}
				this.initialX = this.inst.width;
				this.initialY = this.inst.height;
				if (!this.reverse) {
					this.targetX = this.initialX + parseFloat(this.target.split(",")[0]);
					this.targetY = this.initialY + parseFloat(this.target.split(",")[1]);
				} else {
					this.targetX = this.initialX - parseFloat(this.target.split(",")[0]);
					this.targetY = this.initialY - parseFloat(this.target.split(",")[1]);
				}
				this.tweenInitialX = this.initialX;
				this.tweenInitialY = this.initialY;
				this.tweenTargetX = this.targetX;
				this.tweenTargetY = this.targetY;
			} else {
				if (!isCurrent) {
					if (!this.reverse) {
						this.inst.width = this.tweenSaveWidth;
						this.inst.height = this.tweenSaveHeight;
					} else {
						this.inst.width = parseFloat(this.target.split(",")[0]);
						this.inst.height = parseFloat(this.target.split(",")[1]);
					}
				}
				this.initialX = this.inst.width;
				this.initialY = this.inst.height;
				if (!this.reverse) {
					this.targetX = parseFloat(this.target.split(",")[0]);
					this.targetY = parseFloat(this.target.split(",")[1]);
				} else {
					this.targetX = this.tweenSaveWidth;
					this.targetY = this.tweenSaveHeight;
				}
				this.tweenInitialX = this.initialX;
				this.tweenInitialY = this.initialY;
				this.tweenTargetX = this.targetX;
				this.tweenTargetY = this.targetY;
			}
			if (this.playmode == -6) {
				this.tweenTargetX = this.tweenSaveWidth;
				this.tweenTargetY = this.tweenSaveHeight;
			}
		} else {
;
		}
		this.lastKnownValue = this.tweenInitialX;
		this.lastKnownX = this.tweenInitialX;
		this.lastKnownY = this.tweenInitialY;
		this.initiating = parseFloat(this.wait.split(",")[0]);
		this.cooldown = parseFloat(this.wait.split(",")[1]);
		if ((this.initiating < 0) || (isNaN(this.initiating)))	this.initiating = 0;
		if ((this.cooldown < 0) || (isNaN(this.cooldown)))	this.cooldown = 0;
		if (isCurrent) this.initial = "current";
		if (targetIsCurrent) this.target = "current";
		if (isTargettingObject) this.target = "OBJ";
	};
	function easeOutBounce(t,b,c,d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	}
	behinstProto.easeFunc = function (t, b, c, d)
	{
		switch (this.easing) {
		case 0:		// linear
			return c*t/d + b;
		case 1:		// easeInQuad
			return c*(t/=d)*t + b;
		case 2:		// easeOutQuad
			return -c *(t/=d)*(t-2) + b;
		case 3:		// easeInOutQuad
			if ((t/=d/2) < 1) return c/2*t*t + b;
			return -c/2 * ((--t)*(t-2) - 1) + b;
		case 4:		// easeInCubic
			return c*(t/=d)*t*t + b;
		case 5:		// easeOutCubic
			return c*((t=t/d-1)*t*t + 1) + b;
		case 6:		// easeInOutCubic
			if ((t/=d/2) < 1)
				return c/2*t*t*t + b;
			return c/2*((t-=2)*t*t + 2) + b;
		case 7:		// easeInQuart
			return c*(t/=d)*t*t*t + b;
		case 8:		// easeOutQuart
			return -c * ((t=t/d-1)*t*t*t - 1) + b;
		case 9:		// easeInOutQuart
			if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
			return -c/2 * ((t-=2)*t*t*t - 2) + b;
		case 10:		// easeInQuint
			return c*(t/=d)*t*t*t*t + b;
		case 11:		// easeOutQuint
			return c*((t=t/d-1)*t*t*t*t + 1) + b;
		case 12:		// easeInOutQuint
			if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
			return c/2*((t-=2)*t*t*t*t + 2) + b;
		case 13:		// easeInCircle
			return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
		case 14:		// easeOutCircle
			return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
		case 15:		// easeInOutCircle
			if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
			return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
		case 16:		// easeInBack
			var s = 0;
			if (s==0) s = 1.70158;
			return c*(t/=d)*t*((s+1)*t - s) + b;
		case 17:		// easeOutBack
			var s = 0;
			if (s==0) s = 1.70158;
			return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
		case 18:		// easeInOutBack
			var s = 0;
			if (s==0) s = 1.70158;
			if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
			return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
		case 19:	//easeInElastic
			var a = 0;
			var p = 0;
			if (t==0) return b;  if ((t/=d)==1) return b+c; if (p==0) p=d*.3;
			if (a==0 || a < Math.abs(c)) { a=c; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (c/a);
			return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		case 20:	//easeOutElastic
			var a = 0;
			var p = 0;
			if (t==0) return b;  if ((t/=d)==1) return b+c;  if (p == 0) p=d*.3;
			if (a==0 || a < Math.abs(c)) { a=c; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (c/a);
			return (a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b);
		case 21:	//easeInOutElastic
			var a = 0;
			var p = 0;
			if (t==0) return b;
			if ((t/=d/2)==2) return b+c;
			if (p==0) p=d*(.3*1.5);
			if (a==0 || a < Math.abs(c)) { a=c; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (c/a);
			if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
			return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
		case 22:	//easeInBounce
			return c - easeOutBounce(d-t, 0, c, d) + b;
		case 23:	//easeOutBounce
			return easeOutBounce(t,b,c,d);
		case 24:	//easeInOutBounce
			if (t < d/2) return (c - easeOutBounce(d-(t*2), 0, c, d) + b) * 0.5 +b;
			else return easeOutBounce(t*2-d, 0, c, d) * .5 + c*.5 + b;
		case 25:	//easeInSmoothstep
			var mt = (t/d) / 2;
			return (2*(mt * mt * (3 - 2*mt)));
		case 26:	//easeOutSmoothstep
			var mt = ((t/d) + 1) / 2;
			return ((2*(mt * mt * (3 - 2*mt))) - 1);
		case 27:	//easeInOutSmoothstep
			var mt = (t / d);
			return (mt * mt * (3 - 2*mt));
		};
		return 0;
	};
	behinstProto.saveToJSON = function ()
	{
		return {
		    "i": this.i,
			"active": this.active,
			"tweened": this.tweened,
			"easing": this.easing,
			"initial": this.initial,
			"target": this.target,
			"duration": this.duration,
			"wait": this.wait,
			"playmode": this.playmode,
			"value": this.value,
			"coord_mode": this.coord_mode,
			"forceInit": this.forceInit,
			"group": this.group,
			"repeatcount":this.repeatcount,
			"targetObject": this.targetObject,
			"pingpongCounter": this.pingpongCounter,
			"isPaused": this.isPaused,
			"initialX": this.initialX,
			"initialY": this.initialY,
			"targetX": this.targetX,
			"targetY": this.targetY,
			"tweenSaveWidth": this.tweenSaveWidth,
			"tweenSaveHeight": this.tweenSaveHeight,
			"tweenSaveAngle": this.tweenSaveAngle,
			"tweenSaveX": this.tweenSaveX,
			"tweenSaveY": this.tweenSaveY,
			"tweenSaveValue": this.tweenSaveValue,
			"tweenInitialX": this.tweenInitialX,
			"tweenInitialY": this.tweenInitialY,
			"tweenTargetX": this.tweenTargetX,
			"tweenTargetY": this.tweenTargetY,
			"tweenTargetAngle": this.tweenTargetAngle,
			"ratio": this.ratio,
			"reverse": this.reverse,
			"rewindMode": this.rewindMode,
			"doTweenX": this.doTweenX,
			"doTweenY": this.doTweenY,
			"loop": this.loop,
			"initiating": this.initiating,
			"cooldown": this.cooldown,
			"lastPlayMode": this.lastPlayMode,
			"lastKnownValue": this.lastKnownValue,
			"lastKnownX": this.lastKnownX,
			"lastKnownY": this.lastKnownY,
			"onStarted": this.onStarted,
			"onStartedDone": this.onStartedDone,
			"onWaitEnd": this.onWaitEnd,
			"onWaitEndDone": this.onWaitEndDone,
			"onEnd": this.onEnd,
			"onEndDone": this.onEndDone,
			"onCooldown": this.onCooldown,
			"onCooldownDone": this.onCooldownDone,
			"onCountEnd":this.onCountEnd,
		};
	};
	behinstProto.loadFromJSON = function (o)
	{
			this.i = o["i"];
			this.active = o["active"];
			this.tweened = o["tweened"];
			this.easing = o["easing"];
			this.initial = o["initial"];
			this.target = o["target"];
			this.duration = o["duration"];
			this.wait = o["wait"];
			this.playmode = o["playmode"];
			this.value = o["value"];
			this.coord_mode = o["coord_mode"];
			this.forceInit = o["forceInit"];
			this.group = o["group"];
			this.repeatcount = o["repeatcount"];
			this.targetObject = o["targetObject"];
			this.pingpongCounter = o["pingpongCounter"];
			this.isPaused = o["isPaused"];
			this.initialX = o["initialX"];
			this.initialY = o["initialY"];
			this.targetX = o["targetX"];
			this.targetY = o["targetY"];
			this.tweenSaveWidth = o["tweenSaveWidth"];
			this.tweenSaveHeight = o["tweenSaveHeight"];
			this.tweenSaveAngle = o["tweenSaveAngle"];
			this.tweenSaveX = o["tweenSaveX"];
			this.tweenSaveY = o["tweenSaveY"];
			this.tweenSaveValue = o["tweenSaveValue"];
			this.tweenInitialX = o["tweenInitialX"];
			this.tweenInitialY = o["tweenInitialY"];
			this.tweenTargetX = o["tweenTargetX"];
			this.tweenTargetY = o["tweenTargetY"];
			this.tweenTargetAngle = o["tweenTargetAngle"];
			this.ratio = o["ratio"];
			this.reverse = o["reverse"];
			this.rewindMode = o["rewindMode"];
			this.doTweenX = o["doTweenX"];
			this.doTweenY = o["doTweenY"];
			this.loop = o["loop"];
			this.initiating = o["initiating"];
			this.cooldown = o["cooldown"];
			this.lastPlayMode = o["lastPlayMode"];
			this.lastKnownValue = o["lastKnownValue"];
			this.lastKnownX = o["lastKnownX"];
			this.lastKnownY = o["lastKnownY"];
			this.onStarted = o["onStarted"];
			this.onStartedDone = o["onStartedDone"];
			this.onWaitEnd = o["onWaitEnd"];
			this.onWaitEndDone = o["onWaitEndDone"]
			this.onEnd = o["onEnd"];
			this.onEndDone = o["onEndDone"];
			this.onCooldown = o["onCooldown"];
			this.onCooldownDone = o["onCooldownDone"];
			this.onCountEnd = o["onCountEnd"];
			this.groupSync();
	};
	behinstProto.tick = function ()
	{
		var dt = this.runtime.getDt(this.inst);
		var isForceStop = (this.i == -1);
		if (!this.active || dt === 0)
			return;
		if (this.i == 0) {
			if (!this.onStarted) {
				this.onStarted = true;
				this.onStartedDone = false;
				this.onWaitEnd = false;
				this.onWaitEndDone = false;
				this.onEnd = false;
				this.onEndDone = false;
				this.onCooldown = false;
				this.onCooldownDone = false;
				this.runtime.trigger(cr.behaviors.rex_lunarray_Tween_mod.prototype.cnds.OnStart, this.inst);
				this.onStartedDone = true;
			}
		}
		if (this.i == -1) {
			this.i = this.initiating + this.duration + this.cooldown;
		} else {
			this.i += dt;
		}
		if (this.i <= this.initiating) {
			return;
		} else {
			if (this.onWaitEnd == false) {
				this.onWaitEnd = true;
				this.runtime.trigger(cr.behaviors.rex_lunarray_Tween_mod.prototype.cnds.OnWaitEnd, this.inst);
				this.onWaitEndDone = true;
			}
		}
		if (this.i <= (this.duration + this.initiating)) {
			var factor = this.easeFunc(this.i-this.initiating, 0, 1, this.duration);
			if (this.tweened == 0) {
				if (this.coord_mode == 1) {
					if (this.inst.x !== this.lastKnownX) {
						this.tweenInitialX += (this.inst.x - this.lastKnownX);
						this.tweenTargetX += (this.inst.x - this.lastKnownX);
					}
					if (this.inst.y !== this.lastKnownY) {
						this.tweenInitialY += (this.inst.y - this.lastKnownY);
						this.tweenTargetY += (this.inst.y - this.lastKnownY);
					}
				} else {
					if (this.inst.x !== this.lastKnownX)
						this.tweenInitialX += (this.inst.x - this.lastKnownX);
					if (this.inst.y !== this.lastKnownY)
						this.tweenInitialY += (this.inst.y - this.lastKnownY);
				}
				this.inst.x = this.tweenInitialX + (this.tweenTargetX - this.tweenInitialX) * factor;
				this.inst.y = this.tweenInitialY + (this.tweenTargetY - this.tweenInitialY) * factor;
				this.lastKnownX = this.inst.x;
				this.lastKnownY = this.inst.y;
			} else if ((this.tweened == 1) || (this.tweened == 2) || (this.tweened == 3)) {
				if (this.inst.width !== this.lastKnownX)
					this.tweenInitialX = this.inst.width;
				if (this.inst.height !== this.lastKnownY)
					this.tweenInitialY = this.inst.height;
				if (this.doTweenX) {
					this.inst.width = this.tweenInitialX + (this.tweenTargetX - this.tweenInitialX) * factor;
				}
				if (this.doTweenY) {
					this.inst.height = this.tweenInitialY + (this.tweenTargetY - this.tweenInitialY) * factor;
				} else {
					if (this.tweened == 1) {
						this.inst.height = this.inst.width * this.ratio;
					}
				}
				this.lastKnownX = this.inst.width;
				this.lastKnownY = this.inst.height;
			} else if (this.tweened == 4) {
				var tangle = this.tweenInitialX + (this.tweenTargetAngle - this.tweenInitialX) * factor;
				if (this.i >= (this.duration + this.initiating))
					tangle = this.tweenTargetAngle;
				this.inst.angle = cr.clamp_angle(tangle);
			} else if (this.tweened == 5) {
				if (this.coord_mode == 1) {
					if (this.inst.opacity !== this.lastKnownX)
						this.tweenInitialX = this.inst.opacity;
				}
				this.inst.opacity = this.tweenInitialX + (this.tweenTargetX - this.tweenInitialX) * factor;
				this.lastKnownX = this.inst.opacity;
			} else if (this.tweened == 6) {
				this.value = this.tweenInitialX + (this.tweenTargetX - this.tweenInitialX) * factor;
			} else if (this.tweened == 7) {
				if (this.coord_mode == 1) {
					if (this.inst.width !== this.lastKnownX)
						this.tweenInitialX = this.inst.width;
					if (this.inst.height !== this.lastKnownY)
						this.tweenInitialY = this.inst.height;
				}
				if (this.doTweenX) this.inst.width = this.tweenInitialX + (this.tweenTargetX - this.tweenInitialX) * factor;
				if (this.doTweenY) this.inst.height = this.tweenInitialY + (this.tweenTargetY - this.tweenInitialY) * factor;
				this.lastKnownX = this.inst.width;
				this.lastKnownY = this.inst.height;
			}
			this.inst.set_bbox_changed();
		}
		if (this.i >= this.duration + this.initiating) {
			this.doEndFrame(isForceStop);
			this.inst.set_bbox_changed();
			if (this.onEnd == false) {
				this.onEnd = true;
				this.runtime.trigger(cr.behaviors.rex_lunarray_Tween_mod.prototype.cnds.OnEnd, this.inst);
				this.onEndDone = true;
			}
		}
	};
	behinstProto.doEndFrame = function (isForceStop)
	{
		switch (this.tweened) {
		case 0:		// position
			this.inst.x = this.tweenTargetX;
			this.inst.y = this.tweenTargetY;
			break;
		case 1:		// size
			if (this.doTweenX) this.inst.width = this.tweenTargetX;
			if (this.doTweenY) {
				this.inst.height = this.tweenTargetY;
			} else {
				this.inst.height = this.inst.width * this.ratio;
			}
			break;
		case 2:		// width
			this.inst.width = this.tweenTargetX;
			break;
		case 3:		// height
			this.inst.height = this.tweenTargetY;
			break;
		case 4:		// angle
			var tangle = this.tweenTargetAngle;
			this.inst.angle = cr.clamp_angle(tangle);
			this.lastKnownValue = this.inst.angle;
			break;
		case 5:		// opacity
			this.inst.opacity = this.tweenTargetX;
			break;
		case 6:		// value
			this.value = this.tweenTargetX;
			break;
		case 7:		// size
			if (this.doTweenX) this.inst.width = this.tweenTargetX;
			if (this.doTweenY) this.inst.height = this.tweenTargetY;
			break;
		}
		if (this.repeatcount > 0)
		    this.repeatcount -= 1;
		if (this.i >= this.duration + this.initiating + this.cooldown) {
			if (this.playmode == 0) {
				this.active = false;
				this.reverse = false;
				this.i = this.duration + this.initiating + this.cooldown;
                this.onCountEnd = true;
			} else if (this.playmode == 1) {
				this.i = 0;
				this.init();
				this.onCountEnd = (this.repeatcount == 0);
				this.active = (!this.onCountEnd);
			} else if (this.playmode == 2) {
				if (isForceStop) {
					this.reverse = false;
					this.init();
				} else {
					this.reverse = !this.reverse;
					this.i = 0;
					this.init();
					this.onCountEnd = (this.repeatcount == 0);
				    this.active = (!this.onCountEnd);
				}
			} else if (this.playmode == 3) {
				this.runtime.DestroyInstance(this.inst);
			} else if (this.playmode == 4) {
				this.loop = true;
				this.i = 0;
				this.init();
				this.onCountEnd = (this.repeatcount == 0);
				this.active = (!this.onCountEnd);
			} else if (this.playmode == 5) {
				if (isForceStop) {
					this.reverse = false;
					this.init();
				} else {
					if (this.pingpongCounter <= 0) {
						this.i = this.duration + this.initiating + this.cooldown;
						this.onCountEnd = (this.repeatcount == 0);
				        this.active = (!this.onCountEnd);
					} else {
						if (!this.reverse) {
							this.pingpongCounter -= 1;
							this.reverse = true;
							this.i = 0;
							this.init();
							this.active = true;
						} else {
							this.pingpongCounter -= 1;
							this.reverse = false;
							this.i = 0;
							this.init();
							this.active = true;
						}
					}
				}
			} else if (this.playmode == -6) {
				this.playmode = this.lastPlayMode;
				this.reverse = false;
				this.i = 0;
				this.active = false;
			} else if (this.playmode == 6) {
				this.reverse = false;
				this.i = this.duration + this.initiating + this.cooldown;
				this.active = false;
                this.onCountEnd = true;
			}
		}
		if (this.onCooldown == false) {
			this.onCooldown = true;
			this.runtime.trigger(cr.behaviors.rex_lunarray_Tween_mod.prototype.cnds.OnCooldownEnd, this.inst);
			this.onCooldownDone = true;
		}
		if (this.onCountEnd)
		{
		    this.runtime.trigger(cr.behaviors.rex_lunarray_Tween_mod.prototype.cnds.OnCountEnd, this.inst);
		    this.onCountEnd = false;
		}
	}
	behaviorProto.cnds = {};
	var cnds = behaviorProto.cnds;
	cnds.IsActive = function ()
	{
		return this.active;
	};
	cnds.CompareGroupProgress = function (cmp, v)
	{
		var x = [];
		cr.lunarray_tweenGroup[this.group].forEach(function (value) {
			x.push((value.i / (value.duration + value.initiating + value.cooldown)));
		} );
		return cr.do_cmp(	Math.min.apply(null, x), cmp, v );
	}
	cnds.CompareProgress = function (cmp, v)
	{
		return cr.do_cmp((this.i / (this.duration + this.initiating + this.cooldown)), cmp, v);
	};
	cnds.OnStart = function ()
	{
		if (this.onStartedDone === false) {
			return this.onStarted;
		}
	};
    cnds.OnWaitEnd = function ()
	{
		if (this.onWaitEndDone === false) {
			return this.onWaitEnd;
		}
	};
    cnds.OnEnd = function (a, b, c)
	{
		if (this.onEndDone === false) {
			return this.onEnd;
		}
	};
    cnds.OnCooldownEnd = function ()
	{
		if (this.onCooldownDone === false) {
			return this.onCooldown;
		}
	};
    cnds.OnCountEnd = function ()
	{
		return this.onCountEnd;
	};
	behaviorProto.acts = {};
	var acts = behaviorProto.acts;
	acts.SetActive = function (a)
	{
		this.active = (a === 1);
	};
	acts.StartGroup = function (force, sgroup)
	{
		if (sgroup === "") sgroup = this.group;
		var groupReady = (force === 1) || cr.lunarray_tweenGroup[sgroup].every(function(value2) { return !value2.active; } );
		if ( groupReady ) {
			cr.lunarray_tweenGroup[sgroup].forEach(
				function(value) {
					if (force === 1) {
						acts.Force.apply(value);
					} else {
						acts.Start.apply(value);
					}
				}
			);
		}
	}
	acts.StopGroup = function (stopmode, sgroup)
	{
		if (sgroup === "") sgroup = this.group;
		cr.lunarray_tweenGroup[sgroup].forEach( function(value) {
			acts.Stop.apply(value, [stopmode]);
		} );
	}
	acts.ReverseGroup = function (force, rewindMode, sgroup)
	{
		if (sgroup === "") sgroup = this.group;
		var groupReady = (force === 1) || cr.lunarray_tweenGroup[sgroup].every(function(value2) { return !value2.active; } );
		if ( groupReady ) {
			cr.lunarray_tweenGroup[sgroup].forEach(
				function(value) {
					if (force === 1) {
						acts.ForceReverse.apply(value, [rewindMode]);
					} else {
						acts.Reverse.apply(value, [rewindMode]);
					}
				}
			);
		}
	}
	acts.Force = function ()
	{
		this.loop = (this.playmode === 4);
		if (this.playmode == 5) this.pingpongCounter = 1;
		if ((this.playmode == 6) || (this.playmode == -6)) {
			if (this.i < this.duration + this.cooldown + this.initiating) {
				this.reverse = false;
				this.init();
				this.active = true;
			}
		} else {
			this.reverse = false;
			this.i = 0;
			this.init();
			this.active = true;
		}
	};
	acts.ForceReverse = function (rewindMode)
	{
		this.rewindMode = (rewindMode == 1);
		this.loop = (this.playmode === 4);
		if (this.playmode == 5) this.pingpongCounter = 1;
		if ((this.playmode == 6) || (this.playmode == -6)) {
			if (this.i < this.duration + this.cooldown + this.initiating) {
				this.reverse = true;
				this.init();
				this.active = true;
			}
		} else {
			if (rewindMode) {
				if (this.pingpongCounter == 1) {
					if (this.i >= this.duration + this.cooldown + this.initiating) {
						this.reverse = true;
						this.i = 0;
						this.pingpongCounter = 2;
						this.init();
						this.active = true;
					}
				}
			} else {
				this.reverse = true;
				this.i = 0;
				this.init();
				this.active = true;
			}
		}
	};
	acts.Start = function ()
	{
		if (!this.active) {
		    this.repeatcount = this.repeatcount_save;
			this.loop = (this.playmode === 4);
			if (this.playmode == 5) this.pingpongCounter = 1;
			if ((this.playmode == 6) || (this.playmode == -6)) {
				if (this.i < this.duration + this.cooldown + this.initiating) {
					this.reverse = false;
					this.init();
					this.active = true;
				}
			} else {
				this.pingpongCounter = 1;
				this.reverse = false;
				this.i = 0;
				this.init();
				this.active = true;
			}
		}
	};
	acts.Stop = function (stopmode)
	{
		if (this.active) {
			if ((this.playmode == 2) || (this.playmode == 4)) {
				if (this.reverse) {
					this.i = 0;
				} else {
					this.i = -1;
				}
			} else {
				if (stopmode == 1) {
					this.saveState();
				} else if (stopmode == 0) {
					this.i = this.initiating + this.cooldown + this.duration;
				} else {
					this.i = 0;
				}
			}
			this.tick();
			this.active = false;
		}
	};
	acts.Pause = function () {
		if (this.active) {
			this.isPaused = true;
			this.active = false;
		}
	}
	acts.Resume = function () {
		if (this.isPaused) {
			this.active = true;
			this.isPaused = false;
		} else {
			if (!this.active) {
				this.reverse = false;
				this.i = 0;
				this.init();
				this.active = true;
			}
		}
	}
	acts.Reverse = function (rewindMode)
	{
		this.rewindMode = (rewindMode == 1);
		if (!this.active) {
			this.loop = (this.playmode === 4);
			if (this.playmode == 5) this.pingpongCounter = 1;
			if ((this.playmode == 6) || (this.playmode == -6)) {
				if (this.i < this.duration + this.cooldown + this.initiating) {
					this.reverse = true;
					this.init();
					this.active = true;
				}
			} else {
				if (rewindMode) {
					if (this.pingpongCounter == 1) {
						if (this.i >= this.duration + this.cooldown + this.initiating) {
							this.reverse = true;
							this.i = 0;
							this.pingpongCounter = 2;
							this.init();
							this.active = true;
						}
					}
				} else {
					this.reverse = true;
					this.i = 0;
					this.init();
					this.active = true;
				}
			}
		}
	};
	acts.SetDuration = function (x)
	{
		this.duration = x;
	};
	acts.SetWait = function (x)
	{
		this.wait = x;
		this.initiating = parseFloat(this.wait.split(",")[0]);
		this.cooldown = parseFloat(this.wait.split(",")[1]);
		if ((this.initiating < 0) || (isNaN(this.initiating)))	this.initiating = 0;
		if ((this.cooldown < 0) || (isNaN(this.cooldown)))	this.cooldown = 0;
	};
	acts.SetTarget = function (x)
	{
		if (typeof(x) == "string") {
			this.target = x;
			this.targetX = parseFloat(x.split(",")[0]);
			this.targetY = parseFloat(x.split(",")[1]);
		} else {
			this.target = x;
			this.targetX = x;
		}
		if (!this.active) {
			this.init();
		} else {
		}
	};
	acts.SetTargetObject = function (obj)
	{
		if (!obj)
			return;
		var otherinst = obj.getFirstPicked();
		if (!otherinst)
			return;
		this.targetObject = otherinst;
		this.target = "OBJ";
	};
	acts.SetTargetX = function (x)
	{
		if ((this.tweened == 2) || (this.tweened == 3) || (this.tweened == 4) || (this.tweened == 5) || (this.tweened == 6)) {
			if (typeof(x) == "string") {
				this.target = parseFloat(x.split(",")[0]);
			} else {
				this.target = ""+x+","+this.targetY;
			}
			this.targetX = this.target;
		} else {
			var currY = this.target.split(",")[1];
			this.target = String(x) + "," + currY;
			this.targetX = parseFloat(this.target.split(",")[0]);
			this.targetY = parseFloat(this.target.split(",")[1]);
		}
		if (!this.active) {
			this.saveState();
			this.init();
		} else {
		}
	};
	acts.SetTargetY = function (x)
	{
		if ((this.tweened == 2) || (this.tweened == 3) || (this.tweened == 4) || (this.tweened == 5) || (this.tweened == 6)) {
			if (typeof(x) == "string") {
				this.target = parseFloat(x)+"";
			} else {
				this.target = this.targetX+","+x;
			}
			this.targetX = this.target;
		} else {
			var currX = this.target.split(",")[0];
			this.target = currX + "," + String(x);
			this.targetX = parseFloat(this.target.split(",")[0]);
			this.targetY = parseFloat(this.target.split(",")[1]);
		}
		if (!this.active) {
			this.saveState();
			this.init();
		} else {
		}
	};
	acts.SetInitial = function (x)
	{
		if (typeof(x) == "string") {
			this.initial = x;
			this.initialX = parseFloat(x.split(",")[0]);
			this.initialY = parseFloat(x.split(",")[1]);
		} else {
			this.initial = ""+x;
			this.initialX = x;
		}
		if (this.tweened == 6) {
			this.value = this.initialX;
		}
		if (!this.active) {
			this.saveState();
			this.init();
		} else {
		}
	};
	acts.SetInitialX = function (x)
	{
		if ((this.tweened == 2) || (this.tweened == 3) || (this.tweened == 4) || (this.tweened == 5) || (this.tweened == 6)) {
			if (typeof(x) == "string") {
				this.initial = parseFloat(x);
			} else {
				this.initial = ""+x+","+this.initialY;
			}
			this.initialX = this.initial;
		} else {
			if (this.initial == "") this.initial = "current";
			if (this.initial == "current") {
				var currY = this.tweenSaveY;
			} else {
				var currY = this.initial.split(",")[1];
			}
			this.initial = String(x) + "," + currY;
			this.initialX = parseFloat(this.initial.split(",")[0]);
			this.initialY = parseFloat(this.initial.split(",")[1]);
		}
		if (this.tweened == 6) {
			this.value = this.initialX;
		}
		if (!this.active) {
			this.saveState();
			this.init();
		} else {
		}
	};
	acts.SetInitialY = function (x)
	{
		if ((this.tweened == 2) || (this.tweened == 3) || (this.tweened == 4) || (this.tweened == 5) || (this.tweened == 6)) {
			if (typeof(x) == "string") {
				this.initial = parseFloat(x);
			} else {
				this.initial = ""+this.initialX+","+x;
			}
			this.initialX = this.initial;
		} else {
			if (this.initial == "") this.initial = "current";
			if (this.initial == "current") {
				var currX = this.tweenSaveX;
			} else {
				var currX = this.initial.split(",")[0];
			}
			this.initial = currX + "," + String(x);
			this.initialX = parseFloat(this.initial.split(",")[0]);
			this.initialY = parseFloat(this.initial.split(",")[1]);
		}
		if (!this.active) {
			this.saveState();
			this.init();
		} else {
		}
	};
	acts.SetValue = function (x)
	{
		this.value = x;
	};
	acts.SetTweenedProperty = function (m)
	{
		this.tweened = m;
	};
	acts.SetEasing = function (w)
	{
		this.easing = w;
	};
	acts.SetPlayback = function (x)
	{
		this.playmode = x;
	};
	acts.SetParameter = function (tweened, playmode, easefunction, initial, target, duration, wait, cmode)
	{
        if (typeof(easefunction) == "string")
        {
            easefunction = alias_map[easefunction];
            if (easefunction == null)
                easefunction = 0;
        }
		this.tweened = tweened;
		this.playmode = playmode;
		this.easing = easefunction;
		acts.SetInitial.apply(this, [initial]);
		acts.SetTarget.apply(this, [target]);
		acts.SetDuration.apply(this, [duration]);
		acts.SetWait.apply(this, [wait]);
		this.coord_mode = cmode;
		this.saveState();
	};
    var alias_map = {};
	acts.SetEasingAlias = function (alias, easefunction)
	{
		alias_map[alias] = easefunction;
	};
	behaviorProto.exps = {};
	var exps = behaviorProto.exps;
	exps.Progress = function (ret)
	{
		ret.set_float(this.i / (this.duration + this.initiating + this.cooldown));
	};
	exps.ProgressTime = function (ret)
	{
		ret.set_float(this.i);
	};
	exps.Duration = function (ret)
	{
		ret.set_float(this.duration);
	};
	exps.Initiating = function (ret)
	{
		ret.set_float(this.initiating);
	};
	exps.Cooldown = function (ret)
	{
		ret.set_float(this.cooldown);
	};
	exps.Target = function (ret)
	{
		ret.set_string(this.target);
	};
	exps.Value = function (ret)
	{
		ret.set_float(this.value);
	};
	exps.isPaused = function (ret)
	{
		ret.set_int(this.isPaused ? 1: 0);
	};
}());
cr.getObjectRefTable = function () { return [
	cr.plugins_.Audio,
	cr.plugins_.MeiriqCommon_v2,
	cr.plugins_.Browser,
	cr.plugins_.MeiriqTvCommon_v2,
	cr.plugins_.Function,
	cr.plugins_.Keyboard,
	cr.plugins_.Particles,
	cr.plugins_.Rex_FSM,
	cr.plugins_.TiledBg,
	cr.plugins_.Touch,
	cr.plugins_.Sprite,
	cr.plugins_.Spritefont2,
	cr.plugins_.Text,
	cr.behaviors.Rotate,
	cr.behaviors.Pin,
	cr.behaviors.Fade,
	cr.behaviors.Flash,
	cr.behaviors.Bullet,
	cr.behaviors.rex_lunarray_Tween_mod,
	cr.system_object.prototype.cnds.OnLayoutStart,
	cr.system_object.prototype.cnds.CompareVar,
	cr.plugins_.Sprite.prototype.acts.SetAnim,
	cr.plugins_.Touch.prototype.cnds.OnTouchObject,
	cr.system_object.prototype.acts.SetVar,
	cr.plugins_.Audio.prototype.acts.SetMasterVolume,
	cr.plugins_.MeiriqCommon_v2.prototype.cnds.onHome,
	cr.system_object.prototype.acts.ResetGlobals,
	cr.system_object.prototype.acts.GoToLayout,
	cr.plugins_.MeiriqCommon_v2.prototype.cnds.onPause,
	cr.plugins_.Browser.prototype.acts.ExecJs,
	cr.plugins_.MeiriqCommon_v2.prototype.cnds.onResume,
	cr.plugins_.MeiriqCommon_v2.prototype.cnds.onOrientationHoriz,
	cr.plugins_.MeiriqCommon_v2.prototype.acts.hideCurtainMask,
	cr.plugins_.MeiriqCommon_v2.prototype.acts.executedHook,
	cr.plugins_.MeiriqCommon_v2.prototype.cnds.onOrientationVert,
	cr.plugins_.MeiriqCommon_v2.prototype.acts.showCurtainMask,
	cr.plugins_.Keyboard.prototype.cnds.OnKey,
	cr.plugins_.MeiriqTvCommon_v2.prototype.acts.simulateControlDown,
	cr.plugins_.MeiriqTvCommon_v2.prototype.exps.Key_Back,
	cr.plugins_.Keyboard.prototype.cnds.OnKeyReleased,
	cr.plugins_.MeiriqTvCommon_v2.prototype.acts.simulateControlUp,
	cr.system_object.prototype.cnds.Compare,
	cr.plugins_.MeiriqTvCommon_v2.prototype.exps.isPausing,
	cr.plugins_.MeiriqTvCommon_v2.prototype.cnds.onSomeKeyDownByName,
	cr.plugins_.MeiriqTvCommon_v2.prototype.exps.Key_Menu,
	cr.system_object.prototype.acts.Wait,
	cr.plugins_.MeiriqTvCommon_v2.prototype.acts.showCurtainMask,
	cr.plugins_.Browser.prototype.acts.ConsoleLog,
	cr.plugins_.MeiriqCommon_v2.prototype.cnds.onCbHook,
	cr.plugins_.MeiriqTvCommon_v2.prototype.acts.hideCurtainMask,
	cr.system_object.prototype.cnds.IsGroupActive,
	cr.system_object.prototype.cnds.EveryTick,
	cr.system_object.prototype.acts.AddVar,
	cr.system_object.prototype.acts.Scroll,
	cr.system_object.prototype.exps.random,
	cr.system_object.prototype.cnds.Else,
	cr.system_object.prototype.exps.originalwindowwidth,
	cr.system_object.prototype.exps.originalwindowheight,
	cr.system_object.prototype.cnds.Every,
	cr.system_object.prototype.exps.lerp,
	cr.system_object.prototype.exps.dt,
	cr.plugins_.Function.prototype.cnds.OnFunction,
	cr.plugins_.Sprite.prototype.acts.SetPos,
	cr.plugins_.Spritefont2.prototype.acts.SetText,
	cr.plugins_.Particles.prototype.acts.Destroy,
	cr.plugins_.Sprite.prototype.acts.Destroy,
	cr.system_object.prototype.exps.layoutwidth,
	cr.system_object.prototype.exps.layoutheight,
	cr.plugins_.Sprite.prototype.acts.SetAnimFrame,
	cr.plugins_.Sprite.prototype.acts.StopAnim,
	cr.system_object.prototype.cnds.ForEachOrdered,
	cr.plugins_.Sprite.prototype.acts.SetInstanceVar,
	cr.system_object.prototype.exps.floor,
	cr.system_object.prototype.cnds.PickByComparison,
	cr.plugins_.Sprite.prototype.acts.SetVisible,
	cr.behaviors.Fade.prototype.acts.StartFade,
	cr.plugins_.Rex_FSM.prototype.acts.GotoState,
	cr.plugins_.Rex_FSM.prototype.cnds.IsCurState,
	cr.behaviors.Fade.prototype.cnds.OnFadeOutEnd,
	cr.system_object.prototype.cnds.PickAll,
	cr.system_object.prototype.acts.SetTimescale,
	cr.behaviors.Bullet.prototype.exps.Speed,
	cr.system_object.prototype.cnds.PickRandom,
	cr.behaviors.Bullet.prototype.acts.SetSpeed,
	cr.plugins_.Sprite.prototype.acts.StartAnim,
	cr.plugins_.Sprite.prototype.acts.Spawn,
	cr.plugins_.Particles.prototype.exps.UID,
	cr.plugins_.Particles.prototype.acts.SetAngle,
	cr.behaviors.Pin.prototype.acts.Pin,
	cr.plugins_.Function.prototype.acts.CallFunction,
	cr.plugins_.Sprite.prototype.exps.Y,
	cr.plugins_.Sprite.prototype.cnds.IsVisible,
	cr.plugins_.Sprite.prototype.cnds.IsOverlapping,
	cr.plugins_.Sprite.prototype.cnds.CompareInstanceVar,
	cr.behaviors.Bullet.prototype.acts.SetEnabled,
	cr.behaviors.Flash.prototype.acts.Flash,
	cr.plugins_.Particles.prototype.cnds.PickByUID,
	cr.plugins_.Sprite.prototype.exps.IID,
	cr.system_object.prototype.exps.max,
	cr.system_object.prototype.cnds.TriggerOnce,
	cr.system_object.prototype.cnds.ForEach,
	cr.plugins_.Rex_FSM.prototype.cnds.OnEnter,
	cr.behaviors.rex_lunarray_Tween_mod.prototype.acts.Stop,
	cr.system_object.prototype.acts.CreateObject,
	cr.plugins_.Function.prototype.exps.Param,
	cr.behaviors.rex_lunarray_Tween_mod.prototype.acts.Start,
	cr.behaviors.rex_lunarray_Tween_mod.prototype.cnds.OnEnd,
	cr.behaviors.Flash.prototype.cnds.OnFlashEnded,
	cr.plugins_.Sprite.prototype.cnds.CompareX,
	cr.plugins_.Audio.prototype.cnds.IsTagPlaying,
	cr.plugins_.Audio.prototype.acts.PlayByName,
	cr.plugins_.Touch.prototype.cnds.OnTouchStart,
	cr.behaviors.Fade.prototype.cnds.OnFadeInEnd,
	cr.plugins_.MeiriqCommon_v2.prototype.exps.Hook_Start,
	cr.plugins_.Sprite.prototype.acts.SetScale,
	cr.plugins_.Sprite.prototype.exps.Height,
	cr.behaviors.Bullet.prototype.acts.SetAngleOfMotion,
	cr.behaviors.Rotate.prototype.acts.SetSpeed,
	cr.plugins_.Sprite.prototype.exps.Width,
	cr.plugins_.Sprite.prototype.cnds.IsOnScreen,
	cr.plugins_.TiledBg.prototype.acts.SetWidth,
	cr.system_object.prototype.exps.min,
	cr.plugins_.TiledBg.prototype.exps.Width,
	cr.plugins_.TiledBg.prototype.exps.X,
	cr.plugins_.MeiriqCommon_v2.prototype.exps.Hook_Restart,
	cr.system_object.prototype.exps.loadingprogress,
	cr.plugins_.Text.prototype.acts.SetText,
	cr.system_object.prototype.exps.str
];};
